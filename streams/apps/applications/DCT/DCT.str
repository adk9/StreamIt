// this pipeline performs the core DCT operation
float->float pipeline DCTcore(int N)


// this filter performs the combinations at the output
// of the DCT (look at Rao, Yim 61)



//this filter handles the case of N=2
float->float filter TwoPointDCT() {
    work push 2 pop 2 {
	float a;
	float b;
	a=pop();
	b=pop();
	push(a+b);
	push(a-b);
    }
}



// this filter mixes the inputs with correct with correct weights
float->float filter decimate(int N) {
    float[N/2] coef; //this arrays stores the coefs

    init {
	for (int i=0;i<(N/2);i++)
	    coef[i]=1/(2*sqrt(2/N)*cos((2*i+1)*pi/(2*N)));
    }

    work push N pop N {
	float[N] in_arr; //input array
	for (int i=0;i<N;i++)
	    in_arr[i]=pop();

	for (int i=0;i<N/2;i++)
	    push(in_arr[i]+in_arr[i+N/2]);

	float temp;

	for (int i=0;i<N/2;i++)
	    {
	    temp=in_arr[i]-in_arr[i+N/2];
	    push(temp*coef[i]);
	    }		
   
    }
}
	



// this round roubin splitjoin uses the reversal filter to perform the bit reversal
// operation. only the second half of a sequence is reversed.
float->float splitjoin bitrev(int N) {
    split roundrobin(N/2,N/2);
    add identity(float.TYPE);
    add reversal(N/2);
    join roundrobin(N/2,N/2);
}



// this filter takes care of the bit reversal operation necessary for 
// in the bit reversal in the DIF implementation of the DCT.

float->float filter reversal(int N) {

    work push N pop N peek N {

	for (int i=N-1; i>=0; i--)
	    push(peek(i));

	for (int i=0; i <N; i++)
	    pop();

    }
}










