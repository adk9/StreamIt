

/* This is the subband synthesis block it performs up sampling by interleaving samples with zeroes and then filtering and frequency shifting the output of this filter is used for target detection */

import streamit.*;

// this pipline performs the first few blocks in subband synthesis.

complex[N_cnb][N_srg][N_dop]->complex[N_cnb][N_srg*N_up][N_dop] pipline SubSynth(int N_cnb,int N_srg,int N_dop,int N_up,int N_lp, complex w, complex[] f_lp){
    add FormChg20(N_cnb,N_srg,N_dop);
    add ElSynth(N_cnb,N_srg,N_dop,N_up,N_lp,w,f_lp);
    add FromChg21(N_cnb, N_srg*N_up, N_dop);
}

								     
// this SplitJoin gets as its input the elements of different subbbands and pushes them through RnAnal in form of one dimentional arrays
complex[N_srg]-> complex[N_srg*N_up] splitjoin ElSynth(int N_cnb,int N_srg, int N_dop,int N_up,int N_lp,complex W, complex[] f_lp)
{
	split roundrobin;
	for (int i=0; i< N_cnb; i++)
	    for (int j=0; j < N_dop; j ++)
		add(new AnalTd(N_srg,N_up,N_lp,W,f_lp));
	join roundrobin;
 }

	
// this pipeline  performes the upsampling, low pass filtering and frequency shifting for the array.
  		    
complex[N_srg]->complex[ N_srg*N_up] pipeline AnalTd(int N_rg,int N_dn,int N_lp,int N_td,complex W, complex[] h_lp,complex[] h_td){ 
	add DownSamp(N_N_dn);
        add arrayFIR(N_srg*N_up,N_lp,f_lp);
	add FreqShift(N_rg,W);
	
}



//This Filter performs the Frequency shifting, each time it is invoked, elements of a sequence of length N_rg are read and they are multiplied by W^n Where n is the index.

complex[N]->complex[N] filter FreqShift (int N, complex w);{
    complex[N] X ; // X contains the coefficients
 
    init {
	X[0]=1;
	for (int i=1; i <N; i++)
	    X[i]=X[i-1]*w;	
		    
                }
    
  work push 1 pop 1 peek 0  {

      complex[N] y;
      y=pop();
      for (int i=1; i < N; i++)
	  y[i]=y[i]*X[i];
      push(y);      

  }

}
		    
	  

	
		
//This Filter performs the down sampling task on imaginary numbers

complex[N_in]->complex[(int)N_in/N_dn] filter DownSamp(N_in,N_dn) {
             
               init {
		    }
	       work push 1 pop 1 {
                   int N_out=(int) N_in/N_dn;
		   complex[N_in] in_arr;
		   complex[N_out] out_arr;

		   
		    output.push(input.pop());
		    for (int i=0 ; i <N_out ;i=i++)
			out_arr[i]=in_arr[i*N_dn];
		    push(out_arr);
		    
		    		 		    
	       }
}












