package at.dms.kjc.sir.linear.frequency;

import java.util.*;
import at.dms.kjc.*;
import at.dms.kjc.sir.*;
import at.dms.kjc.sir.linear.*;
import at.dms.kjc.iterator.*;
import at.dms.compiler.*;


/**
 * A LEETFrequencyReplacer replaces FIR filters (those calculating convolution sums,
 * peek=N, pop=1 push=1) of sufficient length with a conversion into the frequency
 * domain, multiplication, and convert the product back into the time domain.
 *
 * In so doing, this also increases the peek, pop and push rates to take advantage of
 * the frequency transformation.
 * 
 * $Id: LEETFrequencyReplacer.java,v 1.2 2003-01-31 22:01:35 aalamb Exp $
 **/
public class LEETFrequencyReplacer extends FrequencyReplacer{
    /** the name of the function in the C library that does fast convolution via the frequency domain. **/
    public static final String FAST_CONV_EXTERNAL = "do_fast_convolution_fftw";
    /** the name of the function in the C library that converts a buffer of real data from the time
     * domain to the frequency domain (replacing the value in the buffer with the half complex array
     * representation of the frequency response. **/
    public static final String CONVERT_EXTERNAL   = "convert_to_freq";
    /** the name of the buffer in which to place the input data. */
    public static final String INPUT_BUFFER_NAME = "timeBuffer";
    /** the prefix for the fields that we will store the transform of the filters in. **/
    public static final String FILTER_WEIGHTS_PREFIX = "freqWeightField";

    /** Constants specifying if we are making the work or the init work function **/
    public static final int INITWORK = 1;
    public static final int WORK = 2;

    /** The minimum size FIR we will replace. 90 came from empirical measurements. **/
    //public static final int minFIRSize = 90;
    public static final int minFIRSize = 2;
    /** We multiply the FIR size to get the target FFT size if it is not specified. **/
    public static final int fftSizeFactor = 2;
    
    
    /** the linear analyzier which keeps mappings from filters-->linear representations**/
    LinearAnalyzer linearityInformation;
    
    LEETFrequencyReplacer(LinearAnalyzer lfa) {
	if (lfa == null){
	    throw new IllegalArgumentException("Null linear filter analyzer!");
	}
	this.linearityInformation = lfa;
    }


    public void preVisitFeedbackLoop(SIRFeedbackLoop self, SIRFeedbackLoopIter iter) {}
    public void preVisitPipeline(SIRPipeline self, SIRPipelineIter iter){}
    public void preVisitSplitJoin(SIRSplitJoin self, SIRSplitJoinIter iter){}
    public void visitFilter(SIRFilter self, SIRFilterIter iter){makeReplacement(self);}

    /**
     * Does the actual work of replacing something that computes a convolution
     * sum with something that does a FFT, multiply, and then IFFT.
     */
    private void makeReplacement(SIRFilter self) {
	LinearPrinter.println(" processing " + self.getIdent());
	/* if we don't have a linear form for this stream, we are done. */
	if(!this.linearityInformation.hasLinearRepresentation(self)) {
	    LinearPrinter.println("  aborting -- not linear");
	    return;
	}

	LinearFilterRepresentation linearRep = this.linearityInformation.getLinearRepresentation(self);
	/* if there is not an FIR filter, we are done. */
	if (!linearRep.isFIR()) {
	    LinearPrinter.println("  aborting -- filter is not FIR"); 
	    return;
	}	

	/** if doing clever replacement, don't do small FIRs. **/
	if (linearRep.getPeekCount() < minFIRSize) {
 	    LinearPrinter.println("  aborting -- fir size too small: " +
				  linearRep.getPeekCount() + ". needs to be at least " +
				  minFIRSize);
	    return;
	}

	/** set the target FFT size appropriately if it hasn't already been set */
	int targetNumberOfOutputs = fftSizeFactor * linearRep.getPeekCount();
	LinearPrinter.println("  target output size: " + targetNumberOfOutputs);
	
	/* now is when we get to the fun part, we have a linear representation
	 * that computes an FIR (ef pop 1, push 1, peek x) and we want to replace it with an FFT.
	 * Note that N is the block size of the input that we are looking at. */
	int x = linearRep.getPeekCount();
	int N = calculateN(targetNumberOfOutputs,x);
	int filterSize = N+2*(x-1); // this is the size of the overall filter
	LinearPrinter.println("  creating frequency filter.\n" +
			      "   N+(x-1)=" + (N+x-1) + " (outputs per steady state)\n" + 
			      "   x=" + x + " (peek, original filter size)\n" +
			      "   filterSize=" + filterSize + " (FFT size)");
	

	/////////////// Create new fields for this filter.
	JFieldDeclaration[] newFields = self.getFields();
	
	/* make the fields to hold the transform of the weights. Note that the
	   weights are stored in "half complex array" format which is the output format
	   generated by FFTW. */
	String weightName = FILTER_WEIGHTS_PREFIX + "_0";
	JVariableDefinition weightField = makeWeightField(weightName);
	// put the weight field into the new fields of this filter
	newFields = appendFieldDeclaration(newFields, weightField);
	
	/* make the fields to hold the real and imaginary partial results between executions. */
	String partialFieldName = "freq_partial";
	JVariableDefinition partialField   = makeWeightField(partialFieldName);
	// append the partial results field on to the end of the fields
	newFields = appendFieldDeclaration(newFields, partialField);
	
	/* make a new init function */
	JMethodDeclaration freqInit = makeNewInit(linearRep, weightField, partialField,
						  filterSize, x);
	
	/* make the init work function */
	JMethodDeclaration freqInitWork = makeNewWork(INITWORK, weightField, partialField,
						      filterSize, x, N);
	
	/* make a new work function */
	JMethodDeclaration freqWork = makeNewWork(WORK, weightField, partialField,
						  filterSize, x, N);
	
	
	LinearPrinter.println("  done building new IR nodes for " + self.getIdent());
	
	LinearPrinter.println("  creating new two stage filter...");
	// Create a new filter that contains all of the new pieces that we have built
	SIRTwoStageFilter freqFilter;
	/* Note, we need to have initPeek-initPop == peek-Pop for some scheduling reason
	 * so therefore, we set the peek rate of the work function to be N+2(x-1) even though
	 * it really only needs to be N+x-1.*/
	freqFilter = new SIRTwoStageFilter(self.getParent(),              /* parent */
					   "TwoStageFreq" + self.getIdent(),/* ident */
					   newFields,                     /* fields */
					   new JMethodDeclaration[0],     /* methods -- init, work, and initWork are special*/
					   new JIntLiteral(N+x-1),        /* peek (w/ extra x-1 window...)*/
					   new JIntLiteral(N+x-1),        /* pop */
					   new JIntLiteral(N+x-1),        /* push */
					   freqWork,                      /* work */
					   N+x-1,                         /* initPeek */
					   N+x-1,                         /* initPop */
					   N+x-1,                         /* initPush */
					   freqInitWork,                  /* initWork */
					   self.getInputType(),           /* input type */
					   self.getOutputType());         /* output type */
	// need to explicitly set the init function
	freqFilter.setInit(freqInit);
	
	// now replace the current filter (self) with the frequency version
	self.getParent().replace(self, freqFilter);
	
	LinearPrinter.println("  done replacing.");
	
    }
    
    /**
     * create the field that we are going to put the filter's freqenucy response in.
     * the field is an array of floats, and we will have one array for the real part of the
     * repsonse and one array for the imaginary part of the response.
     */
    public JVariableDefinition makeWeightField(String name) {
	return new JVariableDefinition(null, /* token reference */
				       ACC_FINAL, /* modifiers */
				       getArrayType(), /* type */
				       name, /* identity */
				       null); /* initializer */
    }
    


    /* returns an array that is a field declaration for (newField)
     * appended to the original field declarations. **/
    public JFieldDeclaration[] appendFieldDeclaration(JFieldDeclaration[] originals,
						      JVariableDefinition newField) {
						     
	/* really simple -- make a new array, copy the elements from the
	 * old array and then stick in the new one. */
	JFieldDeclaration[] returnFields = new JFieldDeclaration[originals.length+1];
	for (int i=0; i<originals.length; i++) {
	    returnFields[i] = originals[i];
	}
	/* now, stick in a new field declaration. */
	returnFields[originals.length]   = new JFieldDeclaration(null, newField, null, null);
	return returnFields;
    }

    /**
     * Make an init function which assigns allocates space for the various fields
     * (frequency weight fields are of size filterSize, and partial result fields are
     * of size x-1) and 
     * calculates the DFT of the impulse response and stores it in the weight fields.
     **/
    public JMethodDeclaration makeNewInit(LinearFilterRepresentation linearRep,
					  JVariableDefinition weightField,
					  JVariableDefinition partialField,
					  int filterSize, int x) {
	
	JBlock body = new JBlock();

	
	/* calculate the weights of the fields based on the filter
	 * coefficients that are found in the linear representation. */	
	float[] time_response_r      = getRealArray(linearRep, filterSize);
	float[] time_response_i      = getImagArray(linearRep, filterSize);

	/** if there are any imaginary parts, bomb an exception. **/
	for (int i=0; i<filterSize; i++) {
	    if (time_response_i[i] != 0) {
		throw new RuntimeException("filters with imaginary responses are not supported " +
					   "for frequency replacement!");
	    }
	}
	
	/** add in statements to allocate space for the weight fields and for the partial results
	    field. The weight fields are all of the filter size (because we will store the frequency
	    representation in half complex array form (the output of FFTW). **/
 	body.addStatement(makeFieldAllocation(weightField.getIdent(), filterSize,
					      "field to store the frequency response of the filter."));
	body.addStatement(makeFieldAllocation(partialField.getIdent(),    x-1,
					      "field to store the partial results across filter firings."));
	
	
	/** copy the values of the time responses into the weight field (afterwards we will
	    run convert_to_freq on the buffer to convert the real values to their complex
	    frequency form. **/
	for (int i=0; i<filterSize; i++) {
	    body.addStatement(makeArrayAssignment(weightField, /* field */
						  i,                          /* index */
						  time_response_r[i]));  /* value */
	}

	// now, add in a callout to convert_to_freq to transform the real weights into
	// their complex form.
	// prep the args
	JExpression[] externalArgs = new JExpression[2];
	externalArgs[0] = new JFieldAccessExpression(null, new JThisExpression(null), weightField.getIdent());
	externalArgs[1] = new JIntLiteral(filterSize);
	JMethodCallExpression externalCall = new JMethodCallExpression(null,               /* token reference*/
								       null,               /* prefix */
								       CONVERT_EXTERNAL,   /* ident */
								       externalArgs);      /* args */
	JavaStyleComment[] comment = makeComment("callout to " + CONVERT_EXTERNAL +
						 " to convert from time to freq. "); 
	body.addStatement(new JExpressionStatement(null,externalCall,comment));            /* comments */


	
	/** assemble the new pieces that we made and stick them into a new method. */
	return new JMethodDeclaration(null,                 /* token reference */
				      ACC_PUBLIC,           /* modifiers */
				      CStdType.Void,        /* return type */
				      "init",               /* identifier */
				      JFormalParameter.EMPTY,/* paramters */
				      CClassType.EMPTY,     /* exceptions */
				      body,                 /* body */
				      null,                 /* java doc */
				      null);                /* java style comment */
    }

    /**
     * Create an array allocation expression. Allocates a one dimensional array of floats
     * for the field of name fieldName of fieldSize.
     **/
    public JStatement makeFieldAllocation(String fieldName, int fieldSize, String commentString) {
	JExpression fieldExpr = new JFieldAccessExpression(null, new JThisExpression(null), fieldName);
	JExpression fieldAssign = new JAssignmentExpression(null, fieldExpr, getNewArrayExpression(fieldSize));
	JavaStyleComment[] comment = makeComment(commentString); 
	return new JExpressionStatement(null, fieldAssign, comment);
    }

    
    /** Creates an assignment expression of the form: this.f[index]=value; **/
    public JStatement makeArrayAssignment(JLocalVariable field, int index, float value) {
	/* make the field access expression (eg this.field)*/
	JFieldAccessExpression fldAccessExpr;
	fldAccessExpr = new JFieldAccessExpression(null, /* token reference */
						   new JThisExpression(null), /* base */
						   field.getIdent()); /* field name */
	/* make the array access expression (eg this.field[index]*/
	JArrayAccessExpression arrAccessExpr;
	arrAccessExpr = new JArrayAccessExpression(null,                    /* token reference */
						   fldAccessExpr,           /* prefix */
						   new JIntLiteral(index)); /* accessor */
	/* the literal value to assign */
	JFloatLiteral literalValue = new JFloatLiteral(null, value);
	/* now, make the assignment expression */
	JAssignmentExpression assignExpr;
	assignExpr = new JAssignmentExpression(null,          /* token reference */
					       arrAccessExpr, /* lhs */
					       literalValue); /* rhs */
	/* return an expression statement */
	return new JExpressionStatement(null, assignExpr, new JavaStyleComment[0]);
    }

    /** Creates an assignment expression of the form: f[index]=value; **/
    public JStatement makeLocalArrayAssignment(JLocalVariable var, int index, float value) {
	/* make the local variable expression to access var */
	JLocalVariableExpression varExpr = new JLocalVariableExpression(null, var);
	/* make the field access expression (eg this.field)*/
	JArrayAccessExpression arrAccessExpr;
	arrAccessExpr = new JArrayAccessExpression(null,                    /* token reference */
						   varExpr,                 /* prefix */
						   new JIntLiteral(index)); /* accessor */
	/* the literal value to assign */
	JFloatLiteral literalValue = new JFloatLiteral(null, value);
	/* now, make the assignment expression */
	JAssignmentExpression assignExpr;
	assignExpr = new JAssignmentExpression(null,          /* token reference */
					       arrAccessExpr, /* lhs */
					       literalValue); /* rhs */
	/* return an expression statement */
	return new JExpressionStatement(null, assignExpr, new JavaStyleComment[0]);
    }

    

    /*
     * make both the work and the new work function.
     *
     * We make a function that copies N elements from the input
     * tape into a local array, calls the library function with the local array
     * and the weight field to calcluate the produce of the DFT of the input and the weight fields.
     * If we are making the initWork function, then just the middle N elements of the result are pushed
     * and if we are making the work function then the x-1 partials are added to the first x-1 elements
     * of the results and we push out the first N+x-1 elements. For both types of work we
     * then save the last x-1 elements of the DFT output in
     * the partial results fields for the next execution. Note that filterSize = N + 2(x-1).
     */
    public JMethodDeclaration makeNewWork(int functionType, /* either INITWORK or WORK */
					  JVariableDefinition weightField,
					  JVariableDefinition partialField,
					  int filterSize, int x, int N) {
	// parameter check
	if ((functionType != INITWORK) && (functionType != WORK)) {
	    throw new IllegalArgumentException("function type must be either WORK or INITWORK");
	}

	/* the body of the new work function */
	JBlock body = new JBlock();
	
	/* make a local variable for a buffer to hold values from the input tape. */
	JVariableDefinition inputBuffer;
	inputBuffer = new JVariableDefinition(null,         /* token reference */
					      0,            /* modifiers */
					      getArrayType(), /* float* */
					      INPUT_BUFFER_NAME, /* ident */
					      null);        /* initializer*/
	
	/* stick in a declaration statement for the buffer into the body of the function. */
	body.addStatement(new JVariableDeclarationStatement(null, inputBuffer, null));
	
	/* allocate space for the input buffer */
	JLocalVariableExpression buffExpr = new JLocalVariableExpression(null, inputBuffer);
	JNewArrayExpression      newExpr = getNewArrayExpression(filterSize);
	JAssignmentExpression    assignExpr = new JAssignmentExpression(null, buffExpr, newExpr);
	body.addStatement(new JExpressionStatement(null,assignExpr,makeComment("allocate space for input buffer.")));
	
	/* now, copy the data from the input tape into the buffer, element by element */
	for (int i=0; i<(N+x-1); i++) {
	    JLocalVariableExpression currentBuffExpr = new JLocalVariableExpression(null, inputBuffer);
	    JArrayAccessExpression currentAccessExpr = new JArrayAccessExpression(null, currentBuffExpr, new JIntLiteral(i));
	    SIRPeekExpression      currentPeekExpr   = new SIRPeekExpression(new JIntLiteral(i), CStdType.Float);
	    JAssignmentExpression currentAssignExpr  = new JAssignmentExpression(null, currentAccessExpr, currentPeekExpr);
	    /* note that currentAssignExpr is buff[i] = peek(i) */
	    body.addStatement(new JExpressionStatement(null, currentAssignExpr, null));
	}
	
	/* add statements to set the rest of the input buffer (eg pad with zeros). */
	for (int i=(N+x-1); i<(N+2*(x-1)); i++) {
	    body.addStatement(makeLocalArrayAssignment(inputBuffer, i, 0.0f));
	}
	
	
	/* stick in a call to the do_fast_convolution routine that gets linked in via the C library. */
	// prep the args
	JExpression[] externalArgs = new JExpression[3];
	externalArgs[0] = new JLocalVariableExpression(null, inputBuffer);
	externalArgs[1] = new JFieldAccessExpression(null, new JThisExpression(null), weightField.getIdent());
	externalArgs[2] = new JIntLiteral(filterSize);
	JMethodCallExpression externalCall = new JMethodCallExpression(null,           /* token reference */
								       null,               /* prefix */
								       FAST_CONV_EXTERNAL, /* ident */
								       externalArgs);      /* args */
	JavaStyleComment[] comment = makeComment("callout to " + FAST_CONV_EXTERNAL +
						 " to do actual DFT, mult, IDFT. "); 
	body.addStatement(new JExpressionStatement(null,externalCall,comment));            /* comments */
	
	/* if we are in the normal work function, push out the first x-1
	   values from the local buffer added to the partial results */
	if (functionType == WORK) {
	    for (int i=0; i<(x-1); i++) {
		body.addStatement(makeArrayAddAndPushStatement(partialField.getIdent(), inputBuffer, i));
	    }
	}
	
    
	//now, put in code that will push the appropriate N values of inputBuffer[x-1 to N+(x-1)]
	//back on the tape
	for (int i=(x-1); i<(N+x-1); i++) {
	    body.addStatement(makeArrayPushStatement(inputBuffer, i));
	}
	
	/* now, copy the last x-1 values in the input buffer into the partial results buffer. */
	for (int i=0; i<x-1; i++) {
	    body.addStatement(makePartialCopyExpression(partialField.getIdent(), i, inputBuffer, (N+x-1)+i));
	}
	
	
	/* now, free the memory that we allocated to buffer (this is a wicked hack,
	   as there is no notion of "free" in java/streamit */
	JExpression[] freeArgs = new JExpression[1];
	freeArgs[0] = new JLocalVariableExpression(null, inputBuffer);
	JMethodCallExpression freeCall = new JMethodCallExpression(null,     /* token reference */
								   null,     /* prefix */
								   "free",   /* ident */
								   freeArgs);/* args */
	
	comment = makeComment("call to free the buffer space");
	body.addStatement(new JExpressionStatement(null, freeCall, comment));
	     
	/* stick in the appropriate number (N+x-1) of pop calls */
	for (int i=0; i<(N+x-1); i++) {
	    body.addStatement(makePopStatement());
	}
	
	/* figure out what the name of the function should be (work, or initWork) **/
	String ident = (functionType == WORK) ? "work" : "initWork";
	
	/* wrap up all the mess that we just made into a new JMethodDeclaration and return it to the caller */
	return new JMethodDeclaration(null,                  /* token reference */
				      ACC_PUBLIC,            /* modifiers */
				      CStdType.Void,         /* return type */
				      ident,                 /* identifier */
				      JFormalParameter.EMPTY,/* paramters */
				      CClassType.EMPTY,      /* exceptions */
				      body,                  /* body */
				      null,                  /* java doc */
				      null);                 /* java style comment */
    }


    /** Makes a copy expression from the local variable to the field of the form this.field[index1] = arr[index2] **/
    public JStatement makePartialCopyExpression(String field, int index1, JLocalVariable arr, int index2) {
	/* first, make the this.field[index] expression */
	JFieldAccessExpression fieldAccessExpr = new JFieldAccessExpression(null, new JThisExpression(null), field);
	JArrayAccessExpression fieldArrayAccessExpr;
	fieldArrayAccessExpr = new JArrayAccessExpression(null, fieldAccessExpr, new JIntLiteral(index1));
	/* now make the array access expression arr[index]. **/
	JLocalVariableExpression arrExpr = new JLocalVariableExpression(null, arr);
	JArrayAccessExpression arrAccessExpr = new JArrayAccessExpression(null, arrExpr, new JIntLiteral(index2));
	/* now make the assignment expression */
	JAssignmentExpression assignExpr = new JAssignmentExpression(null, fieldArrayAccessExpr, arrAccessExpr);
	/* now write it all in an expression statement */
	return new JExpressionStatement(null, assignExpr, null);
	
    }

    /** makes a popFloat() statement. **/
    public JStatement makePopStatement() {
	return new JExpressionStatement(null, new SIRPopExpression(CStdType.Float), null);
    }

    /** makes an array push statement of the following form: push(this.field[index] + arr2[index]) **/
    public JStatement makeArrayAddAndPushStatement(String field, JLocalVariable arr, int index) {
	/* first, make the this.field[index] expression */
	JFieldAccessExpression fieldAccessExpr = new JFieldAccessExpression(null, new JThisExpression(null), field);
	JArrayAccessExpression fieldArrayAccessExpr;
	fieldArrayAccessExpr = new JArrayAccessExpression(null, fieldAccessExpr, new JIntLiteral(index));
	/* now make the array access expression arr[index]. **/
	JLocalVariableExpression arrExpr = new JLocalVariableExpression(null, arr);
	JArrayAccessExpression arrAccessExpr = new JArrayAccessExpression(null, arrExpr, new JIntLiteral(index));
	/* make the add expression */
	JAddExpression addExpr = new JAddExpression(null, fieldArrayAccessExpr, arrAccessExpr);
	/* now make the push expression */
	SIRPushExpression pushExpr = new SIRPushExpression(addExpr, CStdType.Float);
	/* and return an expression statement */
	return new JExpressionStatement(null, pushExpr, null);
    }
       
    

    /* makes an array push statement of the following form: push(arr[index]) */
    public JStatement makeArrayPushStatement(JLocalVariable arr, int index) {
	/* first make the array access expression arr[index]. **/
	JLocalVariableExpression arrExpr = new JLocalVariableExpression(null, arr);
	JArrayAccessExpression arrAccessExpr = new JArrayAccessExpression(null, arrExpr, new JIntLiteral(index));
	/* now make the push expression */
	SIRPushExpression pushExpr = new SIRPushExpression(arrAccessExpr, CStdType.Float);
	/* and return an expression statement */
	return new JExpressionStatement(null, pushExpr, null);
    }
	
    /** returns the type to use for buffers -- in this case float[] */
    public CType getArrayType() {
	return new CArrayType(CStdType.Float, 1);
    }
    
    /** make a JNewArrayStatement that allocates size elements of a float array */
    public JNewArrayExpression getNewArrayExpression(int size) {
	/* make the size array. */
	JExpression[] arrayDims = new JExpression[1];
	arrayDims[0] = new JIntLiteral(size);
	return new JNewArrayExpression(null,           /* token reference */
				       getArrayType(), /* type */
				       arrayDims,      /* size */
				       null);          /* initializer */
    }


    /* make an array of one java comments from a string. */
    public JavaStyleComment[] makeComment(String c) {
	JavaStyleComment[] container = new JavaStyleComment[1];
	container[0] = new JavaStyleComment(c,
					    true,   /* isLineComment */
					    false,  /* space before */
					    false); /* space after */
	return container;
    }


    /** returns an array of floating point numbers that correspond to the real part of the FIR filter's weights  **/
    public float[] getRealArray(LinearFilterRepresentation filterRep, int size) {return getArray(filterRep, size, 0);} 
    /** returns an array of floating point numbers that correspond to the imaginary part of the FIR filter's weights **/
    public float[] getImagArray(LinearFilterRepresentation filterRep, int size) {return getArray(filterRep, size, 1);}

    /**
     * the method that does the actual work for getRealArray and getImagArray.
     * part == 0, means get real part, part == 1 means get imaginary part.
     * if size is greater than the size of the filter rep, the rest of the array is left as 0
     * Note that the filter size is actually larger than the size of the FIR coefficients
     * in the filter's linear representation. 
     **/
    public float[] getArray(LinearFilterRepresentation filterRep, int size, int part) {
	if (!filterRep.isFIR()) {
	    throw new RuntimeException("non fir filter passed to getArray()");
	}
	/* use the matrix that is hidden inside the filter representation */
	FilterMatrix source = filterRep.getA();
	if (source.getRows() > size) {
	    throw new RuntimeException("freq response size is too small for this filter's response.");
	}
	/* allocate the return array */
	float[] arr = new float[size];

	/* pull out the parts of the matrix, one by one */
	for (int i=0; i<source.getRows(); i++) {
	    ComplexNumber currentElement = source.getElement(i,0);
	    /* assign different piece depending on part parameter */
	    arr[i] = (part == 0) ? (float)currentElement.getReal() : (float)currentElement.getImaginary();
	}

	return arr;
    }


    /**
     * calculates the appropriate size FFT to perform. It is passed a target N, the number
     * of outputs to produce, and x, the length
     * of the impuse response of the filter, and it returns the actual N, the
     * number of output points that will be produced by one execution of the
     * filter.
     **/
    public int calculateN(int targetN, int x) {
	// we know N + 2(x-1) = 2^r
	// so we calculate r as floor(lg(N+2(x-1))) +1 where lg is log base 2
	
	// and then N = 2^r - 2(x-1)
	int arg = targetN + 2*(x-1);
	int r = (int)Math.floor(Math.log(arg)/Math.log(2)) + 1;
	// now, calculate N
	int N = (int)Math.pow(2,r) - 2*(x-1);
	return N;
    }







}




