\section{Related Work}
\label{sec:related}

Several interesting projects are underway to determine how to generate
efficient programs for DSP applications. The SPIRAL
project\cite{spiral,xiong-thesis,xiong01spl,johnson01searching,egner01automatic}
aims to determine the fastest implementation for various DSP
transforms using several techniques such as group theory and
stochastic search algorithms.  SPIRAL requires the user to enter a
matrix corresponding to the desired transform, whereas our system
automatically generates the matrix from imperative C-style code.

There are many systems that allow a designer to explore design
choices, such as Matlab\cite{matlab} which is used extensively in both
academia and industry.  There are also research projects such as
\cite{covell-ade} and those described in \cite{oppenheim-symbolic}
aimed at allowing a DSP designer to explore various implementation
choices.

The ATLAS project \cite{whaley01automated} aims to automatically
produce fast libraries for linear algebra manipulations, focusing on
adaptive library generation.  FFTW \cite{frigo99fast,fftw} is a
runtime tuned library for computing the FFT as fast as possible.

% Something should be said about other stream projects and their attempts at optimizations...
% which I know very little about.

\section{Conclusion}
\label{sec:conclusion}

This paper presents a set of automated analyses for detecting,
analyzing, and optimizing linear filters in streaming applications.
Though the mathematical optimization of linear filters has been a
longtime focus of the DSP community, our techniques are novel in the
automated application of these techniques to programs that are written
in a flexible and high-level programming language.  We demonstrate
that using linear dataflow analysis, linear combination, and automated
frequency translation, we can improve \todo{performance number}.

There is becoming an increasingly ominous rift between the design and
implementation of signal processing applications.  Algorithms are
designed at a conceptual level, with modular processing blocks that
that naturally express the computation.  However, in order to obtain
good performance, each hand-tuned implementation is forced to
disregard the abstraction layers and painstakingly consider
specialized whole-program optimizations.  The StreamIt project aims to
reduce this process to a single stage in which the designers and
implementors share a set of high-level abstractions that can be
efficiently handled by the compiler.  

The linear analysis described in this paper represents a first step
towards this goal.  By automatically performing linear combination and
frequency translation, it allows programmers to write linear stream
operations in a natural and modular fashion without any performance
penalty.

\subsection{Future Work}

Linear analysis can easily be extended to incorporate a notion of
linear state.  A stateful linear node is characterized by
\begin{equation} \nonumber
\lambda=(({\mathbf A}_x, {\mathbf A}_s), ({\mathbf C}_x, {\mathbf C}_s), 
({\mathbf b}_x, {\mathbf b}_s))
\end{equation}
Each {\tt filter} in the stream graph contains a state vector
${\mathbf s}$ such that ${\mathbf y}$ at time $i$ and ${\mathbf s}$ at
time $i+1$ is given by
\begin{equation} \nonumber
y_i={\mathbf A}_o{\mathbf x} + {\mathbf A}_s{\mathbf s}_i + {\mathbf b}_x
\end{equation}
\begin{equation} \nonumber
{\mathbf s}_{i+1}={\mathbf C}_x{\mathbf x} + {\mathbf C}_s{\mathbf s}_i + {\mathbf b}_s
\end{equation}
The additon of stateful nodes allows us to describe a larger class of programs 
using our linear analysis framework.
Using linear state, our structure combination rules can be extended to include {\tt feedbackloops}.
Examples of programs that exhibit stateful linear nodes are control systems
and infinite impulse response (IIR) filters.

Another promising avenue of research is attempting to exploit work
done on matrix factorizations in order to automatically derive fast
implementations of large compuatations such as DSP transforms.  Also,
to increase the class of programs that would fit into our linear
framework, the entries of the ${\mathbf A}$ and ${\mathbf b}$ of
linear nodes could contain symbolic constants that are resolved at
runtime.

