\section{Linear Dataflow Analysis}
%\begin{figure}[t]
%\scriptsize
%\begin{verbatim}
%float->float filter LowPassFilter(float g, float cutoffFreq, int N) {
%  float[N] h;%
%
%  /* since the impulse response is symmetric, 
%   * don't worry about reversing h[n]. */
%  init {
%    int OFFSET = N/2;
%    for (int i=0; i<N; i++) {
%      int idx = i + 1;
%      // generate real part
%      if (idx == OFFSET) 
%	/* take care of div by 0 error 
%	(lim x->oo of sin(x)/x actually equals 1)*/
%	h[i] = g * cutoffFreq / pi; 
%      else 
%	h[i] = g * sin(cutoffFreq * (idx-OFFSET)) / (pi*(idx-OFFSET));
%    }
%  }
%
%  /* implement the FIR filtering operation 
%   * as the convolution sum. */
%  work peek N pop 1 push 1 {
%    float sum = 0;
%    for (int i=0; i<N; i++) { 
%      sum += h[i]*peek(i);
%    }
%    push(sum);
%    pop();
%  }
%}
%
%\end{verbatim}
%\vspace{-12pt}
%\caption{\protect\small StreamIt code for a low pass filter.
%\protect\label{fig:lowpasscode}}
%\vspace{-12pt}
%\end{figure}

%Figure~\ref{fig:lowpasscode} contains the code to implement a rectangularly windowed 
%low pass filter. Note that the {\tt init} function gets called once when the program
%starts up.


Since each {\tt filter}'s {\tt work} function can contain arbitrary C-like code,
the compiler must determine which {\tt filters} can be represented by linear nodes
automatically. 
 
The data analysis pass that is currently employed is very much like standard constant propagation. 
Instead of mappings from variables to compile time constants, we keep mappings to linear forms.
A linear forms is defined as a pair $({\mathbf v}, c)$ of a column vector $\mathbf{v}$ of size $e$ 
and a constant $c$. For each program variable, its linear form at a particular program 
point corresponds to the formula for computing a value from a linear 
combination of {\tt filter} inputs. The value of a linear form at runtime is 
${\mathbf xv} + c$.


The analysis must keep track of how many {\tt pop()}s the {\tt work} 
function has performed at any particular program point so that 
the position of the data returned by each {\tt pop()} or {\tt peek(i)} 
encountered is determinable. We define $popcount$ for each program point 
as the number of {\tt pops} encountered along all possible
execution paths. If different execution paths could cause $popcount$ to take
mutiple values at any point, $popcount$ becomes undefined.
We define ${\mathbf v} = zerov(k)$ a row vector of size $e$ such that 
$v[i]=0, i \neq k$, and $v[i]=1,i=k$.


A linear form is generated in one of he following three ways:
\begin{enumerate}
\item A constant $r$ generates the linear form $({\mathbf 0},r)$. 
\vspace{-6pt}

\item A {\tt peek(i)} statement generates the linear form 
$(zerov(u-i-1-popcount), 0)$.
\vspace{-6pt}

\item A {\tt pop()} expression generates the linear form 
$(zerov(u-1-popcount),0)$

\vspace{-6pt}
\end{enumerate}


Linear forms propagate through the dataflow graph much like constants are propagated
during a standard constant propagation pass. Two linear forms $l_{1}$ and $l_{2}$ can
be added together by adding their vectors element wise and adding their constants, eg 
$l_1+l_2=(v_1+v_2, c_1+c_2)$. Linear forms can only be multiplied by constants $r$, 
the result of which is simply a scaling of all the elements of $v$ and of $c$ by a factor
$r$. Eg $l*r = (rv,rc)$. If two linear forms are multiplied together 
then the result is not a linear combination of the {\tt Filter}'s input, rather it is
some polynomial function in the input.

{\tt if} statements are handled just like for constant propagation. The confluence operator
is set intersection, which only propagates variable to linear form mappings that are
maintained along both branches of control flow. We also have to impose the special restriction that the
same number of {\tt pops()} occurred along both branches or we don't know what the current offset
for generating linear forms from {\tt peek(i)} and {\tt pop()} expressions is. 
We currently only handle loops that can be unrolled in the 
compiler (eg those loops whose bounds are determinable at compile time). 
A loop can't be unrolled at compile time only if its termination condition is data 
dependent, and data dependent loops probably don't compute linear 
functions of the data anyways.


The final piece of generating a linear representation from a linear form is to 
When the {\tt expr} in a {\tt push(expr)} expression is a linear form $l=(v,c)$, 
we copy $v$ to the appropriate column in the {\tt Filter}'s linear representation matrix $A$ 
and we copy $c$ to the appropriate column in the linear representation's constant vector $a$.
The first {\tt push()} expression places the linear form in the last column of $A$. The second
{\tt push()} the second to last column of $A$, etc. The last column of $A$ represents 
the calculations necessary for the first output item produced by the filter. The second to last
column represents the calculations for the second output item of the filter, etc.
The same positions are chosen for the linear forms' constants in the constant vector $a$.

If all the {\tt push} expressions in a filter have linear forms as arguments, 
then we have determined that the filter is linear and remember the mapping from 
filter to linear representation.
