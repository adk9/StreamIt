\section{Linear Dataflow Analysis}

\newcommand{\maptype}{var$\rightarrow$linform~}
\newcommand{\la}{$\leftarrow$}
\newcommand{\IND}{\begin{ALC@g}}
\newcommand{\UND}{\end{ALC@g}}

\begin{algorithm}
{\bf Data Types}
\begin{algorithmic}
\STATE $x \in \mbox{variable}$
\STATE $(v, c) \in \mbox{linform}$
\STATE $map \in $ \maptype
\STATE $y \in \mbox{val}$
\STATE $c \in \mbox{inst, which can be any of the following cases:}$
\IND
\STATE ({\tt loop} $N$ $\mt{code}$)
\STATE ({\tt branch} $\mt{code}_1$ $\mt{code}_2$)
\STATE $v_1 := v_2~\mt{op}~v_3$
\STATE $v_1 := \mt{const}$
\STATE $v_1 := \mbox{\tt peek}(i)$
\STATE $v_1 := \mbox{\tt pop}()$
\STATE {\tt push}$(v_1)$
\UND
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
{\bf globals} Push, Pop, Peek \\ ~ \\
%
proc {\bf intersect}(val $y_1$, val $y_2$) returns val
\begin{algorithmic}
\IF {$y_1 = y_2$}
\STATE return $y_1$
\ELSE
\STATE return $\bot$
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
proc {\bf mergeMap}(\maptype $m_1$, \maptype $m_2$) returns \maptype
\begin{algorithmic}
\STATE \maptype $\mt{result}$
\FORALL {$x \in m_1.\mt{keys}$}
\STATE $\mt{result}$.put({\bf intersect}($m_1$.get($x$), $m_2$.get($x$)))
\ENDFOR
\STATE return $\mt{result}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
proc {\bf buildCoeff}(int pos) returns int[Peek]
\begin{algorithmic}
\STATE int[Peek] $\mt{result}$
\FOR {$i \leftarrow 0$ to Peek$-1$}
\IF {i=pos}
\STATE $\mt{result}$[i] \la 1
\ELSE
\STATE $\mt{result}$[i] \la 0
\ENDIF
\ENDFOR
\STATE return $\mt{result}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
proc {\bf extract}(inst[] $code$, \maptype $map$, int $\mt{popcount}$, int $\mt{pushcount}$, 
float[Push][Peek] $A$, float[Push] $b$) 
returns ($\mt{popcount'}$, $\mt{pushcount'}$, $\mt{map'}$, $A'$, $b'$)
\begin{algorithmic}
\FOR {$i \leftarrow 1$ to $\mt{code}$.length}
\STATE {\bf case} $\mt{code}$[i] of
\IND
\STATE ({\tt loop} N $code'$)
\IND
\STATE \bf{for} $i \leftarrow 1$ to $N$ {\bf do}
\IND
\STATE $(\mt{popcount}, \mt{pushcount}, \mt{map}, A, b)~\leftarrow~$ \bf{extract}$(\mt{code}, \mt{map}, \mt{popcount}, \mt{pushcount}, A, b)$
\UND
\UND
\STATE
\STATE $x_1 := x_2 + x_3$ or $x_1 := x_2 - x_3$
\IND
\STATE $(v_2, c_2) \leftarrow \mt{map}.\mt{get}(x_2)$
\STATE $(v_3, c_3) \leftarrow \mt{map}.\mt{get}(x_3)$
\STATE $\mt{map}.\mt{put}(x_1, (v_2+v_3, c_2+c_3))$
\UND
\STATE
\STATE $x_1 := x_2 / x_3$
\STATE
\STATE $x_1 := x_2 * x_3$
\IND
\STATE $(v_2, c_2) \leftarrow \mt{map}.\mt{get}(x_2)$
\STATE $(v_3, c_3) \leftarrow \mt{map}.\mt{get}(x_3)$
\IF {$v_2 = \vec 0_{Peek}$}
\STATE $(v', c') \leftarrow (c_2*v_3, c_2*c_3)$
\ELSIF {$v3=\vec 0_{Peek}$}
\STATE $(v', c') \leftarrow (c_3*v_2, c_3*c_2)$
\ELSE
\STATE $(v', c') \leftarrow \bot$
\ENDIF
\STATE $\mt{map}.\mt{put}(x_1, (v', c'))$
\UND
\STATE
\STATE $x_1 := x_2 \mt{bitop} x_3$, for $\mt{bitop} \in \{\&, |, \wedge\}$
\IND
\STATE $(v_2, c_2) \leftarrow \mt{map}.\mt{get}(x_2)$
\STATE $(v_3, c_3) \leftarrow \mt{map}.\mt{get}(x_3)$
\STATE $\mt{map}.\mt{put}(x_1, (\mbox{\bf intersect}(\vec 0_{Peek}, v_2, v_3), c_2 \mt{bitop} c_3))$
\UND
\STATE
\STATE $x1 := \mt{const}$
\IND
\STATE $\mt{map}.\mt{put}(x_1, (\vec 0_{Peek}, \mt{const}))$
\UND
\STATE
\STATE $x_1 := \mbox{\tt peek}(i)$
\IND
\STATE $\mt{map}.\mt{put}(x_1, (\mbox{\bf buildCoeff}(i+\mt{popCount}), 0))$
\UND
\STATE
\STATE $x_1 := \mbox{\tt pop}()$
\IND
\STATE $\mt{map}.\mt{put}(x_1, (\mbox{\bf buildCoeff}(\mt{popcount}), 0))$
\STATE $\mt{popcount}++$
\UND
\STATE
\STATE $\mbox{\tt push}(x_1)$
\IND
\STATE $(v, c) \leftarrow \mt{map}.\mt{get}(x_1)$
\STATE $A[*, \mt{pushcount}] \leftarrow v$
\STATE $b[\mt{pushcount}] \leftarrow c$
\STATE $\mt{pushcount}--$
\UND
\STATE
\STATE ({\tt branch} $code_1 code_2)$
\IND
\STATE $(\mt{popcount}_1, \mt{pushcount}_1, \mt{map}_1, A_1, b_1) \leftarrow {\mbox{\bf extract}}(\mt{code}_1, \mt{map}, \mt{popcount}, \mt{pushcount}, A, b)$
\STATE $(\mt{popcount}_2, \mt{pushcount}_2, \mt{map}_2, A_2, b_2) \leftarrow {\mbox{\bf extract}}(\mt{code}_2, \mt{map}, \mt{popcount}, \mt{pushcount}, A, b)$
\STATE
\STATE $\mt{popcount} \leftarrow {\mbox{\bf intersect}}(\mt{popcount}_1, \mt{popcount}_2)$
\STATE $\mt{pushcount} \leftarrow {\mbox{\bf intersect}}(\mt{pushcount}_1, \mt{pushcount}_2)$
\STATE $A \leftarrow \mbox{\bf intersect}( A_1, A_2 )$
\STATE $b \leftarrow \mbox{\bf intersect}( b_1, b_2 )$
\STATE $\mt{map} \leftarrow \mt{mergeMap}(\mt{map}_1, \mt{map}_2)$
\UND
\UND %end case
\ENDFOR
\STATE return ($\mt{popcount}$, $\mt{pushcount}$, $\mt{map}$, $A$, $b$)
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
proc {\bf toplevel}(filter $F$) returns linear node
\begin{enumerate}
\item Set Peek, Pop, Push equal to I/O rates of filter $F$.
\item Let $A_{0} \leftarrow~$ new float[Peek][Push] with each entry = $\bot$
\item Let $b_{0} \leftarrow~$ new float[Push] with each entry = $\bot$
\item (popcount, pushcount, map, $A$, $b$) \la \\
{\bf extract}($F_{work}$, empty-map, 0, Push, $A_{0}$, $b_{0}$)
\item
\begin{algorithmic}
\IF {$A$ and $b$ contain no $\bot$ entries}
\STATE return linear node $\lambda = \{A, b, \mbox{Peek}, \mbox{Pop}, \mbox{Push}\}$
\ELSE
\STATE {\it fail}
\ENDIF
\end{algorithmic}
\end{enumerate}
\end{algorithm}


