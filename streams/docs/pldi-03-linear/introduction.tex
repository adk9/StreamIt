\section{Introduction}
As more and more parts of modern life use digital computation, everything from cell phones, GPS systems
and satellite radios, require ever more complicated processing of digital signals. 
Each successive generation of applications requires ever more sophisticated algorithms mapped 
on to ever more specialized digital signal processors (DSP). As 
embedded devices have severe performance requirements placed on them,
the mapping of algorithm to architecture is typically done by hand at great cost and great expense.

Upward of fifty percent of the code that runs the DSP(s) in a modern cell phone is coded in assembly
with the rest written in C. Hand optimized assembly code typically makes the best use of the 
available resources such as power, specialized coprocessors, and specialized instructions.
The problem with assembly code is that the same algorithm must be mapped time and time again 
whenever a new chip comes out. The life cycle of a typical DSP is much shorter than the life
cycle of a general purpose microprocessor -- each new generation is separated by months rather
than years.
 
Therefore frequenctly reimplementing algorithms by hand is a costly arduous process that 
increases cost and slows the pace of advances. Engineers must spend time working out details rather 
than focusing on solving harder problems. Compilers were invented fourty years ago 
exactly to let engineers focus on the problem at hand rather than spend time with 
machine specific details. Compilers for DSP architectures have a difficult job, and are not
very good at mapping a program written in a general purpose language like C into the specialized 
instructions provided by DSPs. Many of the instructions provided by a DSP are targeted 
for a very specific application (like FIR filtering), but most general purpose languages have
no way to describe higher level behavior other than functionally. If you don't express
your algorithm in the same way that the compiler expects to encounter it, the resulting
program will not take best advantage of the available DSP resources.

We are attempting to solve this problem by introducing a new domain specific language which
supports imperative {\tt C} like code to describe computation. By imposing structure and
explicitly identifying the input and the output of different program sub components
we can run analyses that determine if a program is performing a common DSP task.  
We can then use this information to take advantage of special purpose DSP hardware
or we can even apply standard signal processing algorithm optimizations to 
We can then leverage the existing work on DSP algorithm optimization to perform compiler transformation
at a fairly sophisticated level. Our system lets programmers describe the
computation to be performed at an appropriate level and the compiler takes care of 


\subsection{StreamIt}

\begin{figure}
\center
\epsfxsize=3.0in
\epsfbox{images/general-picture-filter.eps}
\caption{Filter F with $peek_{F}$, $pop_{F}$ and $push_{F}$}
\label{fig:overview-filter}
\end{figure}


The StreamIt\cite{thies02streamit,thies01streamit,william-stream,michal-common} project
aims to provide a language and compiler for streaming applications. Streaming applications 
are characterized by data streaming in and out of the application. Each data element (both
input and output) is in the system for only a small amount of time as opposed to scientific
applications where the data set is used extensively for the life of the computation.
 
StreamIt programs are composed of processing blocks called {\tt Filters} which
contain a typed input tape from which they can read values and an output tape to which
they can write typed values. Each filter defines a {\tt work} function that executes when there
is sufficient data on the input tape or there is a need for data on the output tape.
{\tt Filters} can contain fields (like a Java field, or a C++ member variable) that
persist between calls to {\tt work}. The {\tt work} function is written in C like imperative code, 
and it can access {\tt Filter} fields (eg state), call external routines, etc.
There are very few limits on what code a {\tt work} function can contain except for
producing and consuming the appropriate amount of data.  
During the execution of the {\tt work} function, input is consumed and output is produced.
{\tt Filters } can examine data items (called {\tt peek}ing) on the input tape without
consuming them (called {\tt pop}ing). A {\tt Filter} {\tt push}es items on to its output tape.

All {\tt Filters} in StreamIt declare the number of elements they
will {\tt peek} at, the number of elements they will {\tt pop} and the number
of elements that they will {\tt push}. A {\tt Filter} $F$ can examine up to $peek_{F}$ 
items from its input tape, consumes exactly $pop_{F}$ items and {\tt push}es 
$push_{F}$ items into the output tape. Currently StreamIt requires that each filter has 
$peek_F$, $pop_F$ and $push_F$ rates that are static and known at compile time. 
Figure~\ref{fig:overview-filter} shows a schematic of how the various filter rates are related.

\begin{figure}
\center
\epsfxsize=3.0in
\epsfbox{images/streamit-structures.eps}
\caption{StreamIt Structures: Pipeline, SplitJoin, and FeedbackLoop.}
\label{fig:structures}
\end{figure}

{\tt Filters} in StreamIt are composed hierarchically using predefined structures to form
a program. 

\begin{enumerate}
\item {\tt Pipelines} represent the serial computation of one filter after another.
\item {\tt SplitJoins} represent parallel computation. 
\item {\tt FeedbackLoops} allow cycles to be introduced into the stream graph. 
\end{enumerate}

{\tt Filters}, {\tt Pipelines}, {\tt SplitJoins} and {\tt FeedbackLoops} 
are {\tt Streams} and each {\tt Stream} can be used as a subcomponent in 
a structure. Figure~\ref{fig:structures} illustrates the three structures provided by StreamIt.
StreamIt programs can also be represented as a connected graph of filters 
which we will refer to as the stream graph. It is also important to note
{\tt Streams} have exactly one input and one output tape.

Most real world programs can be fit into StreamIt's structured stream model, 
though the fit sometimes requires extra manipulation. We believe
that benefits of structure to both the programmer and the compiler outweigh the
costs of imposing structure on the programmer.

\subsection{Matrices and DSP}
We take advantage of StreamIt's one input one output {\tt Streams} and 
our knowledge that a large class of StreamIt programs will be performing
digital signal processing (DSP) functions to perform some useful automatic 
optimizations.

The is an entire research area of Electrical Engineering devoted to DSP. The
theory and the implementation of systems to process digital signals is well developed (see
an introductory text such as\cite{oppenheim-discrete} or \cite{lyons-understanding}). 
There are a few very widely used building blocks of most DSP systems, and their output 
can be formulated as a simply a linear combination of their inputs. Examples are
finite impulse response (FIR) filters, compressors, expanders and signal transforms
(most notably the discrete Fourier transform (DFT) -- 
see \cite{oppenheim-discrete} for a detailed discussion).

Electrical engineers who concentrate on DSP applications spend a large percentage of their 
time designing an appropriate implementation for a particular design. Choosing
the appropriate implementation structure is a highly non trivial task, and sometimes determining the 
the right choice is more of an art than a science. There are many systems that allow design choices
to be explored, for example Matlab\cite{matlab} is a (dare we say ridiculously) widely used package 
in both academia and in industry. There are also research projects such as \cite{covell-ade} 
and those described in \cite{oppenheim-symbolic} aimed at allowing a DSP designer to explore
various implementation choices.(XXXXXXXXXXXXx -- Are there other things we should reference here?) 

Given that a product called Matlab (as in  MATrix LAB) is used extensively
in signal processing applications, it probably comes as no  that 
matrices often provide a convenient way of working with
digital data and describing digital filters. If we can determine that StreamIt {\tt Filter}'s
{\tt work} function is doing matrix computation, we can take advantage of the huge body
of knowledge in DSP and in linear algebra.
