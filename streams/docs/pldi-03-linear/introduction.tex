\section{Introduction}
As more and more parts of modern life use digital computation, from cell phones to GPS systems
and satellite radio systems, the importance of digitally processing signals is growing.
Each successive generation of applications requires ever more sophisticated algorithms mapped 
on to ever more specialized processors. Since embedded computers have severe performance
requirements placed on them, typically the mapping of algorithm to architecture is done by hand.
When writing optimized assempbly for the latest DSP processors, one has to map the same algorithm
and time again. This remapping is costly arduous process that slows the pace of advance
because it forces engineers to spend time working out details rather than focusing on new technology.

\subsection{StreamIt}
\begin{figure}
\center
\epsfxsize=2.5in
\epsfbox{images/streamit-structures.eps}
\caption{StreamIt Structures: Pipeline, Splitjoin, and FeedbackLoop.}
\label{fig:structures}
\end{figure}

The StreamIt\cite{thies02streamit,thies01streamit,william-stream,michal-common} project
aims to provide a common language and compiler for streaming computations. Streaming computations
are characterized by data streaming in and out of the system while each data element (both
input and output) is in the system for only a small amount of time. 
StreamIt programs are composed of processing blocks called {\tt Filters} which
contain an input tape from which they can read values and an output tape to which
they can write values. {\tt Filters} are composed heirarchally into structures to form
a Stream Graph representation of the program (*need to explain stream graph).
 
{\tt Pipelines} represent the serial computation of one filter after another.
{\tt SplitJoins} represent parallel computation. {\tt FeedbackLoops} allow cycles
to be introduced into the stream graph. Figure~\ref{fig:structures} shows a {\tt Pipeline},
{\tt SplitJoin} and a {\tt FeedbackLoop}. StreamIt programs do not support arbitrary connections
between {\tt Filters} and as such not every stream graph is expressable. Most real world programs
can be fit into the structured stream model, even if it takes some extra manipulation. We believe
that benefits of structure outweigh and costs associated with it.

\subsection{Matrices and Digital Signal Processing}
We take advantage of StreamIt's one input one output computation blocks and 
our observations that a large class of likely StreamIt programs are performing
digital signal processing functions (eg filtering of the data) to do domain specific
optimizations on programs.

The is an entire area of electrical engineering devoted to digital signal processing. The
theory and the implementation of systems to process digital signals is well developed (see
an introductory text such as\cite{oppenheim-discrete} or \cite{lyons-understanding} for 
a flavor of the work that is done in this field. Many of the operations used for digital 
processing produce output that is a linear combinations of input values such as FIR filters and
the discrete time Fourier transform (see \cite{oppenheim-discrete} for detailed discussion
analysis).

Electrical engineers who do DSP spend a large portion of their time in implementation. Choosing
the appropriate structure to implement a digital system is a highly non trivial task, and sometimes
the right choice is more of an art than a science. There are many systems that allow design choices
to be explored, for example Matlab\cite{matlab} is a (dare we say rediculously) widely used package 
in both academia and in industry. There are also research projects such as \cite{covell-ade} 
and those described in \cite{oppenheim-symbolic}. 

As you might imagine given that a product called Matlab (like Matrix Lab) is used extensively
in signal processing applications, matrices often provide a convenient way of working with
digital data and digitial filters. Casting the work of StreamIt {\tt Filters} in terms 
of matrix operations is a good thing because it allows us to use the existing large body
of theory and knowledge about this area. 

Several interesting projects are underway to determine how to generate efficient programs
for computing DSP transforms that are expressed as matrices. For instance, the SPIRAL
project\cite{spiral} aims to determine the fastest implementation for various transforms
using several techniques ranging from group theory to stochastic search algorithms. See
 \cite{xiong-thesis,xiong01spl,johnson01searching,egner01automatic}.
Similiarly, the ATLAS project \cite{whaley01automated} aims to automatically produce fast
performance tuned libraries for linear algebra manipulations.
