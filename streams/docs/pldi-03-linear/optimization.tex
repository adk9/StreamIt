% this thing used to be about optimizations, now it is all about ``Translation to Frequency Domain''

\section{Translation to Frequency Domain}

Our linear analysis framework provides a compile time formulation of
the computation that a linear {\tt stream} is performing and we can
use this information to exploit well known domain specific optimizing
transformations.  Using our linear information, our compiler identifies
convolution regions that require substantially fewer computation if they 
are translated in to the frequency domain.

Calculating a convolution sum is a common and fundamental operation in
discrete time signal processing.
If the convolution region is sufficiently large, transforming the data to the
frequency domain, performing a simple vector multiply and converting
back to the time domain requires fewer operations than the original 
convolution computation.

The transformation from convolution sum into frequency multiplication
is done explicitly by the programmer because no compiler analysis today
has the information to determine when a convolution sum is being
computed.  As the complexity of DSP programs grow, determining the
disparate regions across which these optimizations can be applied is
an ever more daunting task. For example, individual filters may not
have sufficiently large convolutions to merit this transformation, but
after a liner combination of multiple filters the transformation will
be beneficial.  Furthermore, differing architectural features makes
the task of portable program transformations even harder.

\subsection{Transformation Overview}
The convolution sum $y[n]=x[n]*h[n]$ is defined 
as $y[n]=\sum_{k=-\infty}^{\infty}x[k]h[n-k]$.
In StreamIt, if a {\tt stream} is calculating a convolution sum we know that 
the input ($x[n]$) and output ($y[n]$) correspond exactly to the input and output tapes. 
Furthermore, a {\tt stream} will be computing a convolution sum when $o_F=1$ in which
case we can identify the values $h[n]$ as exactly the columns of $A$.

Calculating the convolution in the frequency domain is more efficient because of the 
existence of the fast Fourier transform (FFT) algorithm to calculate the discrete 
Fourier transform (DFT). Calculating a convolution takes $O(N^2)$ time, and performing 
the equivalent frequency computation domain using an FFT takes only two $O(N lg(N))$ 
time-frequency conversions coupled with an $O(N)$ frequency domain vector multiply.

%This seeming roundabout calculation
%is feasible because a class of fast algorithms known as the FFT are known that convert
%to frequency and back again. For a thorough treatment of the theory of discrete time 
%signal processing, including using the DFT to implement convolution, see \cite{oppenheim-discrete}.

To compute the convolution of two discrete time signals, $x[n]*h[n]$ 
one can calculate the DFT of both sequences to produce 
$X[k]$ and $H[k]$. Multiplying $X[k]$ and $H[k]$ element wise
produces a new sequence $Y[k]$, and taking the inverse DFT (IDFT) of $Y[k]$ 
produces $y[n]$ which is exactly the same as $x[n]*h[n]$.

When we identify a {\tt stream} that computes a convolution sum, the
compiler computes $H[k]$ at compile time and stores it during runtime. 
The {\tt stream}'s {\tt work} function is changed so that first $X[k]$ is 
$x[n]$ is calculated using an FFT algorithm. Then the {\tt work} function 
multiplies $X[k]$ with $H[k]$, to produce $Y[k]$. Finally $y[n]$ is obtained by
transforming $Y[k]$ back to the time domain using an inverse FFT.

\subsection{Automatic Transformation}
%this is where the fun starts.  

To implement this transformation, the compiler needs to compute $H[k]$ at
compile time. The compiler is transforming an FIR filter which has $h[n]$ of length $e$
and push rate $u=1$.
In order to overcome the constant factors hidden in the asymptotic savings
the transformed $F$ needs to produce more than the original $1$ output on each
execution of {\tt work}. The number of outputs, $N$, to produce on each 
execution of {\tt work} is set to be approximately $2e$, a number determined
by empirical observations. $N$ is then rounded up so that $N+2(e-1)$ is a power of two 
because our FFT algorithm only works on powers of two sized inputs. 

The frequency transformation generates a new {\tt stream} that
uses $N+e-1$ items each execution where the original {\tt stream} used only $e$.
Using $N+e-1$ input items results in a complete convolution results in 
$N+2e-2$ values, of which both the first and last $e_F-1$ values 
are incorrect. Without state, the transformed filter can at most produce 
the next $N$ items because any additonal output requires more than $N+e-1$ inputs.

The compiler automaticalls computes the complex values of $H[k]=FFT(N+2e-2,h[n])$,
the $N+2e-2$ point DFT of $h[n]$ at compile time and saves them as filter state. 
A new compiler generated {\tt work} function calculates the complex valued $X[k]=DFT(N+2e-2,x[n])$, 
the $N+2e-2$ DFT of the input and then calculates $Y[k]$ as the element-wise vector 
product of $X[k]$ and $H[k]$. Finally then performs the inverse FFT $y[n]=IFFT(N+2e-2,y[n])$.

In the initial implementation, the {\tt work} function simply used the middle $N$ 
values of $y[n]$ and discarded the remaining $2e-2$. Then $N$ values were popped 
from the input and the process repeated to produce the next $N$ outputs.

Our new implementation uses the previously discarded values of $y[n]$ because they are not
meaningless. The first $e-1$ are part of the computation from the previous invocation of the 
{\tt work} function and the last $e-1$ are part of the computation that will be done
by the next invocation of the {\tt work} function. 
The reuse of partial results from previous frequency calculations is  known in the DSP community known as 
the ``overlap and add'' method ~\cite{oppenheim-discrete} and is widely used.
On each {\tt work} function exection, the filter outputs the first $e-1$ items 
of $y[n]$ plus the partial results from the previous invocation followed 
by the $N$ middle elements of $y[n]$. Finally, it stores the last $e-1$ elements 
of $y[n]$ in a field to be used on the next invocation of {\tt work}.

