\section{Container Combination(propagation)}
Merely determining that a single filter computes a linear combination of its input is not
all that interesting or useful. However, we can take advantage of StreamIt's heirarchal 
structures to find the linear representation for {\tt Stream} structures ({\tt Pipelines},
{\tt SplitJoins} and {\tt FeedbackLoops}. First we require that all of the structure's 
children {\tt Streams} need to have linear representations for us determine an overall
linear representation. In the following discussion we restrict our attention to combining
{\tt Pipelines} and {\tt SplitJoins}. There is nothing inherent in the discussion that 
forecloses combining {\tt FeedbackLoops} into an overall linear representatin, but it
requires us to develop the notion of linear state (see Future Work).

\subsection{Rate Matching}

As in any streaming systems, the issue of rate is important. Data is being produced
and consumed by the various {\tt Filters} and when they are combined with structures
the overall {\tt Streams} have specific rates as well. The problem of scheduling the
the number and order of executions of {\tt work} functions is fully described in
\cite{karczma-thesis}. In order to combine filters, the rules we develop must take
rate matching into account. 

For example, if there are two
{\tt Filters} $F_1$ and $F_2$ in a {\tt Pipeline} and $F_1$ produces ({\tt push}es) 2 elements 
during its {\tt work} function but $F_2$ needs to examine ({\tt peek()}s) 4 elements 
to produce any output, it will be necessary to execute $F_1$'s {\tt work} function 
twice to produce enough output for $F_2$. If we want to combine the action of the 
{\tt Pipeline} into a single linear representation, we need to take into account
the different rates of the sub components.

\begin{figure}
\center
\epsfxsize=3.0in
\epsfbox{images/expanding-a-filter.eps}
\caption{Expanding {\tt Stream} $S$ by a factor $f_A$}
\label{fig:expanding-a-filter}
\end{figure}

Therefore, a fundamental operation necessary to combine any of StreamIt's structures, 
we need an expansion operation on our linear forms which represents the data produced
by multiple invocations of a {\tt Stream}. 
We denote expanding a filter $F$ by a factor $f_a$ as $expand(F, f_a)$.
When a {\tt Stream}'s linear form is expanded by $f_A$ 
the resulting linear form describes the formula for describing the filter's work
function exactly $f_a$ times. Figure~\ref{fig:expanding-a-filter} shows a 
high level picture of expanding filter $F$ to $F'$. Specifically, 
the new peek rate $peek_{F'}$ is  $peek_F + (f_A-1)pop_F$, the new pop rate
$pop_{F'}$ is  $f_{a}pop_F$ and the new push rate $push_{F'}$ is  $f_{a}push_F$.

\begin{figure}
\center
\epsfxsize=3.0in
\epsfbox{images/expanding-a-matrix.eps}
\caption{Expanding a linear form $(A,a)$ by a factor $f_{A}$}
\label{fig:expanding-a-matrix}
\end{figure}

Expansion is an operation that can be performed on any filter. Since we are interested
in linear filters, we need to formulate expansion on linear forms as well.
Figure~\ref{fig:expanding-a-matrix} shows the result of expanding the linear 
form $lf = (A,a)$ by a factor $f_A$ such that $lf' = expand(lf, f_A) = (A',a')$. 
The expansion of $A$ to $A'$ is done by first creating a zero matrix 
with $peek_{F}+(f_{A}-1)*pop_{F}$ rows and $f_{A}push_F$ columns which corresponds 
to the expanded filter. The original matrix $A$ is then copied $f_{A}$ times and placed along the
diagonal. Starting from the top left, each copy of $A$ is offset from the previous copy 
by $push_{F}$ columns and $pop_{F}$ rows. To expand the constant vector $a$ to $a'$ we simply
create a row vector with $f_{A}push_F$ rows and place $f_A$ adjacent copies in there.

\subsection{Pipelines}

\begin{figure}
\center
\epsfxsize=3.0in
\epsfbox{images/pipeline-combination-before.eps}
\epsfxsize=3.0in
\epsfbox{images/pipeline-combination-after.eps}
\caption{A {\tt Pipeline} of two linear {\tt Streams} with linear forms $(A,a)$ and $(B,b)$ (above) and the same {\tt Pipeline} after we have expanded the child filters (below).}
\label{fig:combining-pipeline}
\end{figure}

{\tt Pipelines} are serial combinations of {\tt Streams}, one followed directly after 
another. Below we describe the rules necessary to combine two serial filters. 
Combining a {\tt Pipeline} with an arbitrary number of {\tt Streams} can be accomplished 
by continually combining adjacent pairs until there are none left. 
We wish to derive the rules for combining two adjacent {\tt Streams}, 
$S_{1}$ followed by $S_{2}$ with linear forms $(A,a)$ and $(B,b$) respectively.
The combination rules follow directly from the equations relating the inputs and the outputs of the 
two {\tt Streams}. Defining our notation: $S_{1}$ takes $x[n]$ as input and produces 
$y_1[n]$ as output. $S_{2}$ inputs $y_1[n]$ and produces $y_2[n]$. 
Using our linear input to output equations from above,
$y_1 = xA + a$ and $y_2 = yB + b$. Combining the
two previous equations, it is clear that $y_2 = xAB + (Aa + b)$ 
which corresponds to a new linear form $(AB, Aa+b)$. 

The equations for the overall linear form is very elegant, but it is important to 
remember that the expressions are matrix operations, and that the dimensions of 
$A$ and $B$ might not be compatible (we don't worry about $a$ ane $b$ because if the 
we can multiply $AB$ then we can also multiply $ab$. The problem of incompatible
matrix sizes is the same problem of scheduling the first {\tt Stream} to produce
enough data for the second {\tt Stream} to read from. To make the dimensions match up, 
we have at our disposal the $expand$ operation described above. We will try and 
choose expansion factors $f_A$ and $f_B$ such that the expanded linear forms are
compatible. For most pairs of linear filters, there are multiple $(f_A,f_B)$ combinations
that make the multiplication compatible. In general, we try and choose the pair that
will result in the smallest overall matrix.


In general, to make the rates of two {\tt Streams} match, one needs to satisfy
$push_{S_1'} = push_{S_2'}$ which means that 
$f_Apush_{S_1}=peek_{S_2}+(f_B-1)pop_{S_2}$, where $push_{S_1}$,
$peek_{S_2}$ and $pop_{S_2}$ are all arbitrary integers and 
$f_A$ and $f_B$ are integers calculated by the compiler.
This constraint is not always satisfiable. For instance if
$push_{F_1}=2$, $peek_{F_2}=3$ and $pop_{F_2}=2$, you can not
choose $f_a$ and $f_2$ to satisfy the above equation. In this 
case we can use something called a {\tt TwoStageFilter} to block
the operation into a {\tt work} function that initializes the 
computation and another {\tt work} function that computes values
in the steady state.

It is also interesting to note that in some cases the combined linear form
actually represents a less inefficient way of computing the results of the
filters. (Possibly an example????XXXXXXXXXXXXXXX)

Figure~\ref{fig:combining-pipeline} shows graphically the process of expanding the
two {\tt Streams} in a {\tt Pipeline} so that they can be combined into a single linear filter.

\subsection{SplitJoins}
{\tt SplitJoins} are the StreamIt construct that allow a programmer to describe explicitly 
parallel computation. Data elements come into the top of the {\tt SplitJoin} and are directed
to the parallel {\tt Filters} by a {\tt Splitter} element. Currently, there are two types of
{\tt Splitters}: a duplicate splitter that merely sends a copy of each data element to each
of the parallel {\tt Filters}. A roundrobin splitter which has $N$ weights, $w_k$ for $k\in[1..N]$
where $N$ is the number of parallel {\tt Filters} in the {\tt SplitJoin}. The first $w_1$ elements
from the input data stream are sent to the leftmost {\tt Filter}. The next $w_2$ elements
are directed to the second leftmost {\tt Filter} and so on. When $sum_{k=0}^{N} w_k$ elements
have been seen, then the pattern starts again from the beginning.

The data from the parallel {\tt Filters} are combined back into a single stream by means of
a roundrobin joiner characterized by weights $v_k$ for $k\in[1..N]$ where $N$ is the number
of parallel streams in the {\tt SplitJoin}. First, $v_1$ items from the leftmost filter
are placed onto the output tape. Then $v_2$ elements from the second leftmost filter are placed
onto the output tape and so on. Again, the process repeats itself after $sum_{k=0}^{N} v_k$
elements have been produced at the output.


\begin{figure}
\center
\epsfxsize=3.0in
\epsfbox{images/splitjoin-combine.eps}
\caption{Combining a {\tt SplitJoin} that is composed of linear streams.}
\label{fig:splitjoin-combine}
\end{figure}

In our linear framework, we can produce a linear representation from any valid {\tt SplitJoin}
given that each of the child streams is linear. If that is the case, then we can describe the
action of the entire {\tt SplitJoin} as a linear operation represented by a new linear form
as shown in Figure~\ref{fig:splitjoin-combine}.

One can think of the joiner of a {\tt SplitJoin} as simply reordering the output data from
the parallel stream blocks. Remembering that each column of a linear form represents the 
formula for calculating a single output of the filter, then it is easy to see the overall form
of a {\tt SplitJoin} is going to consist of a particular order of the columns in the parallel
program streams.

\subsubsection{Duplicate Splitter}

\begin{figure}
\center
\epsfxsize=3.0in
\epsfbox{images/splitjoin-duplicate-ratematch.eps}
\caption{Expanding substreams to match their rates in a {\tt SplitJoin}.}
\label{fig:splitjoin-duplicate-ratematch}
\end{figure}

Combining a {\tt SplitJoin} where the splitter is duplicate is relatively straightforward
since each of the rows in the sub streams refer to the same input items given that the
linear representations of the sub streams have the same number of rows. The same rows in
different linear representations correspond to the same data items because each the 
same data item is copied to each sub stream.

To produce an overall representation by simply ordering the columns of the sub streams'
linear representations, we need to ensure that we could run the joiner
an integer number of times and consume exactly the correct number of items from one
expanded firing from each of the sub streams. To match the output rates we calculate
$x=lcm(\forall k, lcm(push(F_k),w_k))$. One can interpret x as the total number of elements
produced by all of the sub filters. Then we expand each filter $F_i$ by a factor
$f_i=\frac{x}{push(F_i)}$ which means that expanded it will produce $f_i*push(F_i)$ items, and
it will take $f_{w_i}=\frac{x}{w_i}$ firings of the joiner, with each of the firings consuming
$w_i$ elements. It is important to note that in order for the {\tt SplitJoin} to be valid
(eg have a schedule that does not result in an infinite buffer, see \cite{karczma-thesis} for
all of the the gory details) all of the $f_{w_i}$'s must be the same integer.
Figure~\ref{fig:splitjoin-duplicate-ratematch} graphically depicts the process of expanding
the sum linear forms so that the rates are matched. 

\begin{figure}
\center
\epsfxsize=3.0in
\epsfbox{images/splitjoin-duplicate-matrix.eps}
\caption{Matrix resulting from combining a {\tt SplitJoin} with rate matched substreams.}
\label{fig:splitjoin-duplicate-matrix}
\end{figure}

After the rates are matched as described above, we are garenteed to have the same number of rows
in each of the sub streams expanded representations. In order to construct the overall matrix, 
all that remains is to order the columns of the expanded representations appropriately. 
Since we know that the the first $w_1$ output elements will be the first $w_1$ elements 
produced from filter $F_1$ we put the $w_1$ rightmost columns of $A_1$ as the rightmost
columns of the overall representation matrix. We then place the $w_2$ rightmost columns of $A_2$ 
into the next columns of the overall representation matrix, and so forth until
we have determined all of the elements that would have been produced from one firing of 
the joiner ($\sum_{i=0}^{N} w_{i}$). If $f_{w_i}$ is greater than one 
(eg the joiner has to be executed more than once) then we go back and take rightmost
$w_1$ remaining columns from $A_1$, then the rightmost remaining columns from $A_2$, and
so forth. This process repreats until all of the columns from the expanded representations have
been fitted into the overall linear representation. Figure~\ref{fig:splitjoin-duplicate-matrix} 
shows graphically the process of creating the overall matrix.


\subsubsection{Roundrobin Splitter}

\begin{figure}
\center
\epsfxsize=3.0in
\epsfbox{images/splitjoin-roundrobin-to-duplicate.eps}
\caption{Converting a {\tt SplitJoin} with a roundrobin splitter to a {\tt SplitJoin} with a duplicate splitter.}
\label{fig:splitjoin-roundrobin-to-duplicate}
\end{figure}

In some applications, the incoming data to the {\tt SplitJoin} is directed to various sub streams 
by a roundrobin splitter with weights $v_i$. In this case, first we expand the sub streams of the
{\tt SplitJoin} to match the rates as described above and shown in 
Figure~\ref{fig:splitjoin-duplicate-ratematch}. However, after we have expanded, the number of
columns is correct, but the rows of each filter's expanded representation do not represent the
same input elements (because each filter doesn't see data bound to other filters). Therefore,
the matrices aren't necessairly going to have the same number of rows, and so merely
copying columns in the order described above isn't going to work because the columns will be 
of different sizes. To handle the case with a roundrbin splitter, we transform the {\tt SplitJoin} 
into a {\tt SplitJoint} with a duplicate splitter as illustrated in 
Figure~\ref{fig:splitjoin-roundrobin-to-duplicate}. To affect this transformation, we need the rows
of each sub filter's matrix to represent the same data items. By sending all of the data to each filter,
we need to tell each linear representation that its output doesn't depend in any way on the data that 
was originally bound for another filter. We insert rows of $0$s into the expanded representions
for each row that was originally bound for another subfilter. Figure~\ref{fig:splitjoin-roundrobin-matrix}
illustrates how the new matrix is constructed.

\begin{figure}
\center
\epsfxsize=3.0in
\epsfbox{images/splitjoin-roundrobin-matrix.eps}
\caption{Corresponding matrix for splitter conversion from roundrobin to duplicate.}
\label{fig:splitjoin-roundrobin-matrix}
\end{figure}
