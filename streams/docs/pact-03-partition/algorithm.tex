\section{Partitioning}

structures
----------
container s:
  s.size()  : returns number of children
  s.get(i)  : returns the i'th child

in a splitjoin s, s.get(i, j) is short for s.get(i).get(j)

globals
-------
// A_s[i][j][k] holds minimum cost of assigning children i..j of
// stream s to k tiles
forall s in graph:  int[][][] A_s;

// setup for n partitions
procedure setup(int n) 
----------------------
(pad all parallel streams of a splitjoin with a pipeline, and pad
 these pipelines with identities so that each parallel stream is the
 same length)
(consider pipelines as 1-element splitjoin)
(consider feedbackloops as 2-element pipeline in a splitjoin)

forall s in graph
  A_s = new int[s.length()][s.length()][s.width()][s.width()][n]
  forall (x1,x2,y1,y2,n) \in A_s
    A[i][j][k] = -1

// returns whether or not stream <s> needs a joiner if it is spread
// across multiple tiles
boolean needsJoiner (stream s)
------------------------------
par = s.parent()
if (par==null)
  // if have no parent, then need a joiner
  return true
else if (par.width()==1 && s!=par.get(0, par.length()-1))
  // if in the middle of a pipeline, then need a joiner
  return true
else 
  // otherwise, need a joiner only if <par> needs joiner
  return needsJoiner (par)
endif

// return minimal cost for allocating <n> partitions to children
int getCost(stream s, int n)
----------------------------

// see if we will need a joiner
if (n>1 && needsJoiner(s)) 
  n--
endif

if (s is Node)
 return getNodeCost(s, n)
if (s is Pipeline || s is FeedbackLoop)
 return get1DCost(s, 0, s.size(), n)
if (s is SplitJoin)
 return get2DCost(s, 0, s.size()-1, 0, s.get(0).size()-1, n)

// return minimal cost for allocating <n> partitions to children
// <y1>...<y2> of stream <s>
procedure get1DCost(stream s, int y1, int y2, int n)
----------------------------------------------------
// if value is memoized, return it
if (A_s[y1][y2][n] != -1)
  return A_s[y1][y2][n]
endif

// if down to one child, descend into it
if (y1==y2)
  int cost = getCost(s.get(y1), 0, s.getCost(y1).size()-1, n)
  A_s [y1][y2][n] = cost
  return cost;
endif

// if n is 1, just sum the work of components
if (n==1)
  int sum = get(y1, y1, n)
  sum += y1<y2 ? get(y1+1, y2, n) : 0
  A[y1][y2][n] = sum;
  return sum;
endif

// otherwise, find lowest-cost place at which to make a partition
// at this level 
int min = infinity
for i = y1 to y2 - 1
  for j = 0 to n-1
    int cost = max(getCost(y1, i, j), getCost(i+1, y2, n-j))
    if (cost < min)
      min = cost
    endif
  endfor
endfor

A[y1][y2][n] = min;
return min


procedure get2DCost(stream s, int x1, int x2, int y1, int y2, int n)
----------------------------------------------------------------
// if value is memoized, return it
if (A_s[x1][x2][y1][y2][n] != -1)
  return A_s[x1][x2][y1][y2][n]
endif

// if down to one child, descend into it
if (x1==x2 && y1==y2)
  int cost = getCost(s.get(x1, y1), n)
  A_s [x1][x2][y1][y2][n] = cost
  return cost;
endif

// if n is 1, just sum the work of components
if (n==1)
  int sum = getRectCost(s, x1, x1, y1, y1, n);
  sum += x1<x2 ? getRectCost(s, x1+1, x2, y1, y1, n) : 0
  sum += y1<y2 ? getRectCost(s, x1, x1, y1+1, y2, n) : 0
  sum += x1<x2 && y1<y2 ? getRectCost(s, x1+1, x2, y1+1, y2, n) : 0
  return sum;
endif

// try making vertical cut (in case s is a splitjoin)
int min = infinity
for xPivot = x1 to x2 - 1
  for nPivot = 0 to n-1
    int cost = max(getRectCost(s, x1, xPivot, y1, y2, nPivot),
                   getRectCost(s, xPivot+1, x2, y1, y2, n-nPivot));
    if (cost < min)
      min = cost
    endif
  endfor
endfor

// try making horizontal cut (for splitjoin, pipeline, feedbackloop)
for yPivot = y1 to y2 - 1
  for nPivot = 0 to n-1
    int cost = max(getRectCost(s, x1, x2, y1, yPivot, nPivot),
                   getRectCost(s, x1, x2, yPivot+1, y2, n-nPivot));
    if (cost < min)
      min = cost
    endif
  endfor
endfor

A[x1][x2][y1][y2][n] = min;
return min

int getNodeCost(stream s, int n)
--------------------------------
if (isFissable(s))
  return work / n
else
  return work
endif

// do partitioning of stream s on n tiles
procedure toplevel(stream s, int n)
-----------------------------------
setup(n)
cost = getCost(s, n)
traceback(s, cost, n)

----------------------------------------------------------------------------------

for general cost functions, a few problems you'd like to solve:

1. partitioning to given number of tiles while not violating some property
2. partitioning to minimum number of tiles while not violating some property
3. partitioning to any number of tiles while maximizing some number

--- 




