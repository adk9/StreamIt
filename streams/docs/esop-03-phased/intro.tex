\section{Introduction}

Applications that are structured around some notion of a "stream"
are becoming increasingly important and widespread.  There is
evidence that streaming media applications are already consuming
most of the cycles on consumer machines \cite{Rix98}, and their
use is continuing to grow.  In the embedded domain, applications
for hand-held computers, cell phones, and DSP's are centered
around stream of voice or video data.  The stream abstraction is
also fundamental to high-performance applications such as
intelligent software routers, cell phone base stations and HDTV
editing consoles.

Despite the prevalence of these applications, there is
surprisingly little language and compiler for practical,
large-scale stream programming.  The notion of a stream as a
programming abstraction has been around for decades \cite{SICP},
and a number of special-purpose stream languages have been
designed (see \cite{survey97} for a review). Many of these
languages and representations are elegant and theoretically sound,
but they often lack features and are too inflexible to support
straightforward development of modern stream applications, or
their implementations are too inefficient to use in practice.
Consequently most programmers turn to general-purpose languages
such as C or C++ to implement stream programs.

There are two reasons that general-purpose languages are
inappropriate for stream programming.  Firstly, they are a
mismatch for the application domain.  That is they do not provide
a natural or intuitive representation of streams thereby having a
negative effect on readability, robustness, and programmer
productivity.  Furthermore, general-purpose languages do not
communicate well the inherent parallelism of stream computations.
 Secondly, general-purpose languages are a mismatch for the
emerging class of grid-based architectures
\cite{smartmemories,rawshort,trips}.

{\StreamIt} is a language and compiler specifically designed for
modern stream programming.  The {\StreamIt} langauge holds two
goals: first, to provide high-level stream abstractions that
improve programmer productivity and program robustness within the
streaming domain; second, to serve as a common machine language
for grid-based processors.  At the same time, {\StreamIt} compiler
aims to perform stream-specific optimizations to achieve the
performance of an expert programmer.

In order to achieve these goals, {\StreamIt} provides a number of
features, designed to allow the programmer to easily and naturally
express the required computation, while keeping the program easy
to analyze by a compiler: all {\StreamIt} streaming constructs are
single-input, single-output; all computation happens in {\filters};
data is passed around between {\filters} using three streaming
constructs: {\pipeline}, which allows stacking of {\filters} one after
another, {\splitjoin}, which allows splitting and joining of data
amongst multiple streams, and {\feedbackloop}, which constructs
cyclic streams.  In {\StreamIt}, every {\filter} must declare the rate
at which it processes data: how much data is consumed and produced
on every invocation of the {\filter}'s {\work} function.  This model
of data passing is called Synchronous Data Flow (SDF).

In addition to \SDF, {\StreamIt} allows the programmer to pass data
between {\filters} in an asynchronous manner, similar to a
combination of message passing and function calls. Timing of such
data delivery is expressed in terms of amount of information
wavefronts - the programmer can specify a delay between message
delivery and destination {\filter}'s processing of data currently
being produced or consumed by the source {\filter}.  Such timing
mechanism introduces latency and buffering constraints on
execution of {\StreamIt} programs.

Using the features present in {\StreamIt}, the programmer can
express complex algorithms and computation models.  One of the
difficulties faced by {\StreamIt} is scheduling of the execution of
the program.  Since {\StreamIt} uses SDF computation model with
latency constraints, it is possible to schedule the order of
execution of {\filters} at compile time.  Scheduling SDF programs
presents a difficult challenge to the compiler:  as the complexity
of the program grows, the amount of memory required to execute the
program increases.  This increase comes from two sources: the
schedule size is creases, as well as amount of data needed for
buffering increases.  These two sources are closely coupled. There
exist tradeoffs between the schedule size and the buffer size.

This problem is further complicated by message latency constraints
placed on the program by the programmer.  While {\StreamIt} programs
are meant to provide relatively lax latency requirements, it is
possible to write programs with latency constraints so tight that
very few valid schedules exist. Finding these schedules is a
challenging task.

This thesis develops several techniques for scheduling execution
of {\StreamIt} programs. This thesis will present techniques which
take advantage of structure of {\StreamIt} to create compact
schedules. These schedules will be purely hierarchical in nature.
The concept of a phasing schedule will be introduced to reduce the
requirement for buffering data between {\filters} without overly
increasing the size of the schedule. Finally, the problem of
scheduling programs with message latency constraints will be
solved using integer programming.

The contributions of this thesis are:
\begin{itemize} \item
hierarchical scheduling of streaming application, a concept
enabled by {\StreamIt} language, \item first formal handling of
SDF graphs with peeking, \item novel phasing scheduling technique,
\item a minimal latency schedule using hierarchical phases, \item
novel SDF program abstraction called the information buffering
model that simplifies information latency analysis, \item a
solution to scheduling of {\StreamIt} programs with latency
constraints.
\end{itemize}

The remainder of this thesis is organized as follows: chapter
\ref{chpt:streamit} describes relevant {\StreamIt} constructs in
detail; chapter \ref{chpt:sched-basic} explains basic concepts in
scheduling {\StreamIt} graphs; chapter \ref{chpt:hierarchical}
describes hierarchical phasing techniques; chapter
\ref{chpt:phased} describes phasing scheduling techniques,
including phased scheduling, a more advanced approach to
scheduling; chapter \ref{chpt:constrained} introduces techniques
for scheduling of {\StreamIt} programs with latency constraints;
chapter \ref{chpt:results} analyzes performance of various
algorithms described here.
