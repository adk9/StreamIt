\documentclass[11pt]{article}

\usepackage{cite}
\usepackage[margin=1in]{geometry}
\usepackage{palatino}
\usepackage{url}

% Abstract formatting:
\def\class#1{\texttt{#1}}


% Print acronyms in small caps.
\def\cfg{\textsc{cfg}}
\def\dsp{\textsc{dsp}}
\def\fortran{\textsc{fortran}}
\def\ir{\textsc{ir}}
\def\Ir{\textsc{Ir}}
\def\mips{\textsc{mips}}
\def\mit{\textsc{mit}}
\def\opi{\textsc{opi}}
\def\raw{\textsc{raw}}
\def\scale{\textsc{scale}}
\def\sir{\textsc{sir}}
\def\ssa{\textsc{ssa}}
\def\Ssa{\textsc{Ssa}}
\def\stair{\textsc{stair}}
\def\Stair{\textsc{Stair}}
\def\suif{\textsc{suif}}
\def\Suif{\textsc{Suif}}
\def\suifvm{\texttt{suifvm}}
\def\vliw{\textsc{vliw}}
\def\xml{\textsc{xml}}
\def\Xml{\textsc{Xml}}
\def\machsuif{Machine \suif}

% Predefine useful email addresses.
\urldef\dmazemail\url{dmaze@cag.lcs.mit.edu}

\title{Commentary on \stair}
\author{David Maze\\\dmazemail}

\begin{document}

\maketitle

\begin{itemize}
\item 2.3, 2. Seems to me like types would still be useful --- might
  want a "bit" in addition to int and float?  (I don't know, if we
  ever generate hardware from low-level IR, for example.) But required
  bitwidth for everything does seem like overkill.  [Bill]
  
\item Variables.  Do we want to distinguish SSA by number or name?
  Seems like if you want to get a new SSA variable, you might just
  want to get a fresh name instead of finding what the current free
  number is for that variable.  [Bill]

  \emph{SSA-by-number means that it's easier to collect together
    different parts of the same variable without copying values around
    when doing register allocation.  ---dzm}
  
\item The array addressing case.  Wouldn't it be much easier for a
  lower layer to convert a single instruction to multiple instructions
  instead of the other way around? Seems like the store should be the
  most general, high-level version in the common layer.  So I'd vote
  for store-with-offset instead of doing the add of the address in the
  VM.  [Bill]
  
\item Branching.  I'm a little confused about why the insert
  conditional branch, etc., is in the Backend interface.  Isn't there
  a vm-level concept of branches?  Are all branches machine-specific?
  Why aren't they just like other instructions?  (Or you're saying
  that at the vm level, all branches are just implied by the control
  flow graph?  Still there needs to be some instruction for
  designating which path to take, I guess.)  [Bill]
  
  \emph{My intent was that everything would stay in \cfg{} form until
    the latest possible moment.  So all of the control flow, including
    conditional and unconditional branches, is in the \cfg.  This
    isn't necessarily ideal; we might want to break the \cfg{} around
    calls, for example.  ---dzm}
  
\item 4.4 Symbols --- are "variables" the same as temporary operands
  in the low-level \ir?  when you say "symbols and registers, but
  nothing else, have types" --- what's the "else"?  I think the
  temporaries in the low-level IR should have types as well.  [Bill]
  
  \emph{When a temporary is generated, it gets a slot in the symbol
    table, so it becomes a normal variable.  The "else" includes
    immediates (implicit integer or float type) and memory references
    (where you probably care).  The immediates are the thing that are
    a big pain with typing in \machsuif.  ---dzm}
  
\item I don't think don't think edge should be inner class of block,
  if that's what you were really intending.  (Passes might want to
  know about edges.)  [Bill]
  
  \emph{That is what I was intending.  That can be changed.  There's
    some concern about the names I'm using being pretty generic ones,
    though; I might use ControlEdge over an unqualified Edge.  ---dzm}
  
\item I think a major open question is whether or not the "low-level
  IR" is structured.  At one point (around StreamIt Fun Day '02) we
  were talking that there should be an architecture-independent
  equivalent of the "flat graph" that Mike Gordon currently uses in
  the Raw backend.  Maybe \stair{} is independent of this decision
  (\stair{} code could appear either in \sir{} function bodies, or in
  some low-level graph function body) but when we're building the
  infrastructure, I think it'd be good to introduce the generic
  unstructured graph at the same time.  Maybe Gordo can help define
  this -- or could just distill it from his Raw code.  [Bill]

\item Shouldn't there be phi nodes?  [Bill, paraphrased]

  \emph{Oh yeah, that didn't make it into the original document.  Each
    block should have a list of variables and associated \ssa{}
    numbers live on entry and exit.  Then, for each variable, either
    the \ssa{} number is identical to all of the previous blocks, or
    it's different from all of the previous blocks and an implicit phi
    function exists.  ---dzm}
  
\item Is there any value in having the \cfg{} and the textual sequence
  of instruction just be redundant views of the same thing?  Michal
  was describing algorithms where you just loop through a linear
  stream of instructions and follow the branches for a simple way of
  doing things.  I think the same thing could be done through a \cfg,
  but I can't tell if it'd be more cumbersome.  [Bill]
  
\item Perhaps \class{BlockContainer} should be replaced by
  \class{Function}; are there other interesting case of containers?
  [Bill]

\end{itemize}
\end{document}

