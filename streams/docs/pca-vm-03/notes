going off chip from raw:
- three connections multiplexed:
  - memory dynamic network
  - general dynamic network
  - static network 1

completely bi-directional

14 ports on the chip in all

************************************************************
MY PLAN

- write the new Streaming Virtual Machine section
- write the new Metadata section
  - include description of Raw
  - will involve defining an actual API for accessing stuff.

- send to Peter with dummy placeholders for other chapters, ask if I
  should take care of integrating or if this should be left to UT

************************************************************
THINGS TO CHANGE

old issue summary: 4468
peter's update after talking to stanford: 4785
most recent summary:  5013

metadata
--------

* do we need notion of explicit DMA controllers?
* how do you represent a bus?

- need to write Raw in current metadata
- allow multiple I/D per processor

- add list of black-box function names, along with their SVM-style code code

streaming
---------

x new stream buffer:
  x follow peter's pseudocode
  x 9 kinds (figure out some kind of inheritance)
    x 3: input, output, both
    x 3: inorder, outorder, random
    x inorder inherits from out-of-order because of read/write

  x properties:
    x capacity
    x reset -- makes everything back to zero
    x length
      x how many "live items" in it
      x if random, then just returns capacity
      x this is updated after each return from start()
    x totalLength
      x how many items pushed onto it
      ? if random, then just returns capacity
    x has copy constructor for copying elements
    x guaranteed of data layout if totalLength < capacity
    x EOS tokens are below the level of the SVM. Control code should
      abstractly know the length of a stream or (if it is being
      produced/received) the number of elements available and if more are
      expected. There are multiple ways to implement this abstraction for
      different kinds of hardware.
    x note that only allows fixed-size records.  Variable sized
      records can be supported at language-level and compiled into
      fixed size scheme with some kind of data encoding

x kernels
  x take an argument for the resource where they should execute
  x take an argument for random-access stream buffer that the LLC
    can use to store temporaries that overflow local kernel mem.
  x should include work_info, prework_info
  x new restriction: work function must return
  x for copy kernel, include src_stride and dst_stride

x graphs
  x add dependence info to constructors.  must be literals.
    x to avoid memory-based location analysis in low-level compiler
  x add non-blocking start method
    x does this call pre_work?
    x can you call it on a given graph object even after you've terminated?
      for running some graphs twice, etc.  Maybe call reset in between.
  x add non-blocking terminate method
    x does this call post_work?
  x calls to start first calls wait on inputs first -- but calls
    to start are asynchronous
  x consistency is not guarnateed for parallel writes.  same with
    reuse of internal buffers -- nothing is guaranteed
  x use "finish" instead of "termination" throughout document
  x doesn't run on a given resource anymore; resource assignment
    is done at kernel level
  x new restriction: must be connection in architecture graph for every
    link in graph
  x Send/receive protocol needs to be adjusted for output full on
    receive side.

x stream control:
  x allow support for compiler-managed imem - e.g. call kernelLoad(kernel)
    to give hint that kernel should be loaded
  x still can't inspect kernels while they're running, but can poll using
    the start method
  x embedded in normal GP/threaded code with streaming restrictions
    only on streaming objects
  x the control code does file I/O and such outside of a kernel space
  x Add a 64 bit signed/unsigned integer type (also to within kernels)

x library support

   x for library support: add to metadata a list of kernels that the llc
     implements, supply their SVM representation -- also specify the
     annotation functions for everything, but leave out declaration of
     work; the HLC guaranteest hat it won't muck with them (fuse them
     or anything) and then LLC can implement how it wants

   x OPEN ISSUE:  this will require having separate graph for each
     library function.  will make it impossible to run graph in 
     pieces and poll the pieces, since calling start calls terminate?

just the document
-----------------

x be consistent between _ and capitalization for delimiting
multiple-word identifiers

x KernelInfo class should remove static argument to setPush/pop/peek.

x Say a given INSTANCE of a kernel can appear in only one graph.

******************************************************************************
NOT DOING

- come back to enumerating some kind of set of configurations, maybe
  by an array that has rows and columns for different kinds of
  config's

- is it worthwhile to represent static rates, etc. for sub-segments of
  a stream graph?  (some functions that are called inside a kernel?)

- Mike Vahey says "Pg 12, Not clear about 'only copy across one
  connection'"

************************************************************
RAW NOTES WITH PETER

in the afternoon
----------------

length still returns how many items have been written to stream
  - if it's random, then just returns size
  -> length return how many items have been (pushed)

StreamBuffers -> 
  - capacity
  - length
  - totalLength
  - reset - sets pointers to beginning, 

- you can copy them, read 
- guaranteed of data layout if totalLength<capacity

- some inheritance order between 9 classes

next day
--------

- dependence information between graphs has to be literals as well

his current email:
------------------

- have outOfOrder Istream, outOfOrder ostream.  inorder inherits from
out-of-order because of read/write methods

- read/write and push/pop with optional argument to write into an output stream 

- terminate is non-blocking

- if you call start, then it does the equivalent of calling wait() on
inputs first -- but call to start() is still asynchronous

- the dependence annotations between graphs is because you don't want
to do memory-based location analysis in the low-level compiler

- for library support: add to metadata a list of kernels that the llc
implements, supply their SVM representation -- also specify the
annotation functions for everything, but leave out declaration of
work; the HLC guaranteest hat it won't muck with them (fuse them or
anything) and then LLC can implement how it wants

- be sure to say that consistency is not guarnateed for parallel writes

* still an open issue:  number of dma controllers in the metadata, etc
  * need to describe in RAW

as per old mail
---------------

- allow multiple I/D per processor

- as per sharing memory space for internal buffers, should just be
dealt with by the fusion of the high-level compiler (#3)

- have "memory block" that is above stream, takes resource, pointer,
size.  pass this as argument to constructor but nothing else -- just
for storing locals if the lower-level stream needs to.

------
finishing conversatoin at 6 p.m.

- should use the word "finish" instead of "termination" throughout the
document so that we don't confuse the fault-tolerance case

- "components of kernel" should include work_info, prework_info.

----

- threaded processor can just map contents to physical locations of
streams

- need to assign a required resource that executes a given kernel.
Graph doesn't run on a single resource; a kernel runs on a resource.
e.g. DMA controller.

