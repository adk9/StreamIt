% uncomment this to use pubform
%\documentstyle[psfig, amsmath]{pubform}

\documentclass{sig-alternate}
\usepackage{gregs-defs}

\begin{document}

\title{A Common Machine Language for Grid-Based Machines}

% uncomment this to use pubform
%% \author{Bill Thies, Michal Karczmarek, Michael Gordon, David Maze, Jeremy Wong, \\ Henry Hoffmann, Matthew Brown, and Saman Amarasinghe \\
%% \parbox{6in}{\centering{Laboratory For Computer Science\\
%%     Massachusetts Institute of Technology\\
%%     Cambridge, MA  02139\\
%%     \tt{\{thies, karczma, mgordon, dmaze, jnwong, hank, morris, saman\}@lcs.mit.edu}}}}
%% \date{\today}

\numberofauthors{1}
\author{
\alignauthor \vspace{-18pt}
Bill Thies, 
Michal Karczmarek, 
Michael Gordon, 
David Maze, 
Jeremy Wong,
Henry Hoffmann, 
Matthew Brown, 
and Saman Amarasinghe\\
	\vspace{6pt}
	Laboratory for Computer Science \\
	Massachusetts Institute of Technology \\
	Cambridge, MA  02139 \\
%	\vspace{6pt}
%	{\tt \{thies, karczma, mgordon, dmaze, jnwong, hank, morris, saman\}@lcs.mit.edu} \\
%	\vspace{12pt}
%        \today
}

% for the arrow of a function def, etc.
\newcommand{\ma}[2]{max_{#1 \rightarrow #2}}
\newcommand{\mi}[2]{\textsc{sdep}_{#2 \small{\rightarrow} #1}}
\newcommand{\floor}[2]{\left\lfloor\frac{#1}{#2}\right\rfloor}
\newcommand{\ceil}[2]{\left\lceil\frac{#1}{#2}\right\rceil}
\newcommand{\ra}[0]{\rightarrow}
\newcommand{\la}[0]{\lambda}

\def\fn#1{\mathop{\mbox{\it #1}}}
\def\fun#1#2{\ensuremath{\mathop{\mbox{\it #1}}(#2)}} % function call

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

A {\it common machine language} is an essential abstraction that
allows programmers to express an algorithm in a way that can be
efficiently executed on a variety of architectures.  The key
properties of a common machine language (CML) are: 1) it abstracts
away the idiosyncratic differences between one architecture and
another so that a programmer doesn't have to worry about them, and 2)
it encapsulates the common properties of the target architectures such
that a compiler for any given target can still produce an efficient
executable.  

For von-Neumann architectures, the canonical CML is C: instructions
consist of basic arithmetic operations, executed sequentially, which
operate on either local variables or values drawn from a global block
of memory.  The C language has been implemented efficiently on a wide
range of architectures, and it saves the programmer from having to
adapt to each kind of register layout, cache configuration, and
instruction set.

However, recent years have seen the emergence of a class of grid-based
architectures \cite{smartmemories, trips, raw} for which the
von-Neumann model no longer holds, and for which C is no longer an
adequate CML.  The design of these processors is fundamentally
different in that they are conscious of wire delays--instead of just
arithmetic computations--as the barriers to performance.  Accordingly,
grid-based architectures support fine-grained, reconfigurable
communication between replicated processing units.  Rather than a
single instruction stream with a monolithic memory, these machines
contain multiple instruction streams with distributed memory banks.

Though C can still be used to write efficient programs on these
machines, doing so either requires architecture-specific directives or
a very smart compiler that can extract the parallelism and
communication from the C semantics.  Both of these options renders C
obsolete as a common machine language, since it fails to hide the
architectural details from the programmer and it imposes abstractions
which are a mismatch for the domain.

To bridge this gap, we propose a new common machine language for
grid-based processors: StreamIt.  The StreamIt language makes explicit
the large-scale parallelism and regular communication patterns that
these architectures were designed to exploit.  A program is
represented not as a monolithic memory and instruction stream, but
rather as a composition of autonomous filters, each of which contains
its own memory and can only communicate with its immediate neighbors
via high-bandwidth data channels.  In addition, StreamIt provides a
low-bandwidth messaging system that filters can use for non-local
communication.  We believe that StreamIt abstracts away the variations
in grid-based processors while encapsulating their common properties,
thereby enabling compilers to efficiently map a single source program
to a variety of modern processors.

\section{The StreamIt Language}

In this section we provide a very brief overview of the StreamIt
language; please see \cite{streamittech} for a more detailed
description.  The current version of StreamIt is legal Java syntax to
simplify our presentation and implementation, and it is designed to
support only streams with static input and output rates.  Designing a
cleaner syntax and considering dynamically varying rates will be the
subject of future work.

\subsection{Filters}

The basic unit of computation in StreamIt is the {\tt Filter}.  An
example of a Filter is the {\tt Adder}, a component of our software
radio (see Figure \ref{fig:radiocode}).  Each {\tt Filter} contains an
{\tt init} function that is called at initialization time; in this
case, the {\tt Adder} records {\tt N}, the number of items it should
add at once.  The {\tt work} function describes the most fine grained
execution step of the filter in the steady state.  Within the {\tt
work} function, the filter can communicate with neighboring blocks
using the {\tt input} and {\tt output} channels, which are typed FIFO
queues declared within the {\tt init} function.  These high-volume
channels support the intuitive operations of {\tt push(value)}, {\tt
pop()}, and {\tt peek(index)}, where {\tt peek} returns the value at
position $index$ without dequeuing the item.

\subsection{Connecting Filters}
\label{sec:connecting}

The basic construct for composing filters into a communicating network
is a {\tt Pipeline}, such as the Radio in Figure \ref{fig:radiocode}.
Like a {\tt Filter}, a {\tt Pipeline} has an {\tt init} function that
is called upon its instantiation.  However, there is no {\tt work}
function, and all input and output channels are implicit; instead, the
stream behaves as the sequential composition of filters that are
specified with successive calls to {\tt add} from within {\tt init}.

There are two other stream constructors besides {\tt Pipeline}: {\tt
SplitJoin} and {\tt FeedbackLoop}.  The former is used to specify
independent parallel streams that diverge from a common {\it splitter}
and merge into a common {\it joiner} (see the Equalizer in Figure
\ref{fig:radiocode}).  There are two kinds of splitters: 1) Duplicate,
which replicates each data item and sends a copy to each parallel
stream, and 2) RoundRobin($w_1, \dots, w_n$), which sends the first
$w_1$ items to the first stream, the next $w_2$ items to the second
stream, and so on.  RoundRobin is the only joiner type.  The splitter
and joiner type are specified with calls to {\tt setSplitter} and {\tt
setJoiner}, respectively; the parallel streams are specified by
successive calls to {\tt add}, with the $i$'th call setting the $i$'th
stream in the SplitJoin.  We do not discuss FeedbackLoops do to space
constraints.

%% Evident in all of these examples is another feature of the StreamIt
%% syntax: {\it inlining}.  The definition of any stream or filter can be
%% inlined at the point of its instantiation, thereby preventing the
%% definition of many small classes that are used only once, and,
%% moreover, providing a syntax that reveals the hierarchical structure
%% of the streams from the indentation level of the code.  In our Java
%% syntax, we make use of anonymous classes for inlining \cite{java}.

StreamIt differs from other languages in that it imposes a
well-defined structure on the streams; all stream graphs are built out
of a hierarchical composition of Pipelines, SplitJoins, and
FeedbackLoops.  This structure enables the stream to be mapped
efficiently onto a grid target, since all of the communication is
between neighboring filters.  Moreover, we are developing fission and
fusion algorithms that can, for example, collapse a large Pipeline
into a single filter for execution on a single processor, thereby
allowing us to adjust the granularity of the stream graph to match the
granularity of a given target.

%% The comparison of StreamIt's structure with arbitrary stream graphs
%% could be likened to the difference between structured control flow and
%% GOTO statements.  Though sometimes the structure restricts the
%% expressiveness of the programmer, the gains in robustness,
%% readability, and compiler analysis are immense.

\subsection{Messages}

StreamIt provides a dynamic messaging system for passing irregular,
low-volume control information between filters and streams.  Messages
are sent from within the body of a filter's {\tt work} function,
perhaps to change a parameter in another filter.  The central aspect
of the messaging system is a sophisticated timing mechanism that
allows filters to specify when a message will be received relative to
the flow of information between the sender and the receiver.  Due to
space constraints, we do not describe the syntax for message
statements, but we do consider the semantics of message timing in
Section \ref{sec:messagesemantics}.

\subsection{Implementation Status}

\section{Conclusions}

\begin{figure}
\psfig{figure=radio.ps,height=2in}
\vspace{-6pt}
\caption{Block diagram of a software radio.
\protect\label{fig:radiodiagram}}
%\vspace{-6pt}
%\end{figure}

%\begin{figure}
\scriptsize
\begin{verbatim}
class Adder extends Filter {
  int N;

  void init(int N) {
    input = new Channel(Float.TYPE, N);
    output = new Channel(Float.TYPE, 1);
    this.N = N;
  }
  
  void work() {
    float sum = 0;
    for (int i=0; i<N; i++) {
      sum += input.popFloat();
    }
    output.pushFloat(sum);
  }
}

public class Equalizer extends Pipeline {
  void init(int BANDS) {
    add(new SplitJoin() {
      void init() {
        int bottom = 2500;
        int top = 5000;
        setSplitter(DUPLICATE());
        for (int i=0; i<N; i++, bottom*=2, top*=2) {
          add(new BandPassFilter(bottom, top));
        }
        setJoiner(ROUND_ROBIN());
    }});
    add(new Adder(BANDS));
  }
}
  
class CheckFreqHop extends Filter {
   int DELAY;
   RFtoIFPortal portal;

   void init(RFtoIF rf2if, int N) {
      input = new Channel(Float.TYPE, N);
      output = new Channel(Float.TYPE, N);
      this.portal = new RFtoIFPortal(rf2if);
      DELAY = 256/N;
   }

   void work() {
      boolean hopped = /* calculate if hopped */
      float newFreq =  /* detect new frequency */
      if (hopped) {
         portal.setFreq(newFreq, DELAY);
      }
   }
}

class Radio extends Stream {
   int N = 64;
   int BANDS = 10;

   void init() {
      add(new ReadFromAtoD());
      RFtoIF rf2if = add(new RFtoIF(N));
      add(new FFT(N));
      add(new CheckFreqHop(rf2if));
      add(new Equalizer(10));
      add(new Speaker());
   }
}
\end{verbatim}
\vspace{-16pt}
\caption{StreamIt code for a software radio.
\protect\label{fig:radiocode}}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{small}
\bibliographystyle{abbrv}
\bibliography{references}
\end{small}
\end{document}
