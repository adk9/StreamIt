\section{Results}
\label{sec:results}

We have implemented a fully-functional prototype of the StreamIt
compiler for the Raw architecture; the compiler phases are described
in Section~\ref{sec:phases}.  We have implemented all of the phases of
the compiler as well as the optimizations, but the decision of which
optimizations to apply is currently guided by the programmer.

\begin{table}[t]
\begin{center}
\scriptsize
\begin{tabular}{|l|l|} \hline
{\bf Benchmark} & {\bf Description}\\
\hline \hline
FM Radio & A software-based FM Radio with equalizer.\\
\hline
GSM & A GSM decoder.\\
\hline
BeamFormer & A core component of modern radar, sonar, and communications signal processors. \cite{pca}\\
\hline
FFT & A 64-element FFT. \\
\hline
CRC & A 32-bit Cyclic Redundancy Check (CRC) Encoder/Decoder. \\
\hline
\end{tabular}
\vspace{-6pt}
\caption{\protect\small Application Descriptions.}
\label{tab:benchmarks}
\vspace{-12pt}
\end{center}
\end{table}

%We have evaluated our compiler with StreamIt versions applications: 
%\begin{itemize}
%
%\item A software-based FM Radio with
%equalizer, 
%
%\item A GSM Decoder, which takes GSM-encoded parameters as
%inputs, and uses these to synthesize audible speech, 
%
%\item A beamformer
%which encapsulates the core functionality of modern radar, sonar, and
%communications signal processors -- modeled after a system from the
%Polymorphic Computing Architecture (PCA) \cite{pca}

%\item A 64-element FFT filter implemented as a pipeline of a bit reversal 
%filter followed by multiple-stage butterfly filters.

%\item A Cyclic Redundancy Check (CRC) Encoder/Decoder, which is an error detection system utilizing a predefined 32 bit generator polynomial.  It can detect errors in bit strings of up to 64KB in size with 99.99999997% accuracy.

%\item Matrix Multiplication 

%\item A MP3

%\item A performance test from the SpectrumWare system that
%implements an Orthogonal Frequency Division Multiplexor (OFDM)
%\cite{spectrumware}.  Table \ref{tab:benchmarks} gives characteristics
%of the above applications including the number of filters implemented
%and the size of the stream graph as coded.

%%\end{itemize}


\begin{table}[t]
\begin{center}
\scriptsize
\begin{tabular}{|l|c|c|c|c|c|c|c|} \hline
& {\bf Lines} & \multicolumn{3}{|c|}{{\bf Unoptimized}} & \multicolumn{3}{|c|}{{\bf Optimized}}\\
\cline{3-8}
{\bf Benchmark} &
\begin{tabular}{c} 
{\bf of} \\ {\bf code}
\end{tabular} &    
\begin{tabular}{c} 
{\bf \# of} \\ {\bf filters}
\end{tabular} &    
\begin{tabular}{c} {\bf Throughput} \\
{\bf (per 10$^5$ cycles)}
\end{tabular} &    
{\bf MFLOPS} & 
\begin{tabular}{c} 
{\bf \# of} \\ {\bf filters}
\end{tabular} &    
\begin{tabular}{c} {\bf Throughput} \\
{\bf (per 10$^5$ cycles)}
\end{tabular}  &
{\bf MFLOPS}
\\
\hline \hline
BeamFormer (12x4) & 596 & 53 & 0.9 & 573 & 15 & 1.8 & 1124\\
\hline
BeamFormer (48x16) & 596 & 209 & N/A & N/A & 15 & 0.3 & 840\\
\hline
FM Radio & 511 & 14 & 107 & 141 & 11 & 41 & 258\\
\hline
FFT & 174 & 31 & 641 & 35.75 & 15 & 27.8 & 4.25\\
\hline
GSM Decoder & 1925 & 14 & 58.6 & N/A & 16 & 60.4 & N/A\\
\hline
CRC & 336 & 47 & 35.1 & N/A & 5 & 52.4 & N/A\\
\hline
%%Matrix & \\
%%\hline
\end{tabular}
\vspace{-6pt}
\caption{\protect\small Performance Results.}
\label{tab:performance}
\vspace{-21pt}
\end{center}
\end{table}

We evaluate the StreamIt compiler for the set of applications shown in
Table~\ref{tab:benchmarks}; results appear in
Figure~\ref{tab:performance}.  We show the performance of the original
application, which maps each Filter in the original program to a
single Raw tile.  In some cases, we need to use an 8x8 Raw processor
in order to have enough tiles for the Filters; otherwise, we target a
4x4 configuration of Raw.  To obtain the ``optimized'' numbers, we
perform a series of fusion, fission and reordering transformations to
create a load-balanced set of filters that can be mapped onto a 4x4
Raw processor. Figures~\ref{fig:opt-diagram} and
\ref{fig:utilization-diagram} depict the impact of our load balancing
transformations on performance and tile utilization, respectively.

\begin{figure}
\begin{minipage}{3.2in}
\centering
\psfig{figure=speedup-diagram.eps,width=3.3in}
\caption{The speedup due to load balancing normalized to original performance.
\protect\label{fig:opt-diagram}}
\end{minipage}
\hspace{0.1in}
\begin{minipage}{3.2in}
\centering
\psfig{figure=utilization-diagram.eps,width=3.2in}
\caption{Utilization of a tile ofter load balancing normalized to the original utilization.\protect\label{fig:utilization-diagram}}
\end{minipage}
\end{figure}

The results show that for programs with substantial computation
requirements such as the BeamFormer, the StreamIt compiler is able to
extract good performance out of the Raw processor.  The BeamFormer
application shows a sustained 1.03 GFLOPS rate, after a 400\%
improvement due to our optimizations.  However, programs such as FFT,
which was created to experiment with the language features of
StreamIt, has very little work per filter. We were unable to amortize
the communication overhead for FFT, leading to a slowdown.  Better
tile code generation and traditional optimizations may help improve
the performance.

\begin{figure}
\centering
\psfig{figure=beam-graph-orig.eps,width=1.97in}
\caption{\protect\small Stream graph of the original 12x4 BeamFormer.  The 12x4 BeamFormer has 12 channels and 4 beams; it is the largest version that fits onto 64 tiles without filter fusion.  \protect\label{fig:beam-orig}}
\vspace{36pt}
\psfig{figure=beam-graph-opt.eps,width=6in}
\caption{\protect\small Stream graph of the load-balanced 12x4 BeamFormer.  Vertical fusion is applied to collapse each pipeline into a single filter, and horizontal fusion is used to transform the 4-way SplitJoin into a 2-way SplitJoin.
Figure~\ref{fig:beam-blood} shows the benefit of these
transformations. \protect\label{fig:beam-opt}}
\end{figure}

\begin{figure}
  \begin{center} \psfig{figure=beam-blood-key.eps,width=3.25in} \\
    \subfigure[\vspace{-6pt}
    Original.\label{fig:beam-blood1}]{\psfig{figure=beam-blood-orig.eps,width=3in}}
    \hspace{0.3in} \subfigure[\vspace{-6pt}
    Load-balanced.\label{fig:beam-blood2}]{\psfig{figure=beam-blood-opt.eps,width=3in}
    \vspace{-6pt}} \vspace{-6pt} \caption{Execution traces for the (a)
    original and (b) load-balanced partitionings of the BeamFormer.
    Graphs are colored as in
    Figure~\ref{fig:fm-blood}. \protect\label{fig:beam-blood}}
    \vspace{-6pt}
\end{center}
\end{figure}
