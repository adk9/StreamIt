\section{Introduction}

As the size of the transistor becomes smaller and smaller, the next
generation of microprocessors will have to be conscious of wire delays
as the fundamental barrier to performance.  Recently, a number of
architectures have been emerging that address the problem of wire
delay by replicating the basic processing unit and exposing the
communication between units to a software layer ({\it e.g.}, Raw
\cite{rawshort}, SmartMemories \cite{smartmemories}, TRIPS
\cite{trips}).  These machines are especially well-suited for
streaming applications that have regular communication patterns and
widespread parallelism.

However, today's communication-exposed architectures are lacking a
portable programming model.  If these machines are to be widely used,
it is imperative that one be able to write a program once, in a
high-level language, and rely on a compiler to produce an efficient
executable on any of the candidate targets. For von-Neumann machines,
the C programming language served this purpose; it abstracted away the
idiosyncratic details between one machine and another, but
encapsulated the common properties (such as a single program counter,
arithmetic operations, and a monolithic memory) that are necessary to
obtain good performance.  However, for wire-exposed targets that
contain multiple instruction streams and distributed memory banks, C
is obsolete.  Though C can still be used to write efficient programs
on these machines, doing so either requires architecture-specific
directives or a very smart compiler that can extract the parallelism
and communication from the C semantics.  Both of these options
disqualify C as a portable machine language, since it fails to hide
the architectural details from the programmer and it imposes
abstractions which are a mismatch for the domain.

In this paper, we describe a compiler for StreamIt: a high level
stream language that aims to be portable across communication-exposed
machines \cite{streamitcc}.  StreamIt contains basic constructs that
expose the parallelism and communication of streaming applications
without depending on the granularity of the underlying architecture.
Our current backend is for Raw \cite{rawshort}, a tiled architecture
with fine-grained, programmable communication between processors.
However, the compiler consists of three general techniques that can be
applied to compile StreamIt to machines other than Raw: 1)
partitioning, which adjusts the granularity of a stream graph to match
that of a given target, 2) layout, which maps a partitioned stream
graph to a given network topology, and 3) scheduling, which generates
a fine-grained static communication pattern for each computational
element.  We consider this work to be a first step towards a portable
programming model for communication-exposed architectures.

The rest of this paper is organized as follows.  Section
\ref{sec:streamit} provides an introduction to StreamIt,
Section~\ref{sec:raw} contains an overview of Raw, and
Section~\ref{sec:phases} outlines our compiler for StreamIt on Raw.
Sections \ref{sec:partition}, \ref{sec:layout}, and \ref{sec:communic}
describe our algorithms for partitioning, layout, and communication
scheduling, respectively.  Section~\ref{sec:results} presents our
results from the cycle-accurate Raw simulator.
Section~\ref{sec:related} considers related work, and
Section~\ref{sec:conclusion} contains our conclusions.
