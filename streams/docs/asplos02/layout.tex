\section{Layout}

The goal of the layout phase is to assign nodes in the stream graph to
computation nodes in the target architecture while minimizing the
communication and synchronization present in the final layout.  The
final layout assigns exactly one node in the stream graph to one
computation node in the target.  The layout phase assumes that the
given stream graph will fit onto the computation fabric of the target
and that each filter is load balanced.  Both of these requirements are
satisfied by the partitioning phase described above.

Classically, layout (or placement) algorithms have fallen into two
categories: constructive initial placement and iterative improvement
[citation 11 of Wiengold].  Both try to minimize a predetermined cost
function.  In constructive initial placement, the algorithm calculates
a solution from scratch, using the first complete placement
encountered.  Iterative improvement starts with an initial random
layout and repeatedly perturbs the placement in order to minimize the
cost function.

The layout phase of the streamit compiler is implemented using
simulated annealing [old simulated annealing paper], a type of
iterative improvement.  A detailed explanation of simulated annealing
is beyond the scope of this paper, but we will mention the following.
Simulated annealing is a form of stochastic hill-climbing. Unlike most
other methods for cost function minimization, simulated annealing is
suitable for problems where there are many local minima.  Simulated
annealing achieves its success by allowing the system to go uphill
with some probability as it searches for the global minima.  As the
simulation proceeds, the probability of climbing uphill decreases.
  
We chose to use simulated annealing because its performance and its
flexibly.  To retarget the layout phase of the compiler, we simply
supply the annealing algorithm with three elements: the cost function,
a perturbation function, and the set of legal layouts.  Furthermore,
for most tiled targets these three functions could be reused.

Clearly, the choice of cost function will greatly determine the
performance of the generated layout.  The cost function should
accurately measure the added communication and synchronization
generated by mapping the stream graph to the communication model of
the target.  Due to the static qualities of StreamIt, the compiler can
provide the layout phase with exact knowledge of the communication
properties of the stream graph.  The cost function can calculate the
number of items that travel over a channel during each execution of
the steady state.  Furthermore, with knowledge of the routing
algorithm, the cost function can determine the intermediate hops for
each channel.  These properties can be used to tailor the cost
function to target architecture.

Depending on the communication model of the target architecture, these
metrics can be extremely important in generating a good layout.  For
architectures with non-uniform communication, the layout phase can use
this knowledge to take advantage of the specific properties of the
architecture.  For example, in a Smart Memories architecture [ref], we
would like to place the nodes that communicate over an expensive
channel on the same quad.

\subsection{Layout on Raw}

The layout phase of our StreamIt compiler maps nodes in the stream
graph to the tile processors on Raw.  Each tile processor looks very
much likes a MIPS R4000[ref].  The tile processor uses a MIPS
instruction set with some slight modifications for inter-tile
communication.  The layout phase does not assign each node in the
stream graph to a processor.  Splitter nodes are folded into their
neighboring up-stream filter and neighboring joiners are collapsed
into a single tile.  This mapping will be explained in more depth in
the next section.  Again, all nodes needing assignment are mapped to
exactly one tile processor.

Due to the properties of the static network and the communication
scheduler (see next section), the layout phase does not have to worry
about deadlock.  All assignments of nodes to tiles are legal.  This
gives simulated annealing the flexibility to search many possibilities
and simplifies the layout phase.  The perturbation function used in
simulated annealing simply swaps the assignment of two randomly chosen
tile processors.

The cost function is the most important parameter of the simulated
annealing algorithm.  After some experimentation, we have arrived at
the following cost function: 

%%Sum over channels (items(channel) *
%%(hops(channel) + (num_assigned(channel) * 2)^3) 

Where item(channel) gives the number of data items that traverse the
channel for each steady state execution.  Hops(channel) gives the
number of intermediate tiles traversed on the route of the channel.
Finally, assigned attempts to give a cost to the added
synchronization imposed by this channel assignment.  assigned
calculates the number of tiles that are assigned to filters plus the
number of tiles involved in routing other channels on the route.

With the above cost function, we heavily weigh the added
synchronization imposed by the layout.  For Raw this metric is far
more important than the length of the route because neighbor
communication over the static network is cheap.  If a tile that is
assigned a filter must route data items through it, then it must
synchronize the routing of these items with the execution of its
work().  Also, a tile that is involved in the routing of many
channels must serialize the routes running through it.  Both limit
the amount of parallelism in the layout and need to be avoided.

Using the parameters described above, simulated annealing calculates
highly optimized assignments.  The layouts are generated rather
quickly (about ?? minutes for the FMRadio application).  In figure ?? 
we show the initial random placement for the load-balanced FMRadio and
in figure ?? + 1 we show the layout annealing calculated.  Clearly,
the optimized assignment is superior to the random placement.
Importantly, the optimized placement minimizes the number of filters
involved in routing data.
