\section{Layout}

The goal of the layout phase is to assign nodes in the stream graph to
computation nodes in the target architecture while minimizing the
communication and synchronization present in the final layout.  The
final layout assigns exactly one node in the stream graph to one
computation node in the target.  The layout phase assumes that the
given stream graph will fit onto the computation fabric of the target
and that each filter is load balanced.  Both of these requirements are
satisfied by the partitioning phase described above.

Classically, layout (or placement) algorithms have fallen into two
categories: constructive initial placement and iterative improvement
[citation 11 of Wiengold].  Both try to minimize a predetermined cost
function.  In constructive initial placement, the algorithm calculates
a solution from scratch, using the first complete placement
encountered.  Iterative improvement starts with an initial random
layout and repeatedly perturbs the placement in order to minimize the
cost function.

The layout phase of the streamit compiler is implemented using
simulated annealing [old simulated annealing paper], a type of
iterative improvement.  A detailed explanation of simulated annealing
is beyond the scope of this paper, but we will mention the following.
Simulated annealing is a form of stochastic hill-climbing. Unlike most
other methods for cost function minimization, simulated annealing is
suitable for problems where there are many local minima.  Simulated
annealing achieves its success by allowing the system to go uphill
with some probability as it searches for the global minima.  As the
simulation proceeds, the probability of climbing uphill decreases.
  
We chose to use simulated annealing because its performance and its
flexibly.  To retarget the layout phase of the compiler, we simply
supply the annealing algorithm with three elements: the cost function,
a perturbation function, and the set of legal layouts.  Furthermore,
for most tiled targets these three functions could be reused.

Clearly, the choice of cost function will greatly determine the
performance of the generated layout.  The cost function should
accurately measure the added communication and synchronization
generated by mapping the stream graph to the communication model of
the target.  Due to the static qualities of StreamIt, the compiler can
provide the layout phase with exact knowledge of the communication
properties of the stream graph.  The cost function can calculate the
number of items that travel over a channel during each execution of
the steady state.  Furthermore, with knowledge of the routing
algorithm, the cost function can determine the intermediate hops for
each channel.  These properties can be used to tailor the cost
function to target architecture.

Depending on the communication model of the target architecture, these
metrics can be extremely important in generating a good layout.  For
architectures with non-uniform communication, the layout phase can use
this knowledge to take advantage of the specific properties of the
architecture.  For example, in a Smart Memories architecture [ref], we
would like to place the nodes that communicate over an expensive
channel on the same quad.
