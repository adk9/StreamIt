\section{Code Generation}
\label{sec:codegen}

The final phase in the flow of the StreamIt compiler is code
generation.  The code generation phase must use the results of each of
the previous phases to generate the complete program text.  The
results of the partitioning and layout phases are used to generate the
computation code that executes on a computation node of the target.
The communication code of the program is generated from the schedules
produced by the communication scheduler.

\begin{table*}[t]
\begin{center}
\scriptsize
\begin{tabular}{|l|l||r||r|r|r|r||r||} \hline
 & & {\bf lines of} & \multicolumn{4}{|c||}{\bf \# of constructs in the program} & {\bf \# of filters in the} \\ \cline{4-7}
{\bf Benchmark} & {\bf Description} & {\bf code} & filters & pipelines & splitjoins & feedbackloops & {\bf expanded graph}
\\
\hline \hline
FIR & 64 tap FIR & 
125 & 5 & 1 & 1 & 0 & 132
\\ \hline
Radar & Radar array front-end\cite{pca} & 
549 & 8 & 3 & 3 & 0 & 52
\\ \hline
Radio & FM Radio with an equalizer & 
525 & 14 & 6 & 6 & 0 & 26
\\ \hline
Sort & 32 element Bitonic Sort & 
419 & 4 & 5 & 5 & 0 & 242
\\  \hline
FFT & 64 element FFT & 
200 & 3 & 3 & 3 & 0 & 24
\\  \hline
Filterbank & 8 channel Filterbank & 
650 & 9 & 3 & 3 & 1 & 51
\\  \hline
GSM & GSM Decoder & 
2261 & 26 & 11 & 11 & 2 & 46
\\ \hline
Vocoder & 28 channel Vocoder &  
1964 & 55 & 8 & 8 & 1 & 101
\\ \hline
3GPP & 3GPP Radio Access Protocol &  
1087 & 16 & 10 & 10 & 0 & 48
\\ \hline
\hline
\end{tabular}
\vspace{-6pt}
\caption{\protect\small Application Characteristics.}
\label{tab:benchmarks}
\vspace{-12pt}
\end{center}
\end{table*}

\begin{table*}[t]
\begin{center}
\scriptsize
\begin{tabular}{|l||r|r|r|r||r||r||} \hline
& \multicolumn{5}{|c||}{\bf 250 MHz Raw processor} & {\bf C on a 2.2 GHz} \\ 
\cline{2-6} 
{\bf Benchmark} & \multicolumn{4}{|c||}{\bf StreamIt on 16 tiles} & {\bf C on a single tile} & {\bf Intel Pentium IV}\\ 
\cline{2-7}
& {\bf Utilization} &
\begin{tabular}{c}\hspace{-5pt} {\bf \# of tiles} \hspace{-5pt}\\
\hspace{-5pt} {\bf used} \hspace{-5pt}
\end{tabular} &    
 {\bf MFLOPS} & 
\begin{tabular}{c}\hspace{-5pt} {\bf Throughput} \hspace{-5pt}\\
\hspace{-5pt} {\bf (per 10$^5$ cycles)} \hspace{-5pt}
\end{tabular} &    
\begin{tabular}{c}\hspace{-5pt} {\bf Throughput} \hspace{-5pt}\\
\hspace{-5pt} {\bf (per 10$^5$ cycles)} \hspace{-5pt}
\end{tabular} &    
\begin{tabular}{c}\hspace{-5pt} {\bf Throughput} \hspace{-5pt}\\
\hspace{-5pt} {\bf (per 10$^5$ cycles)} \hspace{-5pt}
\end{tabular} \\    
\hline \hline
FIR    & 86\% &  14 & 812 &  1094.9  & 293.5 & 445.6 \\ \hline
Radar  & 79\% & 16 & 1,231 &     2.5  & {\it app. too large} & 0.041 \\ \hline
Radio  & 73\% & 16 & 421 &    53.9  & 8.85 & 14.1 \\ \hline
Sort   & 64\% & 16  & N/A &  2,664.4 & 225.6 & 239.4 \\ \hline
FFT    & 42\% & 16  & 182 &  2,141.9 & 468.9 & 448.5  \\ \hline
Filterbank & 
       41\% & 16  &  644 &   256.4  & 8.9 & 7.0   \\ \hline
GSM    & 23\% & 16 & N/A &    80.9  & {\it app. too large} & 7.76 \\ \hline
Vocoder& 23\% & 15  & 118 &     .31  & {\it app. too large} & 3.35  \\ \hline
3GPP   & 18\% & 16  & 44 &   119.6  & 17.3  & 65.7   \\ \hline \hline
\end{tabular}
\vspace{-6pt}
\caption{\protect\small Performance Results.}
\label{tab:performance}
\end{center}
\vspace{-12pt}
\end{table*}

\subsection{Code Generation for Raw}

The code generation phase of the Raw backend generates code for both
the tile processor and the switch processor.  For the switch
processor, we generate assembly code directly.  For the tile
processor, we generate C code that is compiled using Raw's GCC port.
First we will discuss the tile processor code generation.  We can
directly translate the intermediate representation of most StreamIt
expressions into C code.  Translations for the {\tt push(value)}, {\tt
peek(index)}, and {\tt pop()} expressions of StreamIt require more
care.

In the translation, each filter collects the data necessary to fire in
an internal buffer.  Before each filter is allowed to fire, it must
receive \emph{pop} items from its switch processor (\emph{peek} items
for the initial firing).  The buffer is managed circularly and the
size of the buffer is equal to the number of items peeked by the
filter.  {\tt peek(index)} and {\tt pop()} are translated into
accesses of the buffer, with {\tt pop()} adjusting the end of the
buffer, and {\tt peek(index)} accessing the $index^{th}$ element from
the end of the buffer.  {\tt push(value)} is translated directly into
a send from the tile processor to the switch processor.  The switch
processors are then responsible for routing the data item.

The filter code does not interleave send instructions with receive
instructions.  The filter must receive all of the data necessary to
fire before it can execute its work function.  This is an overly
conservative approach that prevents deadlock for certain situations,
but limits parallelism.  For example, this technique prevents
feedbackloops from deadlocking by serializing the loop and the body.
The loop and the body cannot execute in parallel.  We are
investigating methods for relaxing the serialization.

As described in Section \ref{sec:rawcommunic}, the communication
scheduler computes an internal buffer schedule for each collapsed
Joiner node.  This schedule exactly describes the order in which to
send and receive data items from within the Joiner.  The schedule is
annotated with the destination buffer of the receive instruction and
the source buffer of the send instruction.  Also, the communication
scheduler calculates the maximum size of each buffer.  With this
information the code generation phase can produce the code necessary
to realize the internal buffer schedule on the tile processor.

Lastly, to generate the instructions for the switch processor, we
directly translate the switch schedules computed by the communication
scheduler.  The initialization switch schedule is followed by the steady
state switch schedule, with the steady state schedule looping infinitely.
