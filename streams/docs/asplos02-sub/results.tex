\section{Results}
\label{sec:results}

We have implemented a fully-functional prototype of the StreamIt
compiler for the Raw architecture.  Our implementation includes all of
the phases described in Section~\ref{sec:phases} as well as the
optimizations.

%We have evaluated our compiler with StreamIt versions applications: 
%\begin{itemize}
%
%\item A software-based FM Radio with
%equalizer, 
%
%\item A GSM Decoder, which takes GSM-encoded parameters as
%inputs, and uses these to synthesize audible speech, 
%
%\item A \Radar application
%which encapsulates the core functionality of modern radar, sonar, and
%communications signal processors -- modeled after a system from the
%Polymorphic Computing Architecture (PCA) \cite{pca}

%\item A 64-element FFT filter implemented as a pipeline of a bit reversal 
%filter followed by multiple-stage butterfly filters.

%\item A Cyclic Redundancy Check (CRC) Encoder/Decoder, which is an error detection system utilizing a predefined 32 bit generator polynomial.  It can detect errors in bit strings of up to 64KB in size with 99.99999997% accuracy.

%\item Matrix Multiplication 

%\item A MP3

%\item A performance test from the SpectrumWare system that
%implements an Orthogonal Frequency Division Multiplexor (OFDM)
%\cite{spectrumware}.  Table \ref{tab:benchmarks} gives characteristics
%of the above applications including the number of filters implemented
%and the size of the stream graph as coded.

%%\end{itemize}

We evaluate the StreamIt compiler for the set of applications shown in
Table~\ref{tab:benchmarks}; results appear in
Table~\ref{tab:performance}, with MFLOPS calculated using Raw's target
clock speed of 250 MHz.  We show the performance of the original
application, which maps each Filter in the original program to a
single Raw tile.  In some cases, we need to use an 8x8 Raw processor
in order to have enough tiles for the Filters; otherwise, we target a
4x4 configuration of Raw.  To obtain the ``optimized'' numbers, we
perform a series of fusion, fission and reordering transformations to
create a load-balanced set of filters that can be mapped onto a 4x4
Raw processor.  Figures~\ref{fig:opt-diagram} and
\ref{fig:utilization-diagram} depict the impact of our load balancing
transformations on throughput and tile utilization, respectively.

The results show that for programs with substantial computation
requirements, the StreamIt compiler is able to extract good
performance out of the Raw processor.  For example, the \Radar
application (see Figure~\ref{fig:beamcode} for source code) shows a
sustained 1.47 GFLOPS rate, after a 145\% improvement due to our
optimizations.  Figures~\ref{fig:beam-orig} and~\ref{fig:beam-opt}
give the original and optimized configurations of \Radar's stream
graph, and Figure~\ref{fig:beam-blood} illustrates the impact of our
load balancing optimizations .
%
%However, programs such as FFT, which was created to experiment with
%the language features of StreamIt, have very little work per
%filter. We were unable to amortize the communication overhead for FFT,
%leading to a slowdown.  Better tile code generation and traditional
%optimizations may help improve the performance.
