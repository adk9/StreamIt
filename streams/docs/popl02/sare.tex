\section{Systems of Affine Recurrence Equations}

A System of Affine Recurrence Equations (SARE) is a set of equations
${\cal E}_1 \dots {\cal E}_{m_{\cal E}}$ of the following form~\cite{DRV00}:
\begin{equation}
\forall {\vec i} \in {\cal D_{\cal E}}, X({\vec i}) = f_{\cal E}(\dots, Y({\vec h}_{{\cal
E}, Y}({\vec i})), \dots)
\label{eq:sare}
\end{equation}
In this equation, our notation is as follows:
\begin{itemize}

\item $\{X, Y, \dots\}$ is the set of {\it variables} defined by the
SARE.  Variables can be considered as multi-dimensional arrays mapping
a vector of indices ${\vec i}$ to a value in some space ${\cal V}$.

\item ${\cal D_{\cal E}}$ is a polyhedron representing the {\it
domain} of the equation ${\cal E}$.  Each equation for a variable $X$
has a disjoint domain; the domain $D_X$ for variable $X$ is taken as
the convex union of all domains over which $X$ is defined.

\item ${\vec h}_{{\cal E}, Y}$ is a vector-valued affine\footnote{If
the dependence function ${\vec h}$ is a translation (${\vec h}({\vec
i}) = {\vec i} - {\vec k}$ for constant ${\vec k}$), then the SARE is
{\it uniform}, and referred to as a SURE or SRE~\cite{karp67}.}
function, giving the index of variable $Y$ that $X({\vec i})$ depends
on.  A vector-valued function ${\vec h}$ is affine if it can be
written as ${\vec h}({\vec i}) = C{\vec i} + {\vec d}$, where C is a
constant array and ${\vec d}$ is a constant vector that do not vary
with ${\vec i}$.

\item $f_{\cal E}$ is a strict function used to compute the elements
of $X$.

\end{itemize}

\section{Phased Computation Graphs}
\label{sec:pcg}

\begin{table}[t]
\small
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|} \hline
Model of Computation & Items on Channels & Nodes with & Nodes with & Cyclic Steady & Initialization \\
                     & at Start & Pop $\ne$ Push & Peek $>$ Pop & State Phases & Phases \\
\hline \hline
Synchronous Dataflow \cite{LM87} & X & X & & & \\
\hline
Cyclo-Static Dataflow \cite{BELP96} & X & X & & X & \\
\hline
Computation Graphs \cite{KM66} & X & X & X & & \\
\hline
Phased Computation Graphs & X & X & X & X & X \\
\hline
\end{tabular}
\vspace{-6pt}
\caption{\protect\small Models of Computation for Dataflow Graphs.}
\label{tab:models}
\vspace{-12pt}
\end{center}
\end{table}

We introduce the Phased Computation Graph (PCG) as a model of
computation for dataflow languages.  A PCG is a generalization of the
Computation Graphs (CG) of Karp and Miller~\cite{KM66} to the case
where each node has both an initial and steady-state execution epoch,
each of which contains a number of {\it phases}.  It is also a
generalization of other popular representations for dataflow graphs,
such as synchronous dataflow (SDF) and cyclo-static dataflow (CSDF)
(see Table~\ref{tab:models}).  Formally, a PCG is a directed graph
with the following components:
\begin{itemize}

\item Nodes $n_1 \dots n_{m_n}$.

\item Channels $c_1 \dots c_{m_c}$, where each channel is directed
from a given node $n_a$ to a given node $n_b$.

\item A non-negative integer $A(c)$ indicating the number of items
  that are initially present on channel $c$.

\item The number of phases $\mt{num}(n, t)$ that node $n$ exhibits
during epoch $t$.  Here $t$ indicates the type of epoch, which is
either initial ($\mt{init}$) or steady-state ($\mt{steady}$).  For all
$n$, $\mt{num}(n, \mt{init}) \ge 0$ and $\mt{num}(n, \mt{steady}) \ge
1$.

\item Non-negative integers $U(c, t, p)$, $O(c, t, p)$, and $E(c, t,
p)$, which give the number of items pushed, popped, and peeked,
respectively, over channel $c$ during the $p$'th phase of epoch $t$.

\end{itemize}

\subsection{Execution Model}

We give an informal description of the execution semantics of a PCG,
which is an intuitive extension to that of a CG.  An execution
consists of a sequence of atomic {\it firings} of nodes in the graph.
The effect of firing a given node depends on the epoch (which is a
global state of the graph) and the phase (which is a local state of
each node). At the start of execution, the graph is in the initial
epoch, each node is in phase 0, and each channel $c$ contains $A(c)$
items.

Let us consider a node $n$ that is in phase $p$ within a graph that is
in epoch $t$.  It is legal for $n$ to fire if $p \in [0, \mt{num}(n,
t)-1]$ and, for each channel $c_{in}$ directed into $n$, there are at
least $E(c_{in}, t, p)$ items on $c_{in}$.  The effect of this firing
is to consume $O(c_{in}, t, p)$ items from each channel $c_{in}$
directed into $n$; to produce $U(c_{out}, t, p)$ new items on each
channel $c_{out}$ directed out of $n$; and to advance the phase $p$ of
$n$ to $\mt{next}(t, p)$.  In the initial epoch, each phase executes
only once and $\mt{next}(\mt{init}, p) = p + 1$; in the
steady-state epoch, the phases execute cyclically and
$\mt{next}(\mt{steady}, p) = (p + 1)~\mt{mod}~\mt{num}(n, t)$.

From the starting state of the graph, execution proceeds through the
initial epoch via a sequence of node firings.  The order of node
firings is constrained only by the conditions given above.  When no
further node can fire in the initial epoch, the graph enters the
steady state epoch and the phases of all nodes are reset to 0.
Execution then continues by a (possibly infinite) sequence of
steady-state firings.

\section{Phased Computation Program}

The PCG described above is a representation for a graph, treating each
node and channel as a black box.  Here we introduce some notation for
the internals of the nodes, as well as the ordering of items on the
channels.  We refer to the aggregate model as a Phased Computation
Program (PCP).  Before describing a PCP, we will need some additional
notation:
\begin{itemize}

\item We assume that all items passed over channels are drawn from the
same domain of values ${\cal V}$.

\item An array type\footnote{To simplify the presentation, we allow
ourselves a slight abuse of notation by sometimes using arrays instead
of enumerating individual elements.  Our definitions could be expanded
into strict element-wise SARE's without any fundamental change to the
technique.} of length $n$ and element type $\tau$ is denoted by
$\tau[n]$.  Given a two-dimensional array $A$ of type $\tau[n][m]$,
$A[i][*]$ denotes the $m$-element array comprising the $i$'th row of
$A$.

\item $\mt{num\_in}(n)$ (resp. $\mt{num\_out}(n)$) denotes the number of
channels that are directed into (resp. out of) node $n$.

\item $\mt{chan\_in}(n)$ (resp. $\mt{chan\_out}(n)$) denotes the list of
channels that are directed into (resp. out of) node $n$.

\item $\mt{pos\_in}(n, c)$ (resp. $\mt{pos\_out}(n, c)$) denotes the
position of channel $c$ in $\mt{chan\_in}(n)$
(resp. $\mt{chan\_out}(n)$.  That is, $\mt{chan\_out}(n)[\mt{pos\_out(n,
c)}] = c$.

\end{itemize}

A PCP consists of the following:
\begin{itemize}

\item A Phased Computation Graph $G = (\{n_1 \dots n_{m_n}\}, \{c_1
\dots c_{m_c}\}, A, \mt{num}, U, O, E)$ describing the nodes,
channels, and I/O rates of the program (see Section~\ref{sec:pcg}).
Each channel $c = (n_a, n_b)$ is a FIFO queue; $n_a$ pushes items onto
the back of $c$ and $n_b$ consumes items from the front of $c$.

\item The initial values $I(c)$ that are enqueued onto channel $c$ at
the start of execution.  Since there are $A(c)$ initial values on
channel $c$, $I(c)$ has type ${\cal V}[A(c)]$.

%An initialization function $I(c)$ that returns an array of
%length $A(c)$, the elements of which are enqueued onto channel $c$ at
%the start of execution.  The procedure $I(c)$ takes no arguments; its
%signature is $\mt{void} {\small \rightarrow} {\cal V}[A(c)]$.
%
\item A work function $W(n, t, p)$ that represents the computation of
node $n$ in phase $p$ and epoch $t$.  The signature of $W(n, t, p)$ is
$[{\cal V}[E(\mt{chan\_in}(n)[1], t, p)], \dots, {\cal
V}[E(\mt{chan\_in}(n)[\mt{num\_in}(n)], t, p)]] {\small \rightarrow} [ {\cal
V}[U(\mt{chan\_out}(n)[1], t, p)], \dots, {\cal
V}[U(\mt{chan\_out}(n)[\mt{num\_out}(n)], t, p)]]$.  That is, the function
inputs a list of arrays, each of which corresponds to an incoming
channel $c$ and contains the $E(c,t,p)$ values that $n$ reads from $c$
in a given firing.  The procedure returns a list of arrays, each of
which corresponds to an outgoing channel $c$ and contains the
$U(c,t,p)$ values that $n$ writes to $c$ in a given firing.

\end{itemize}

%The components $I$ and $W$ above are referred to as ``procedures''
%rather than mathematical functions because we expect them to be
%represented as blocks of source code for an actual procedure
%declaration, thereby allowing a straightforward conversion to a PCG
%from a dataflow program.  However, 

