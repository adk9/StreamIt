\section{Notes not to forget}

\begin{itemize}

\item it's important that N effects the domains, not the variables.

\item can model state in a SARE with a self-loop from one iter to the next.

\item emphasize what is and is not resolvable at compile time.

\item motivation for peeking, phases, init/steady epochs.  Code
example in StreamIt?

\item more background on SARE's -- equivalent to static control flow
programs.

\item emphasize that with more fine-grained specifications of the work
functions, you have powerful fine-grained analysis of whole program.

\item fill in explanation for the equations, balance equations, etc.

\item Need better typesetting - all the figures in a table?

\end{itemize}

\section{Introduction}

\begin{itemize}

\item Background on SDF/CSDF and SARE's; how they're comming from
different communities that have been disconnected 'til now.  Review
how landbreaking it was when Feautrier showed static control flow
programs are equivalent to SARE's.

\end{itemize}

\section{SARE}

A System of Affine Recurrence Equations (SARE) is a set of equations
${\cal E}_1 \dots {\cal E}_{m_{\cal E}}$ of the following form~\cite{DRV00}:
\begin{equation}
\forall i \in {\cal D_{\cal E}}, X(i) = f_{\cal E}(\dots, Y(h_{{\cal
E}, Y}(i)), \dots)
\label{eq:sare}
\end{equation}
In this equation, our notation is as follows:
\begin{itemize}

\item $\{X, Y, \dots\}$ is the set of {\it variables} defined by the
SARE.  Variables can be considered as multi-dimensional arrays mapping
an index to a value.

\item ${\cal D_{\cal E}}$ is a polyhedron representing the {\it
domain} of the equation ${\cal E}$.  Each equation for a variable $X$
has a disjoint domain; the domain $D_X$ for variable $X$ is taken as
the convex union of all domains over which $X$ is defined.

\item $h_{{\cal E}, Y}$ is a vector-valued affine function, giving the
index of variable $Y$ that $X(i)$ depends on.

\item $f_{\cal E}$ is a strict function used to compute the elements
of $X$.

\end{itemize}

If each dependence function $h$ is a translation ($h(i) = i - k$ for
constant $k$) then the SARE is {\it uniform}, and referred to as a
SURE or SRE~\cite{karp67}.

\section{Phased Computation Graphs}
\label{sec:pcg}

We introduce the Phased Computation Graph (PCG) as a model of
computation for dataflow languages.  A PCG is a generalization of the
Computation Graphs (CG) of Karp and Miller~\cite{KM66} to the case
where each node has both an initial and steady-state execution epoch,
each of which contains a number of {\it phases}.  Formally, a PCG is a
directed graph with the following components:
\begin{itemize}

\item Nodes $n_1 \dots n_{m_n}$.

\item Channels $c_1 \dots c_{m_c}$, where each channel is directed
from a given node $n_a$ to a given node $n_b$.

\item A non-negative integer $A(c)$ indicating the number of items
  that are initially present on channel $c$.

\item The number of phases $\mt{num}(n, t)$ that node $n$ exhibits
during epoch $t$.  Here $t$ indicates the type of epoch, which is
either initial ($\mt{init}$) or steady-state ($\mt{steady}$).  For all
$n$, $\mt{num}(n, \mt{init}) \ge 0$ and $\mt{num}(n, \mt{steady}) \ge
1$.

\item Non-negative integers $U(c, t, p)$, $O(c, t, p)$, and $E(c, t,
p)$, which give the number of items pushed, popped, and peeked,
respectively, over channel $c$ during the $p$'th phase of epoch $t$.

\end{itemize}

\subsection{Execution Model}

We give an informal description of the execution semantics of a PCG,
which is an intuitive extension to that of a CG.  An execution
consists of a sequence of atomic {\it firings} of nodes in the graph.
The effect of firing a given node depends on the epoch (which is a
global state of the graph) and the phase (which is a local state of
each node). At the start of execution, the graph is in the initial
epoch, each node is in phase 0, and each channel $c$ contains $A(c)$
items.

Let us consider a node $n$ that is in phase $p$ within a graph that is
in epoch $t$.  It is legal for $n$ to fire if $p \in [0, \mt{num}(n,
t)-1]$ and, for each channel $c_{in}$ directed into $n$, there are at
least $E(c_{in}, t, p)$ items on $c_{in}$.  The effect of this firing
is to consume $O(c_{in}, t, p)$ items from each channel $c_{in}$
directed into $n$; to produce $U(c_{out}, t, p)$ new items on each
channel $c_{out}$ directed out of $n$; and to advance the phase $p$ of
$n$ to $\mt{next}(t, p)$.  In the initial epoch, each phase executes
only once and $\mt{next}(\mt{init}, p) = p + 1$; in the
steady-state epoch, the phases execute cyclically and
$\mt{next}(\mt{steady}, p) = (p + 1)~\mt{mod}~\mt{num}(n, t)$.

From the starting state of the graph, execution proceeds through the
initial epoch via a sequence of node firings.  The order of node
firings is constrained only by the conditions given above.  When no
further node can fire in the initial epoch, the graph enters the
steady state epoch and the phases of all nodes are reset to 0.
Execution then continues by a (possibly infinite) sequence of
steady-state firings.

\section{Phased Computation Program}

The PCG described above is a representation for a graph, treating each
node and channel as a black box.  Here we introduce some notation for
the internals of the nodes, as well as the ordering of items on the
channels.  We refer to the aggregate model as a Phased Computation
Program (PCP).  Before describing a PCP, we will need some additional
notation:
\begin{itemize}

\item We assume that all items passed over channels are drawn from the
same domain of values ${\cal V}$.

\item An array type\footnote{To simplify the presentation, we allow
ourselves a slight abuse of notation by sometimes using arrays instead
of enumerating individual elements.  Our definitions could be expanded
into strict element-wise SARE's without any fundamental change to the
technique.} of length $n$ and element type $\tau$ is denoted by
$\tau[n]$.  Given a two-dimensional array $A$ of type $\tau[n][m]$,
$A[i][*]$ denotes the $m$-element array comprising the $i$'th row of
$A$.

\item $\mt{num\_in}(n)$ (resp. $\mt{num\_out}(n)$) denotes the number of
channels that are directed into (resp. out of) node $n$.

\item $\mt{chan\_in}(n)$ (resp. $\mt{chan\_out}(n)$) denotes the list of
channels that are directed into (resp. out of) node $n$.

\item $\mt{pos\_in}(n, c)$ (resp. $\mt{pos\_out}(n, c)$) denotes the
position of channel $c$ in $\mt{chan\_in}(n)$
(resp. $\mt{chan\_out}(n)$.  That is, $\mt{chan\_out}(n)[\mt{pos\_out(n,
c)}] = c$.

\end{itemize}

A PCP consists of the following:
\begin{itemize}

\item A Phased Computation Graph $G = (\{n_1 \dots n_{m_n}\}, \{c_1
\dots c_{m_c}\}, A, \mt{num}, U, O, E)$ describing the nodes,
channels, and I/O rates of the program (see Section~\ref{sec:pcg}).
Each channel $c = (n_a, n_b)$ is a FIFO queue; $n_a$ pushes items onto
the back of $c$ and $n_b$ consumes items from the front of $c$.

\item The initial values $I(c)$ that are enqueued onto channel $c$ at
the start of execution.  Since there are $A(c)$ initial values on
channel $c$, $I(c)$ has type ${\cal V}[A(c)]$.

%An initialization function $I(c)$ that returns an array of
%length $A(c)$, the elements of which are enqueued onto channel $c$ at
%the start of execution.  The procedure $I(c)$ takes no arguments; its
%signature is $\mt{void} {\small \rightarrow} {\cal V}[A(c)]$.

\item A work function $W(n, t, p)$ that represents the computation of
node $n$ in phase $p$ and epoch $t$.  The signature of $W(n, t, p)$ is
$[{\cal V}[E(\mt{chan\_in}(n)[1], t, p)], \dots, {\cal
V}[E(\mt{chan\_in}(n)[\mt{num\_in}(n)], t, p)]] {\small \rightarrow} [ {\cal
V}[U(\mt{chan\_out}(n)[1], t, p)], \dots, {\cal
V}[U(\mt{chan\_out}(n)[\mt{num\_out}(n)], t, p)]]$.  That is, the function
inputs a list of arrays, each of which corresponds to an incoming
channel $c$ and contains the $E(c,t,p)$ values that $n$ reads from $c$
in a given firing.  The procedure returns a list of arrays, each of
which corresponds to an outgoing channel $c$ and contains the
$U(c,t,p)$ values that $n$ writes to $c$ in a given firing.

\end{itemize}

%The components $I$ and $W$ above are referred to as ``procedures''
%rather than mathematical functions because we expect them to be
%represented as blocks of source code for an actual procedure
%declaration, thereby allowing a straightforward conversion to a PCG
%from a dataflow program.  However, 

\section{Translating a PCP to an SARE}

In this section we give the formal translation of a Phased Computation
Program to a System of Affine Recurrence Equations.  The SARE will be
parameterized by $N$, the number of steady-state cycles that one
wishes to execute in the PCP.

\subsection{Computing the Steady State Cycle}

Let $S(n)$ denote the number of times that node $n$ fires its 0'th
phase for a balanced steady-state execution cycle of the entire graph.

\subsection{The Translation}

The translation will use the following helper functions:
\begin{itemize}

\item The number of integral points in a one-dimensional domain ${\cal
D}$ is denoted by $|{\cal D}|$.  The sign and absolute value of an
integer $i$ are given by $sign(i)$ and $abs(i)$, respectively.

\item $\mt{PartialWrite}(c,t,p) = \sum_{r=0}^{p-1} U(c, t, r)$

\item $\mt{TotalWrite}(n,c,t) = \sum_{r=0}^{\mt{num}(n, t)-1} U(c, t, r)$

\item $\mt{PartialRead}(c,t,p) = \sum_{r=0}^{p-1} O(c, t, r)$

\item $\mt{TotalRead}(n,c,t) =  \sum_{r=0}^{\mt{num}(n, t)-1} O(c, t, r)$

\item Given channel $c = (n_a, n_b)$:
\begin{align*}
\mt{Period}(c) \equiv S(n_a) * \mt{TotalWrite}(n_a, c, \mt{steady}) = 
S(n_b) * \mt{TotalRead}(n_b, c, \mt{steady})
\end{align*}

\end{itemize}

\subsubsection{Variables}

For each channel $c = (n_a, n_b)$, do the following:
\begin{itemize}

\item Introduce variables $\mt{IBUF}_c$ and $\mt{SBUF}_c$ with the following domains:
\begin{align*}
{\cal D}_{{IBUF}_c} = \{~i~|~0 \le i \le A(c) +
\sum_{p=0}^{\mt{num}(n_a, \mt{init})-1} U(c, \mt{init}, p) - 1 \} \\ ~ \\
%
{\cal D}_{{SBUF}_c} = \{ ~(i,j)~|~0 \le i \le N - 1 ~\wedge~ 0 \le j \le \mt{Period}(c) - 1\}
\end{align*}

\item For each $p \in [0, num(n_a, \mt{init})-1]$, introduce
variable $\mt{IWRITE}_{c, p}$ with this domain:
\begin{align*}
{\cal D}_{{IWRITE}_{c, p}} = \{~i~|~0 \le i \le U(c, \mt{init}, p) - 1\} \\
\end{align*}

\item For each $p \in [0, num(n_b, \mt{init})-1]$, introduce
variable $\mt{IREAD}_{c, p}$ with this domain:
\begin{align*}
{\cal D}_{{IREAD}_{c, p}} = \{~i~|~0 \le i \le E(c, \mt{init}, p) - 1\} \\
\end{align*}

\item For each $p \in [0, num(n_a, \mt{steady})-1]$, introduce
variable $\mt{SWRITE}_{c, p}$ with this domain:
\begin{align*}
{\cal D}_{{SWRITE}_{c, p}} = \{~(i,j,k)~|~0 \le i \le N-1 ~\wedge~ 0 \le j \le S(n_a) - 1 ~\wedge~ 0 \le k \le U(c, \mt{steady}, p) - 1\} \\
\end{align*}

\item For each $p \in [0, num(n_b, \mt{steady})-1]$, introduce
variable $\mt{SREAD}_{c, p}$ with this domain:
\begin{align*}
{\cal D}_{{SREAD}_{c, p}} = \{~(i,j,k)~|~0 \le i \le N-1 ~\wedge~ 0 \le j \le S(n_b) - 1 ~\wedge~ 0 \le k \le E(c, \mt{steady}, p) - 1\} \\
\end{align*}

\end{itemize}

\subsubsection{Equations}

For each channel $c = (n_a, n_b)$, do the following:

\begin{itemize}

\item Introduce this equation (I to IBUF):
\begin{align*}
\forall i \in [0,A(c)-1],~\mt{IBUF}_{c}(i) = I(c)[i] \\
\end{align*}

\item For each $p \in [0, num(n_a, \mt{init})-1]$, introduce this
equation (IWRITE to IBUF):
\begin{align*}
\forall i \in [A(c) + \mt{PartialWrite}(c,\mt{init},p), 
               A(c) + \mt{PartialWrite}(c,\mt{init},p+1)-1], \\
\mt{IBUF}_{c}(i) = \mt{IWRITE}_{c, p}(i - A(c) - \mt{PartialWrite}(c,\mt{init},p)) \\
\end{align*}

\end{itemize}

\noindent For each node $n$, do the following:
\begin{itemize}
%
\item For each $c \in \mt{chan\_out}(n)$, and for each $p \in [0,
num(n, \mt{init})-1]$, introduce this equation (IREAD to IWRITE):
%
\begin{align*}
\forall i \in {\cal D}_{{IWRITE}_{c, p}},~\mt{IWRITE}_{c,p}(i) = W(n, \mt{init}, p)(\mt{Init\_Inputs})[\mt{pos\_out}(n, c)][i] \\
\mt{where Init\_Inputs} = [\mt{IREAD}_{{chan\_in}(n)[1], p}(*), \dots, \mt{IREAD}_{{chan\_in}(n)[\mt{num\_in}(n)], p}(*) ]
\end{align*}
%
\item For each $c \in \mt{chan\_out}(n)$, and for each $p \in [0,
num(n, \mt{steady})-1]$, introduce this equation (SREAD to SWRITE):
%
\begin{align*}
\forall (i, j, k) \in {\cal D}_{{SWRITE}_{c, p}},~\mt{SWRITE}_{c,p}(i,j,k) = W(n, \mt{steady}, p)(\mt{Steady\_Inputs})[\mt{pos\_out}(n, c)][j] \\
\mt{where Steady\_Inputs} = [\mt{SREAD}_{{chan\_in}(n)[1], p}(i, j, *), \dots, \mt{SREAD}_{{chan\_in}(n)[\mt{num\_in}(n)], p}(i, j, *) ]
\end{align*}
%
\item For each $c \in \mt{chan\_out}(n)$, for each $p \in [0,
\mt{num}(n, \mt{steady})-1]$, and for each $q \in
[0,\frac{\mt{Period(c)}}{\mt{TotalWrite(n,c,\mt{steady})}}-\mt{1}]$,
introduce this equation (SWRITE to SBUF):
\begin{align*}
\forall (i,j) \in {\cal D}_{SW {\small \rightarrow} SB}(c,p,q), \\
\mt{SBUF}_{c}(i,j) = 
  \mt{SWRITE}_{c, p}(i * \frac{\mt{Period}(c)}{\mt{TotalWrite}(n,c,\mt{steady})} + 
                       \lfloor \frac{q}{S(n)} \rfloor, 
                     q~mod~S(n),
                     j - \mt{Offset}_{SW {\small \rightarrow} SB}(q,n,c,p)) \\
\mt{where } {\cal D}_{SW {\small \rightarrow} SB}(c,p,q) = 
  {\cal D}_{{SBUF}_{c}} \cap 
  \{ (i,j) | \mt{Offset}_{SW {\small \rightarrow} SB}(q,n,c,p) \le j
             \le \mt{Offset}_{SW {\small \rightarrow} SB}(q,n,c,p+1) - 1 \} \\ 
\mt{and } \mt{Offset}_{SW {\small \rightarrow} SB}(q,n,c,p') = q*\mt{TotalWrite}(n,c,\mt{steady}) + \mt{PartialWrite}(c,\mt{steady},p'))
\end{align*}
%
\item For each $c \in \mt{chan\_in}(n)$, and for each phase $p \in
[0, \mt{num}(n, \mt{init})-1]$, introduce this equation (IBUF to IREAD):
\begin{align*}
\forall i \in {\cal D}_{IB {\small \rightarrow} IR}(c,p), 
\mt{IREAD}_{c, p}(i) = \mt{IBUF}_{c}(\mt{PartialRead}(c, \mt{init}, p) + i) \\
\mt{and }{\cal D}_{IB {\small \rightarrow} IR}(c,p) = 
  \{ i | i \in {\cal D}_{{IREAD}_{c,p}} ~\wedge~ 
         i + \mt{PartialRead}(c, \mt{init}, p) \in {\cal D}_{{IBUF}_{c}} \}
\end{align*}
%
\item For each $c \in \mt{chan\_in}(n)$, for each phase $p \in [0,
\mt{num}(n, \mt{init})-1]$, and for \\ each $q \in [0, \lfloor
\frac{\mt{argmax}_{\mt{p}'} \left( \mt{PartialRead}(\mt{c}, \mt{init},
\mt{p}') + \mt{E}(\mt{c}, \mt{init}, \mt{p}') \right)
}{\mt{Period(c)}} \rfloor ]$, introduce this equation (SBUF to
IREAD):
\begin{align*}
\forall i \in {\cal D}_{SB {\small \rightarrow} IR}(c,p), 
\mt{IREAD}_{c,p}(i) = 
    \mt{SBUF}_{c}(q,
      i - \mt{Offset}_{SB {\small \rightarrow} IR}(q,n,c,p)) \\
\mt{where }{\cal D}_{SB {\small \rightarrow} IR}(c,p) = 
  \{ i | i \in {\cal D}_{{IREAD}_{c,p}} ~\wedge~ 
         \mt{PartialRead}(c, \mt{init}, p) + i \notin {\cal D}_{{IBUF}_{c}} ~\wedge~ \\
         \mt{Offset}_{SB {\small \rightarrow} IR}(q,n,c,p)
         \le i \le
         \mt{Offset}_{SB {\small \rightarrow} IR}(q+1,n,c,p) - 1 \} \\
\mt{where }\mt{Offset}_{SB {\small \rightarrow} IR}(q',n,c,p) = 
  q' * \mt{Period}(c) + |{\cal D}_{{IBUF}_c}| - \mt{PartialRead}(c,\mt{init},p)
\end{align*}
%
\item For each $c \in \mt{chan\_in}(n)$, and for each phase $p \in [0,
\mt{num}(n, \mt{steady})-1]$, introduce this equation (IBUF to
SREAD):
\begin{align*}
\forall (i,j,k) \in {\cal D}_{IB {\small \rightarrow} SR}(n,c,p), 
\mt{SREAD}_{c, p}(i,j,k) = 
    \mt{IBUF}_{c}(\mt{ReadIndex}(n,c,p,i,j,k)) \\
\mt{where ReadIndex}(n,c,p,i,j,k) = \mt{TotalRead}(n,c,\mt{init})
                + (i*S(n)+j)*\mt{TotalRead}(n,c,\mt{steady}) \\
                + \mt{PartialRead}(c, \mt{steady}, p) 
                + k) \\
\mt{and }{\cal D}_{IB {\small \rightarrow} SR}(n,c,p) = 
  \{ (i,j,k) | \mt{ReadIndex}(n,c,p,i,j,k) \in {\cal D}_{{IBUF}_{c}} \}
\end{align*}
%
% here is the simple, base case of the SBUF -> SREAD function
%\item For each $c \in \mt{chan\_in}(n)$, and for each phase $p \in [0,
%\mt{num}(n, \mt{steady})-1]$, introduce this equation (SBUF to
%SREAD):
%\begin{align*}
%\forall (i,j,k) \in {\cal D}_{{SREAD}_{c, p}},
%\mt{SREAD}_{c, p}(i,j,k) = 
%    \mt{SBUF}_{c}(i,
%                  j*\mt{TotalRead}(n,c,\mt{steady}) + 
%                    \mt{PartialRead}(c,\mt{steady},p) + k)
%\end{align*}
%
\item For each $c \in \mt{chan\_in}(n)$, for each phase $p \in [0,
\mt{num}(n, \mt{steady})-1]$, and for each $q \in [0, \lfloor
\frac{\mt{E(c, steady, p)}}{\mt{Period(c)}} \rfloor]$, introduce
these equations (SBUF to SREAD):
% two possible problems: sread has already been written to, or sbuf has already been read from
\begin{align*}
\forall (i,j,k) \in {{\cal D}\mt{1}}_{SB {\small \rightarrow} SR}(c,p,q), \\
\mt{SREAD}_{c, p}(i,j,k) = 
    \mt{SBUF}_{c}(i+q+
                  \mt{Int\_Offset}(n,c,p), \\
                  j*\mt{TotalRead}(n,c,\mt{steady}) + 
                    \mt{PartialRead}(c,\mt{steady},p) + k \\
                   - q * \mt{Period}(c) + \mt{Mod\_Offset}(n,c,p)) \\
\mt{where }{{\cal D}\mt{1}}_{SB {\small \rightarrow} SR}(c,p,q) = 
  ({\cal D}_{{SREAD}_{c, p}} - \mt{PUSHED}) \\
                         \cap \{ k | q * \mt{Period}(c) - min(0, \mt{Mod\_Offset}(n,c,p))
                                \le k 
                                \le min((q+1)*\mt{Period}(c),  \\
                                        E(c, \mt{steady}, p)) - 1 
                                        - max(0, \mt{Mod\_Offset}(n,c,p)) \} \\ ~ \\
%
%
\forall (i,j,k) \in {{\cal D}\mt{2}}_{SB {\small \rightarrow} SR}(c,p,q), \\
\mt{SREAD}_{c, p}(i,j,k) = 
    \mt{SBUF}_{c}(i+q+
                  \mt{sign(Offset)} + \mt{Int\_Offset}(n,c,p), \\
                  j*\mt{TotalRead}(n,c,\mt{steady}) + 
                    \mt{PartialRead}(c,\mt{steady},p) + k  \\
                   - q * \mt{Period}(c) 
                   - \mt{sign(Offset)} * \mt{Period}(c) + \mt{Mod\_Offset}(n,c,p)) \\
\mt{where }{{\cal D}\mt{2}}_{SB {\small \rightarrow} SR}(c,p,q) = 
  ({\cal D}_{{SREAD}_{c, p}} - \mt{PUSHED}) \\
                         \cap ( \{ k | q * \mt{Period}(c)
                                      \le k 
                                      \le min((q+1)*\mt{Period}(c),  \\
                                              E(c, \mt{steady}, p)) - 1 \} - {{\cal D}\mt{1}}_{SB {\small \rightarrow} SR}(c,p,q) ) \\ ~ \\
%
%
\mt{where }\mt{PUSHED}(n,c,p) = {\cal D}_{IB {\small \rightarrow} SR}(n,c,p) \\
\mt{and }\mt{Num\_Pushed}(n,c,p) = 
% this is a dot product of (i,j,k) with something
  max_{\preceq}\mt{PUSHED} \cdot (S(n) * \mt{TotalRead}(n,c,\mt{steady}), \\
                                        \mt{TotalRead}(n,c,\mt{steady}), \\
                                        1 ) + \mt{PartialRead}(c, \mt{steady}, p) \\
\mt{and }\mt{PEEKED}(c,p) = {SB {\small \rightarrow} IR}(c,p) \\
\mt{and }\mt{Num\_Popped}(c,p) = |\mt{PEEKED}| - (E(c,\mt{steady},p) - O(c,\mt{steady},p)) \\
\mt{and }\mt{Offset}(n,c,p) = \mt{Num\_Popped}(c,p)-\mt{Num\_Pushed}(n,c,p) \\
\mt{and }\mt{Int\_Offset}(n,c,p) = \mt{sign(Offset)}*\lfloor \frac{abs(\mt{Offset}(n,c,p))}{\mt{Period}(c)} \rfloor) \\
\mt{and }\mt{Mod\_Offset}(n,c,p) = \mt{sign(Offset)}*(abs(\mt{Offset}(n,c,p))~\mt{mod}~\mt{Period}(c)) \\
%
\end{align*}
%
\end{itemize}

\section{Applications}

\subsection{Semantics of Time}

\noindent {\bf \dep}

\begin{align*}
\DEP{X}{Y}(i) = max_{\preceq}~\{~ j ~|~ \exists ~&~ T_0 \dots T_n, ~ k_0 \dots k_n, ~ {\cal E}_1 \dots {\cal E}_n ~ s.t. ~ & ~ \\ 
~ & T_0 = Y ~\wedge~ T_n = X ~\wedge~ k_0 = j ~\wedge~ k_n = i ~\wedge~ & ~ \\
~ & \forall p \in 1 \dots n, ~ T_p(k_p) \equiv f_{{\cal E}_p}(\dots, T_{p-1}(h_{{{\cal E}_p}, T_{p-1}}(k_p)), \dots) ~ \} & ~ \\
\end{align*}

In StreamIt, this function is composable because of single-input,
single-output blocks.  Since every junction is a one-dimensional
array, it gives unique point in time for a given filter.  Can use this
to think modularly/composably about time in components, too.

Describe messaging semantics?  Is there space?

\subsection{Scheduling}

\subsubsection{Uniprocessor Scheduling}

\subsubsection{Parallel Scheduling}

\subsubsection{Conditional-Appearance Scheduling}

- Like SAS, but you wrap a conditional around a loop.  Automatic
  outcome of affine scheduling.

\subsection{Node Fission}

Just specify the relations within a node, and you have a complete view
of program.

\subsection{Node Fusion}

\subsection{Buffer Minimization}

\subsection{Code Size}

\subsection{Parameterized Graphs}

Don't need to duplicate code for nodes that are repeated.  Can also
parameterize the schedule along these dimensions.  Especially
well-tailored to StreamIt.  Compare to PSDF.

\subsection{Verification}

Buffer overrun, no exploding schedules, etc.

\section{Related Work}

\begin{itemize}

\item SURE's and Computation Graphs

\item SARE/Feautrier, affine dependences, static control flow programs.

\item Lim/Lam; affine scheduling.

\item The min-buffers for maximal-rate schedules stuff

\item The ptolemy / SDF / CSDF guys.  Scheduling, buffer minimization,
everything they tried to do.

\end{itemize}

\section{Conclusion}

