\section{SARE}

A System of Affine Recurrence Equations (SARE) is a set of equations
${\cal E}_1 \dots {\cal E}_{m_{\cal E}}$ of the following form~\cite{DRV00}:
\begin{equation}
\forall i \in {\cal D_{\cal E}}, X(i) = f_{\cal E}(\dots, Y(h_{{\cal
E}, Y}(i)), \dots)
\label{eq:sare}
\end{equation}
In this equation, our notation is as follows:
\begin{itemize}

\item $\{X, Y, \dots\}$ is the set of {\it variables} defined by the
SARE.  Variables can be considered as multi-dimensional arrays mapping
an index to a value.

\item ${\cal D_{\cal E}}$ is a polyhedron representing the {\it
domain} of the equation ${\cal E}$.  Each equation for a variable $X$
has a disjoint domain; the domain $D_X$ for variable $X$ is taken as
the convex union of all domains over which $X$ is defined.

\item $h_{{\cal E}, Y}$ is a vector-valued affine function, giving the
index of variable $Y$ that $X(i)$ depends on.

\item $f_{\cal E}$ is a strict function used to compute the elements
of $X$.

\end{itemize}

If each dependence function $h$ is a translation ($h(i) = i - k$ for
constant $k$) then the SARE is {\it uniform}, and referred to as a
SURE or SRE~\cite{karp67}.

%Given an equation ${\cal E}$, we will use $\mt{lhs}({\cal E})$ to
%refer to the variable defined on the left hand side of ${\cal E}$, and
%$\mt{rhs}({\cal E})$ to refer to the set of variables referenced on
%the right hand side of ${\cal E}$.  Thus, in the case of
%(\ref{eq:sare}), $\mt{lhs}({\cal E}) = X$ and $Y \in \mt{rhs}({\cal
%E})$.

\section{\dep}

\begin{align*}
\DEP{X}{Y}(i) = max_{\preceq}~\{~ j ~|~ \exists ~&~ T_0 \dots T_n, ~ k_0 \dots k_n, ~ {\cal E}_1 \dots {\cal E}_n ~ s.t. ~ & ~ \\ 
~ & T_0 = Y ~\wedge~ T_n = X ~\wedge~ k_0 = j ~\wedge~ k_n = i ~\wedge~ & ~ \\
~ & \forall p \in 1 \dots n, ~ T_p(k_p) \equiv f_{{\cal E}_p}(\dots, T_{m-1}(h_{{{\cal E}_p}, T_{m-1}}(k_p)), \dots) ~ \} & ~ \\
\end{align*}

\section{Phased Computation Graphs}
\label{sec:pcg}

We introduce the Phased Computation Graph (PCG) as a model of
computation for dataflow languages.  A PCG is a generalization of the
Computation Graphs (CG) of Karp and Miller~\cite{KM66} to the case
where each node has both an initial and steady-state execution epoch,
each of which contains a number of {\it phases}.  Formally, a PCG is a
directed graph with the following components:
\begin{itemize}

\item Nodes $n_1 \dots n_{m_n}$.

\item Channels $c_1 \dots c_{m_c}$, where each channel is directed
from a given node $n_i$ to a given node $n_j$.

\item A non-negative integer $A(c)$ indicating the number of items
  that are initially present on channel $c$.

\item The number of phases $\mt{num}(n, t)$ that node $n$ exhibits
during epoch $t$.  Here $t$ indicates the type of epoch, which is
either \textit{initial} or \textit{steady-state}.  For all $n$,
$\mt{num}(n, \mt{initial}) \ge 0$ and $\mt{num}(n, \mt{steady-state})
\ge 1$.

\item Non-negative integers $U(c, t, p)$, $O(c, t, p)$, and $E(c, t,
p)$, which give the number of items pushed, popped, and peeked,
respectively, over channel $c$ during the $p$'th phase of epoch $t$.

\end{itemize}

\subsection{Execution Model}

We give an informal description of the execution semantics of a PCG,
which is an intuitive extension to that of a CG.  An execution
consists of a sequence of atomic {\it firings} of nodes in the graph.
The effect of firing a given node depends on the epoch (which is a
global state of the graph) and the phase (which is a local state of
each node). At the start of execution, the graph is in the initial
epoch, each node is in phase 0, and each channel $c$ contains $A(c)$
items.

Let us consider a node $n$ that is in phase $p$ within a graph that is
in epoch $t$.  It is legal for $n$ to fire if $p \in [0, \mt{num}(n,
t)-1]$ and, for each channel $c_{in}$ directed into $n$, there are at
least $E(c_{in}, t, p)$ items on $c_{in}$.  The effect of this firing
is to consume $O(c_{in}, t, p)$ items from each channel $c_{in}$
directed into $n$, to produce $U(c_{out}, t, p)$ new items on each
channel $c_{out}$ directed out of $n$, and to advance the phase $p$ of
$n$ to $\mt{next}(t, p)$.  In the initial epoch, each phase executes
only once and $\mt{next}(\mt{initial}, p) = p + 1$; in the
steady-state epoch, the phases execute cyclically and
$\mt{next}(\mt{steady-state}, p) = (p + 1)~\mt{mod}~\mt{num}(n, t)$.

From the starting state of the graph, execution proceeds through the
initial epoch via a sequence of node firings.  The order of node
firings is constrained only by the conditions given above.  When no
further node can fire in the initial epoch, the graph enters the
steady state epoch and the phases of all nodes are reset to 0.
Execution then continues by a (possibly infinite) sequence of
steady-state firings.

\section{Phased Computation Program}

The PCG described above is a representation for a graph, treating each
node and channel as a black box.  Here we introduce some notation for
the internals of the nodes, as well as the ordering of items on the
channels.  We refer to the aggregate model as a Phased Computation
Program (PCP).  Before describing a PCP, we will need some additional
notation:
\begin{itemize}

\item We assume that all items passed over channels are drawn from the
same domain of values ${\cal V}$.

\item An array type\footnote{To simplify the presentation, we allow
ourselves a slight abuse of notation by using arrays in some cases
instead of enumerating each element.  Our definitions could be
expanded into strict element-wise SARE's without any fundamental
change to the technique.} of length $n$ and element type $\tau$ is
denoted by $\tau[n]$.  Given a two-dimensional array $A$ of type
$\tau[n][m]$, $A[i][*]$ denotes the $m$-element array comprising the
$i$'th row of $A$.

\item $\mt{num-in}(n)$ (resp. $\mt{num-out}(n)$) denotes the number of
channels that are directed into (resp. out of) node $n$.

\item $\mt{chan-in}(n)$ (resp. $\mt{chan-out}(n)$) denotes the list of
channels that are directed into (resp. out of) node $n$.

\item $\mt{pos-in}(n, c)$ (resp. $\mt{pos-out}(n, c)$) denotes the
position of channel $c$ in the input (resp. output) of node $n$.

\end{itemize}

A PCP consists of the following:
\begin{itemize}

\item A Phased Computation Graph $G = (\{n_1 \dots n_{m_n}\}, \{c_1
\dots c_{m_c}\}, A, \mt{num}, U, O, E)$ describing the nodes,
channels, and I/O rates of the program (see Section~\ref{sec:pcg}).
Each channel $c = (n_a, n_b)$ is a FIFO queue; $n_a$ pushes items onto
the back of $c$ and $n_b$ consumes items from the front of $c$.

\item The initial values $I(c)$ that are enqueued onto channel $c$ at
the start of execution.  Since there are $A(c)$ initial values on
channel $c$, $I(c)$ has type ${\cal V}[A(c)]$.

%An initialization function $I(c)$ that returns an array of
%length $A(c)$, the elements of which are enqueued onto channel $c$ at
%the start of execution.  The procedure $I(c)$ takes no arguments; its
%signature is $\mt{void} \rightarrow {\cal V}[A(c)]$.

\item A work function $W(n, t, p)$ that represents the computation of
node $n$ in phase $p$ and epoch $t$.  The signature of $W(n, t, p)$ is
$\{{\cal V}[E(chan-in(n)[1], t, p)], \dots, {\cal
V}[E(chan-in(n)[\mt{num-in}(n)], t, p)]\} \rightarrow {\cal
V}[U(chan-out(n)[1], t, p)], \dots, {\cal
V}[U(chan-out(n)[\mt{nun-out}(n)], t, p)]\}$.  That is, the function
inputs a list of arrays, each of which corresponds to an incoming
channel $c$ and contains the $E(c,t,p)$ values that $n$ reads from $c$
in a given firing.  The procedure returns a list of arrays, each of
which corresponds to an outgoing channel $c$ and contains the
$U(c,t,p)$ values that $n$ writes to $c$ in a given firing.

\end{itemize}

%The components $I$ and $W$ above are referred to as ``procedures''
%rather than mathematical functions because we expect them to be
%represented as blocks of source code for an actual procedure
%declaration, thereby allowing a straightforward conversion to a PCG
%from a dataflow program.  However, 

\section{Example}

For example...

\section{Translating a PCP to an SARE}

In this section we give the formal translation of a Phased Computation
Program to a System of Affine Recurrence Equations.  The SARE will be
parameterized by $N$, the number of steady-state cycles that one
wishes to execute in the PCP.

\subsection{Computing the Steady State Cycle}

Let $S(n)$ denote the number of times that node $n$ fires its 0'th
phase for a balanced steady-state execution cycle of the entire graph.

\subsection{The Translation}

For each channel $c = (n_a, n_b)$, do the following:
\begin{itemize}

\item Introduce variables $\mt{IBUF}_c$ and $\mt{SBUF}_c$ with the following domains:
\begin{align*}
{\cal D}_{\mt{IBUF}_c} = \{~i~|~0 \le i \le A(c) +
\sum_{p=0}^{\mt{num}(n_a, \mt{initial})-1} U(c, \mt{initial}, p) - 1\} \\ ~ \\
%
{\cal D}_{\mt{SBUF}_c} = \{~(i,j)~|~0 \le i \le \frac{N *
S(n_a)}{\mt{Period}(c)} * \sum_{p=0}^{\mt{num}(n_a,
\mt{steady-state})-1} U(c, \mt{steady-state}, p) \\
\wedge~0 \le j \le Period(c) \} \\ ~ \\
%
\mt{where Period}(c) = \mt{LCM}(\sum_{p=0}^{\mt{num}(n_a,
\mt{steady-state})-1} U(c, \mt{steady-state}, p), \\
\sum_{p=0}^{\mt{num}(n_b, \mt{steady-state})-1} O(c,
\mt{steady-state}, p)) \\
\end{align*}

\item For each $p \in [0, num(n_a, \mt{initial})-1]$, introduce
variable $\mt{IWRITE}_{c, p}$ with this domain:
\begin{align*}
{\cal D}_{\mt{IWRITE}_{c, p}} = \{~i~|~0 \le i \le U(c, \mt{initial}, p) - 1\} \\
\end{align*}

\item For each $p \in [0, num(n_b, \mt{initial})-1]$, introduce
variable $\mt{IREAD}_{c, p}$ with this domain:
\begin{align*}
{\cal D}_{\mt{IREAD}_{c, p}} = \{~i~|~0 \le i \le E(c, \mt{initial}, p) - 1\} \\
\end{align*}

\item For each $p \in [0, num(n_a, \mt{steady-state})-1]$, introduce
variable $\mt{SWRITE}_{c, p}$ with this domain:
\begin{align*}
{\cal D}_{\mt{SWRITE}_{c, p}} = \{~(i,j)~|~0 \le i \le N * S(n_a) - 1 ~\wedge~ 0 \le j \le U(c, \mt{steady-state}, p) - 1\} \\
\end{align*}

\item For each $p \in [0, num(n_b, \mt{steady-state})-1]$, introduce
variable $\mt{SREAD}_{c, p}$ with this domain:
\begin{align*}
{\cal D}_{\mt{SREAD}_{c, p}} = \{~(i,j)~|~0 \le i \le N * S(n_b) - 1 ~\wedge~ 0 \le j \le E(c, \mt{steady-state}, p) - 1\} \\
\end{align*}

\item Introduce this equation (I to IBUF):
\begin{align*}
\forall i \in [0,A(c)-1],~\mt{IBUF}_{c}(i) = I(c)[i] \\
\end{align*}

\item For each $p \in [0, num(n_a, \mt{initial})-1]$, introduce this
equation (IWRITE to IBUF):
\begin{align*}
\forall i \in [\mt{InitOffset}(c,p), \mt{WriteOffset}(c,p)+U(c, \mt{initial}, p)-1],
\mt{IBUF}_{c}(i) = \mt{IWRITE}_{c, p}(i - \mt{WriteOffset}(c,p)) \\
\mt{where WriteOffset}(c,p) = A(c) + \sum_{r=0}^{p-1} U(c, \mt{initial}, r)
\end{align*}

\end{itemize}
For each node $n$, do the following:
\begin{itemize}

\item For each $c \in \mt{chan-out}(n)$, and for each $p \in [0,
num(n, \mt{initial})-1]$, introduce this equation (IREAD to IWRITE):

\begin{align*}
\forall i \in {\cal D}_{\mt{IWRITE}_{c, p}},~\mt{IWRITE}_{c,p}(i) = W(n, \mt{initial}, p)(\mt{Input-Arrays})[\mt{pos-out}(n, c)][i] \\
\mt{where Input-Arrays} = \{\mt{IREAD}_{\mt{chan-in}(n)[1], p}(*), \dots, \mt{IREAD}_{\mt{chan-in}(n)[\mt{num-in}(n)], p}(*) \}
\end{align*}

\item For each $c \in \mt{chan-out}(n)$, and for each $p \in [0,
num(n, \mt{steady-state})-1]$, introduce this equation (SREAD to SWRITE):

\begin{align*}
\forall (i, j) \in {\cal D}_{\mt{SWRITE}_{c, p}},~\mt{SWRITE}_{c,p}(i,j) = W(n, \mt{steady-state}, p)(\mt{Input-Arrays})[\mt{pos-out}(n, c)][j] \\
\mt{where Input-Arrays} = \{\mt{SREAD}_{\mt{chan-in}(n)[1], p}(i, *), \dots, \mt{SREAD}_{\mt{chan-in}(n)[\mt{num-in}(n)], p}(i, *) \}
\end{align*}

\item For each $c \in \mt{chan-out}(n)$, for each $p \in [0,
\mt{num}(n, \mt{steady-state})-1]$, and for each $q \in [0,
\frac{\mt{Period}(c)}{\sum_{r=0}^{\mt{num}(n, \mt{steady-state})-1}
U(c, \mt{steady-state}, r)}-1]$, introduce this equation (SWRITE to
SBUF):
\begin{align*}
\forall (i,j) \in {\cal D}_{\mt{SW} \rightarrow \mt{SB}}(c,p,q), \mt{SBUF}_{c}(i,j) = \mt{SWRITE}_{c, p}(i * \frac{\mt{Period}(c)}{U(c, \mt{steady-state},p)} + q, j) \\
\mt{where } {\cal D}_{\mt{SW} \rightarrow \mt{SB}}(c,p,q) = {\cal D}_{\mt{SBUF}_{c}} \cap \\
\{ (i,j) | q*\mt{WriteCycle}(n,c) + \mt{WritePhase}(c,p) \\ \le j \le \\ q*\mt{WriteCycle}(n,c) + \mt{WritePhase}(c,p) + U(c, \mt{steady-state}, p) - 1 \} \\
\mt{and } \mt{WriteCycle}(n,c) = \sum_{r=0}^{\mt{num}(n, \mt{steady-state})-1} U(c, \mt{steady-state}, r) \\
\mt{and } \mt{WritePhase}(c,p) = \sum_{r=0}^{p-1} U(c, \mt{steady-state}, r)
\end{align*}

\item For each $c \in \mt{chan-in}(n)$, and for each phase $p \in
[0, \mt{num}(n, \mt{initial})-1]$, introduce this equation (IBUF to IREAD):
\begin{align*}
\forall i \in {\cal D}_{IB \rightarrow IR}(c,p), 
\mt{IREAD}_{c, p}(i) = \mt{IBUF}_{c}(\mt{ReadOffset}(c, \mt{initial}, p) + i) \\
\mt{where ReadOffset}(c,t,p) = \sum_{r=0}^{p-1} O(c, \mt{initial}, r) \\
\mt{and }{\cal D}_{IB \rightarrow IR}(c,p) = 
  \{ i | i \in {\cal D}_{\mt{IREAD}_{c,p}} ~\wedge~ 
         i + \mt{ReadOffset}(c, \mt{initial}, p) \in {\cal D}_{\mt{IBUF}_{c}} \}
\end{align*}

\item For each $c \in \mt{chan-in}(n)$, for each phase $p \in [0,
\mt{num}(n, \mt{initial})-1]$, and for \\ each $q \in [0, \lfloor
\frac{\mt{max}_{\mt{p}'} \left( \mt{ReadOffset}(\mt{c}, \mt{initial},
\mt{p}') + \mt{E}(\mt{c}, \mt{initial}, \mt{p}') \right)
}{\mt{Steady}(\mt{c})} \rfloor ]$, introduce this equation (SBUF to
IREAD):
\begin{align*}
\forall i \in {\cal D}_{SB \rightarrow IR}(c,p), 
\mt{IREAD}_{c,p}(i) = 
    \mt{SBUF}_{c}(q,
      \mt{ReadOffset}(c, \mt{initial}, p) + i - 
            |{\cal D}_{\mt{IBUF}_{c}}| - q * \mt{Steady}(c)) \\
\mt{where }{\cal D}_{SB \rightarrow IR}(c,p) = 
  \{ i | i \in {\cal D}_{\mt{IREAD}_{c,p}} ~\wedge~ 
         \mt{ReadOffset}(c, \mt{initial}, p) + i \notin {\cal D}_{\mt{IBUF}_{c}} \}
%  \{ i | \mt{ReadOffset}(c, \mt{initial}, \mt{num}(n, \mt{initial})) +
%         \mt{ReadOffset}(c, \mt{steady-state}, p) \le i \le
%         \mt{ReadOffset}(c, \mt{initial}, \mt{num}(n, \mt{initial})) +
%         \mt{ReadOffset}(c, \mt{steady-state}, p) + E(c, \mt{steady-state}, p) \\
%         ~\wedge~ i \in {\cal D}_{\mt{IREAD}_{c}} \}
\end{align*}

\item For each $c \in \mt{chan-in}(n)$, and for each phase $p \in [0,
\mt{num}(n, \mt{steady-state})-1]$, introduce this equation (IBUF to
SREAD):
\begin{align*}
\forall i \in {\cal D}_{IB \rightarrow SR}(n,c,p), 
\mt{SREAD}_{c, p}(i) = 
    \mt{IBUF}_{c}(\mt{ReadIndex}(n,c,p)) \\
\mt{where ReadIndex}(n,c,p) = \mt{ReadOffset}(c, \mt{initial}, \mt{num}(n, \mt{initial}))
                \\ + \mt{ReadOffset}(c, \mt{steady-state}, p) + i) \\
\mt{where ReadOffset}(c,t,p) \mt{ is defined as above} \\
\mt{and }{\cal D}_{IB \rightarrow SR}(n,c,p) = 
  \{ i | \mt{ReadIndex}(n,c,p) \in {\cal D}_{\mt{IBUF}_{c}} \} \\
\end{align*}

\item For each $c \in \mt{chan-in}(n)$, for each phase $p \in [0,
\mt{num}(n, \mt{steady-state})-1]$, and for each $q \in [0,
\frac{\mt{Period}(c)}{\sum_{r=0}^{\mt{num}(n, \mt{steady-state})-1}
O(c, \mt{steady-state}, r)}-1]$ introduce this equation (SBUF to
SREAD):
\begin{align*}
\forall (i,j) \in {\cal D}_{SB \rightarrow SR}(n,c,p), 
\mt{SREAD}_{c, p}(i,j) = 
    \mt{SBUF}_{c}(q,i*\mt{ReadCycle}(n,c) + \mt{ReadPhase}(c,p) + j) \\
%
\mt{where ReadCycle}(n,c) = \sum_{r=0}^{\mt{num}(n, \mt{steady-state})-1} O(c, \mt{steady-state}, r) \\
\mt{and ReadPhase}(c,p) = \sum_{r=0}^{p-1} O(c, \mt{steady-state}, r)
\end{align*}

%\item For each $t \in \{\mt{initial}, \mt{steady-state}\}$, for each
%$p \in [0, num(n, t)-1]$, and for each $c \in \mt{chan-in}(n)$,
%introduce this equation (SBUF to SREAD):
%
%\begin{align*}
%\forall (i,j) \in {\cal D}_{\mt{READ}_{c,t,p}}, \mt{READ}_{c, t, p}(i, j) = \mt{BUF}_{c}(\mt{ReadOffset}(c,t,p) + (i-1)*O(c, t, p) + j) \\
%\mt{where ReadOffset}(c,\mt{initial},p) = \sum_{k=0}^{p-1} O(c, \mt{initial}, k)\\ \mt{and ReadOffset}(c, \mt{steady-state}, p) = \sum_{k=0}^{p-1} O(c, \mt{steady-state}, k) + \mt{ReadOffset}(c,\mt{initial},\mt{num}(n,\mt{initial}))
%\end{align*}

\end{itemize}






