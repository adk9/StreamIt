OUTLINE
-------

- Introduction

- Motivation for Messaging / time in distributed system

- Semantics of Time - informal description

- Formal description via equivalence with SARE's
 . program domain is CCG's - generalization of popular dataflow frameworks
  . motivation for peeking and phases? -- give an example in streamit syntax
  . give notation for different phases, starting from streamit syntax
 . describe output domain, being SARE's / static control flow programs
 . give translation procedure from one to the other

- SDEP for SARE's

- SDEP for StreamIt graphs
 . note that since it's single-input, single-output, the max function
	gives a single index into a one-dimensional array
 . show that it's more composable; allows separate compilation / 
	modular thinking
 . also it's parameterizable - can have benefits of polyhedral model
	with parameterized graphs.  this is something that you don't get
	with an arbitrary SDF graph.

- Applications of SDEP 
 . The semantics of messages - describe message sending syntax
 . Verification

- Extensions
 . talk about using affine scheduling results applied to SDF scheduling
   . get automatic fission of nodes, which is unconsidered in sdf community
   . they talk a lot about single appearance schedules.  but they never
	have conditionals governing the executions of loops; this is 
	something that could come for free with affine scheduling
   . can talk about affine scheduling being applied to multi-phase 
	schedules -- the initialization phase is just that before each
	filter has really started

- Related Work
 . check out this buffer minimization 
  . http://epubs.siam.org/sam-bin/dbq/article/29035
 . uniformization of SARE's:
  . http://www.irisa.fr/bibli/publi/pi/2000/1350/1350.html

- Conclusion


****************************************************************************

TODO
----

- We should model state in the SARE's somehow.  With the current
notation, they're strictly stateless.

- Change (n_i, n_j) to (n_a, n_b) in the original place where it occurs.

- would it be clearer if push/pop/peek were an aspect of a node?  I think maybe.

- change "n" notation for nodes to "m" notation?  Then all the upper
bounds can be n's.

****************************************************************************

NOTES
-----

First let's do SDF with peeking -- in this case, it's just a
computation graph:

operation O_k associated with each node n_k

for every branch d_p from n_i to n_j

initially have A_p items on the branch
node n_k (dest) pops W_p items
node n_k (dest) peeks T_p items
node n_i (src)  pushes U_p items

----------------

so if there's static control flow in a node, then you can convert all
nodes to a canonical form like this, for nodes k

--

for all p s.t. there exists d_p : n_j -> n_k:
  for i = 1 to T_p
    in_p[i] = peek(i)
  for i = 1 to W_p
    pop()

// use <in>'s, write to <out>'s

for all p s.t. there exists d_p : n_k -> n_j:
  for i = 1 to U
    push( out_p[i] )

--

assume that there are no name conflicts between the bodies of
different filters.

then you can convert this to as follows.  first, there is an initial
configuration of each channel in the program:

----
for all p
  for i = 1 to A_p
    chan_p[i] = initial-value(p, i)
----

then, there is the code for each node:

----
for all p s.t. there exists d_p : n_j -> n_k:
  last_p = A_p

for m = 1 to steady_k

  for all p s.t. there exists d_p : n_j -> n_k:
    for i = 1 to T_p
      in_p[i] = chan_p[(m-1)*W_p + i]

  // use <in>'s, write to <out>'s

  for all p s.t. there exists d_p : n_k -> n_j:
    for i = 1 to U_p
      chan_p[(m-1)*U_p + i] = out_p[i]
----

can solve balance equations to get steady_k: how many times node k
executes in the steady state

---

extensions / applications:

- could formulate more coarse-grained constraints if you only wanted
to do affine scheduling.  like basically just ignore the inner contents
of the filters.

- adding sdep as the transitive dependence.
	- need to formulate it so that if there are multiple paths,
	you only take the "earliest" dependence.  Could do this as the
	minimum/maximum after the composition is done, and then prove
	properties about the resulting function (like that it, also,
	is compositional.)
- can directly solve for minimal buffer sizes

- is it possible to include CSDF?  Sure, as equations only give you
balance equations for sum of stages.  So just expand stages in the
steady state definition.  The only difference is that you'll want to
input/output them in different places (to avoid deadlock), but this is
no problem.

- need to think about the affine schedule vs. a phased schedule

- in the context of streamit, talk about extending to parameterized
splitjoins, etc.  Then you can have a parameterized schedule for a
stream graph.

- 

---

todo:
 - could optimize the in_p calculation

---

- by the way, if single-appearance schedules are just because of the
code bloat problem, why not just collapse similar iterations by having
an if statement?  they think that that's too high overhead, too?

- moreover, if there are duplicate nodes in the graph, then they
schedule them many times, too.  this would give the advangtage of
parameterizable graphs, if i can figure out how to do it.  shouldn't
be hard at all... just add a dimension to each array's state variable
in a splitjoin, and put the loop on that.

--

new realizations:

- even with a single affine schedule, you can do initialization with
different start times

- could do zero-one programming with different loop structures to see
a single-appearance schedule?  (is there a way to guarantee
single-appearance in what's generated from an affine schedule?  this
would be useful for the affine scheduling community, too.)

- the sdf community has taken for granted that you need SAS, but they
haven't thought about the sci. community's approach of having
conditionals inside loops.  this would be an easy way to improve the
latency / buffer size, etc., without exploding the code.

