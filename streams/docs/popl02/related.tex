\section{Background and Related Work}
\label{sec:related}

\subsection{Dataflow Graphs}

Strictly speaking, synchronous dataflow (SDF) refers to a class of
graphs where

\begin{itemize}

\item Computation Graphs

\item The min-buffers for maximal-rate schedules stuff

\item The ptolemy / SDF / CSDF guys.  Scheduling, buffer minimization,
everything they tried to do.

\item  check out this buffer minimization 
  http://epubs.siam.org/sam-bin/dbq/article/29035

\item uniformization of SARE's:
  http://www.irisa.fr/bibli/publi/pi/2000/1350/1350.html

\end{itemize}

\subsection{Systems of Affine Recurrence Equations}

A System of Affine Recurrence Equations (SARE) is a set of equations
${\cal E}_1 \dots {\cal E}_{m_{\cal E}}$ of the following form~\cite{DRV00,Feautrier92i}:
\begin{equation}
\forall {\vec i} \in {\cal D_{\cal E}}, X({\vec i}) = f_{\cal E}(\dots, Y({\vec h}_{{\cal
E}, Y}({\vec i})), \dots)
\label{eq:sare}
\end{equation}
In this equation, our notation is as follows:
\begin{itemize}

\item $\{X, Y, \dots\}$ is the set of {\it variables} defined by the
SARE.  Variables can be considered as multi-dimensional arrays mapping
a vector of indices ${\vec i}$ to a value in some space ${\cal V}$.

\item ${\cal D_{\cal E}}$ is a polyhedron representing the {\it
domain} of the equation ${\cal E}$.  Each equation for a variable $X$
has a disjoint domain; the domain $D_X$ for variable $X$ is taken as
the convex union of all domains over which $X$ is defined.

\item ${\vec h}_{{\cal E}, Y}$ is a vector-valued affine\footnote{If
the dependence function ${\vec h}$ is a translation (${\vec h}({\vec
i}) = {\vec i} - {\vec k}$ for constant ${\vec k}$), then the SARE is
{\it uniform}, and referred to as a SURE or SRE~\cite{karp67}.}
function, giving the index of variable $Y$ that $X({\vec i})$ depends
on.  A vector-valued function ${\vec h}$ is affine if it can be
written as ${\vec h}({\vec i}) = C{\vec i} + {\vec d}$, where C is a
constant array and ${\vec d}$ is a constant vector that do not vary
with ${\vec i}$.

\item $f_{\cal E}$ is a strict function used to compute the elements
of $X$.

\end{itemize}

In the above definition, note that the index expression ${\vec i}$ on
the left hand side must exactly match the input domain quantifier.
Also, each index expression on the right-hand side must be an affine
expresion of ${\vec i}$.  A SARE has no notion of internal state per
se; however, state can be modeled by introducing a self-loop in the
graph of variables.

SARE's became interesting from the standpoint of program analysis upon
Feautrier's discovery~\cite{Feautrier92i,Feautrier92ii} that a SARE is
mathematically equivalent to a ``static control flow program''.  A
program has static control flow if the entire path of control can be
determined at compile time (see~\cite{Feautrier92i,FV00} for details).
Feautrier showed that using a SARE, one can use linear programming to
produce a {\it parameterized} schedule for a program.  That is, if a
loop bound is unknown at compile time, then the symbolic bound enters
the schedule and it does not affect the complexity of the technique.
Feautrier's framework is very flexible in that it allows you to select
a desirable affine schedule by any linear heuristic.

Lim and Lam~\cite{Lim01} build on Feautrier's technique with an affine
partitioning algorithm that maximizes the degree of parallilism while
minimizing the degree of synchronization.  It also operates on a form
that is equivalent to a SARE.
