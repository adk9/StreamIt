questions for saman:

1. would it be ok to pipeline the procedural code?  it makes it look
much prettier, but why would you want the blocked structure (display?)

2. should the object-oriented code reuse the arrays in the function
calls so it's not blatently wasting memory?

------------------------------------------------------------------------

int N = 5;
int M = 7;

void main() {

   float data[] = new float[N+M];
   int pos;

   for (int pos=0; pos<N; pos++) {
      data[pos] = getData();
   }

   while (true) {
      pos = (pos+1)\%N;

      float sum = 0;
      for (int i=0; i<N; i++) {
         sum = data[(i+pos)\%N]*FIR_COEFF[j][N];
      }

      display(sum);

      data[pos] = getData();
   }
}

------------------------------------------------------------------------
add these semantic restrictions:

1. round-robin split/join must be non-null
2. must have static rates in work function (compiler-detectable)

------------------------------------------------------------------------
add these java restrictions:

- no class libraries except for:
	1. String
	2. 

- no aliasing allowed.  what does this mean?

------------------------------------------------------------------------
from meeting w/ saman

- emphasize in title or abstract that this is for static rates

- make it more clear in words what the semantics are of message
sending, etc.

- make an example that makes use of portals for portal's sake
	1. library notion (unknown receiver / sender)
	2. broadcast messaging
	3. send up and down the stream

	-> like an example w/ completely messaging stuff
	- very simple & artificial

- think about processor simulator?

- messaging first (in this doc), then re-initialization

- add to intro:  timing emphasis

------------------------------------------------------------------------
from Saman's emails

- One thing we did not do is list current limitations we may fix soon
such as rate changing filters, a type dispatch splitter, any joiner,
etc. etc. Current class can be named something lime "static rates" and
some of these extensions as "dynamic rates". Your java class diagram
should go in too.

- Figure 4, two set splitters, second should be a joiner...

- Section 3.2.1 should refer to figure 11.

- In Figure 7 don't put all the code of TrunkedRadio, also put parts of code
from Booster and Check Quality to show message delivery. (Copy the class,
eliminate extraneous stuff and put dots)

- IN 3.3.2 having a messaging system reduces the number of channels since only
high bandwidth comm. need a channel, making most programs easier to fit into
a structured streaming model.

- 3.4.1 Justify reinitializatoin by need to change a part of the stream graph.

Another meta point.
Because of messaging and reinitilization we can integrate control part with
the data part. Most other stream programs need a separate control program.
(eg: Chapin's software radio)

- It would be nice to add a example with reinitialization and draining....

- Adhoc reinitialization can easily loose data or deadlock the system.

- Need to note somewhere that sending a message does not affect the info
wavefront. I.e. can go "back to the future" using messages.

- Just before 4.1.1 The formalism is not only used for define messaging and
latency but also to prove program correctness (deadlock etc.)

- 4.1.1 Where is min?

- Why are some equn's numbered?

- List of equ'n should be aligned at =

- 4.1.3 Should we do a general weighted-round-robin??

- Figure 10 has J and S not FJ and FS is that consistent??

- 4.2.3 We can do something cool on for scheduling, we can bound the
total number of buffer space!  Find the number of items that must be
on a tape, sum them up, and say it has to be less than MAXBUFFERSIZE

- 4.3 Wrong formatting for I1FJ in the 3rd para.

- We should say something in intro/abstract about how easy for us to
prove/show deadlock freedom etc.

- Section 6 needs a description about the TrunkedRadio (how about the
description I e-mailed to you yesterday?)

------------------------------------------------------------------------
Big things to think about

0. realtime constraints

2. message sending syntax
3. letting init codes cause an offset (do push() on output)
4. verifying round-robin's are legal by having same rate on both sides

5. semantics for weighted round-robin / duplicates?  or proof of
simulation by a single round-robin.

6. if a stream sends or receives a message, is the wavefront relative
to the output or input?

7. exact semantics of initialization when combining with tapes/messaging.

8. define exactly the w-behavior if you're sending messages or adding
constraints between disjoint pieces

9. add a pre-made reordering filter?

------------------------------------------------------------------------
Future things to think about

1. any notion of exceptions?  error handling?

2. any concept of filters ignoring items?  would affect wavefront (a
select filter, for example.)

------------------------------------------------------------------------
Things to write about

2. drain/destroy initialization semantics
3. feedback loop initialization
4. portals - let's just adopt templated java lists for the sake of presentation
5. exact restrictions on java?
6. semantic restrictions of streamit

7. the scripting component - having a pipeline of n blocks at runtime
isn't supported in all langs.

8. diagram with class hierarchy?

9. reorganize the derivations of min/max so that stuff leaving the
split/join and stuff entering the split/join is together?  then the
similar equaionts are placed next to each other.

10. improve writing of feedbackloop section.

11. talk to saman about changing example FIR so that it
pushes(peek(i)); pop(); instead of pushing the dummy values.

13. make latency symbol consistent - l or n?  

14. introduce n(t) notation earlier.

15. change messaging semantics so it's clear what happens in the case
of a portal.

16. improve timing by defining upstream and downstream somewhere near
the top.

17. how do they declare how many they push and pop?

19. put a split/join in the radio example -- looks better and makes more sense

21. somewhere in semantics, say what we don't do

22. some name other than TIME interval for the message sending!

** put the feedbackloop joiner transfer functions as a composition of
some other joiner function so that I can still use duplicate, etc there.

** add some latency constraints to the example

- get rid of caching in some of the examples?

- make it clear that latency constraints with a portal apply to all
elements of the portal




