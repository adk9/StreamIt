- write appendix

- rewrite everything that saman wrote (related, example, conclusions)

* define latency for things other than filters.  same with messages!
	- will need concept of first/last filters in a stream, which
		could get complicated
	- ability to send to other targets?

- make an example that makes use of portals for portal's sake
	1. library notion (unknown receiver / sender)
	2. broadcast messaging
	3. send up and down the stream

	-> like an example w/ completely messaging stuff
	- very simple & artificial

	- also have re-initialization an draining in some example?

- expand the messaging diagram into a nice picture with the source,
destination, portal, and connecting code.  (do this in windows!)

todo later this afternoon
-------------------------

- should this be manuscript format instead of two-column?

- add the Tech Report #

questions for saman
-------------------

* order of evaluation of input.pop() in statements that contain more
than 1?  I modified your function to input on different lines.  If we
can have clean semantics, then let's change it back... but I think
this is a mess we don't want to get into.  In fact, let's disallow
it.  (Although we could detect commutativity, maybe...)

* checkFreqHop had a messed up for loop, right?  changed to 1-5, ==2, ==4

* should checkQuality be in the freq domain?  We really want a booster
if the frequency spectrum is even?  But we said that we expect low
values at the hop positions for the hopping... maybe they shouldn't
output anything at the hop positions?

* I'm going to let the init function push and pop, ok?  We still have
to give semantics.

* should there be a semantic restriction that you can't send messages
ahead of the wavefront?  I guess not.  But we could.

- how do you center the components of an equation?

-> can you please switch J to FJ and S to FS on feedback.eps?

-> note: I'm using semantics of add so that it returns what it adds.
this leads to a nicer syntax.

changes we decided against making?
----------------------------------

- put a splitJoin at the end of the TrunkedRadio example, since it
makes more sense that way.

- some name other than TIME interval for the message sending!

- reorganize the derivations of min/max so that stuff leaving the
split/join and stuff entering the split/join is together?  then the
similar equaionts are placed next to each other.

- number all equations?

future things to think about
----------------------------

* a quasi-problem with the operational semantics is that it doesn't
indicate when the splits and joins execute (it assumes they execute
immediately), which might give us less scheduling control than we'd
like.

* realtime constraints.  can we say a filter fires once per time interval?

* work out the semantics of the w-message sending (disjoint pieces)

* letting init codes cause an offset (do push() on output)

* exact tape-based semantics of reinitializatin

* semantic restrictions of sending a message within a message handler.
Need to start counting work functions in a different way.

- any notion of exceptions?  error handling?

- any concept of filters ignoring items?  would affect wavefront (a
select filter, for example.)

- I still vote for a reordering filter that lets you reorder chunks
without a complicated round-robin with identitity functions.

