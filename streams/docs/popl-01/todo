- rewrite example & conclusions

- fix the class hierarchy figure

- get the trunked radio to fit on one page

- more organized future work section?

- add to java/streamit restrictions in appendix

- layout
	- early oo/proc figures have bad layout
	- the rows of array for inference rule are too close together

- add the Tech Report #

changes we decided against making?
----------------------------------

- put a splitJoin at the end of the TrunkedRadio example, since it
makes more sense that way.

- some name other than TIME interval for the message sending!

- reorganize the derivations of min/max so that stuff leaving the
split/join and stuff entering the split/join is together?  then the
similar equaionts are placed next to each other.

- number all equations?

future things to think about
----------------------------

- make an example that makes use of portals for portal's sake
	1. library notion (unknown receiver / sender)
	2. broadcast messaging
	3. send up and down the stream

	-> like an example w/ completely messaging stuff
	- very simple & artificial

	- also have re-initialization an draining in some example?

* get the centering right on the inference rule instead of using \hspace

* to properly deal with messages to streams with null splits & joins,
do we need to define the min/max functions across null splits & joins?
how do you send message to stream (like you'd want to for
re-initialization) if there's no unique upper or lower filter?

* we need to specify default values for functions like drain(),
initPath, etc

* a quasi-problem with the operational semantics is that it doesn't
indicate when the splits and joins execute (it assumes they execute
immediately), which might give us less scheduling control than we'd
like.

* realtime constraints.  can we say a filter fires once per time interval?

* work out the semantics of the w-message sending (disjoint pieces)

* letting init codes cause an offset (do push() on output)

* exact tape-based semantics of reinitialization

* semantic restrictions of sending a message within a message handler.
Need to start counting work functions in a different way.

- any notion of exceptions?  error handling?

- any concept of filters ignoring items?  would affect wavefront (a
select filter, for example.)

- I still vote for a reordering filter that lets you reorder chunks
without a complicated round-robin with identitity functions.






