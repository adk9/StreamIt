\clearpage

\newcommand{\doc}[1]{{\bf {\tt #1}} \vspace{3pt} \\}

\renewcommand{\theequation}{A-\arabic{equation}}
% redefine the command that creates the equation no.
\setcounter{equation}{0}  % reset counter 
\setcounter{section}{0}

\begin{center}
{\bf APPENDIX:  Details on Java Syntax}
\end{center}

\section{Java Classes}

\begin{figure}
\centering
\psfig{figure=hierarchy.eps,width=2.0in}
\caption{\protect\small The StreaMIT class hierarchy.
\protect\label{fig:hierarchy}}
\end{figure}

A diagram of the Java class hierarchy for StreaMIT is shown in
Figure~\ref{fig:hierarchy}.  A summary of the methods in each class is
as follows.

\subsection{Operator}

The {\tt Operator} is the basic building block in the stream graph,
mapping one or more input channels to one or more output channels.

\subsubsection{Fields}

\doc{TimeInterval BEST\_EFFORT}  This pre-defined time interval
indicates that a message should be delivered on a ``best-effort''
basis, without strict timing guarantees.

\subsubsection{Methods}

\doc{MAX\_LATENCY(Stream a, Stream b, int n)}  This directive
constraints the schedule such that, at any given time, $a$ can only
progress up to the wavefront of information that $b$ will see after
$n$ invocations of its own work function.

\doc{Stream Identity()} This returns a {\tt Stream} that outputs
exactly the items that it inputs.

\subsection{Stream}

The {\tt Stream} represents a portion of the stream graph that inputs
has exactly one input channel and exactly one output channel.

\subsubsection{Methods}

\doc{void init(user-defined arguments)}  The {\tt init} function is
called automatically when the stream is first instantiated, and can be
called again with a message at runtime to trigger a re-initialization
of this stream.  The purpose of the {\tt init} function is to
initialize child streams and to set parameters used with this stream.

\doc{Stream add(Stream child)}  The {\tt add} function appends {\tt
child} to the current pipeline of blocks comprising this stream and
returns {\tt child}.  It can only be called from within the {\tt init}
function.

\doc{void run()} - The {\tt run} function provides an outside
interface for starting the stream.  No component of any stream may
call {\tt run}.

\subsection{Filter}

The {\tt Filter} is the most basic kind of stream.  It contains no
child streams, and thus calling {\tt add} is forbidden from within its
{\tt init} function.  Instead, the {\tt Filter} defines a {\tt work}
function that explicitly describes the transfer of input items to
output items.  A filter has some input and output type, hereafter
referred to as <input-type> and <output-type>, respectively.

\subsubsection{Fields} 

\doc{Channel input}
\doc{Channel output}
These input and output channels must be the first two fields declared
in the class.  At the line of their declaration, they should be
initialized to be a new {\tt <input-type>Channel} and {\tt
<output-type>Channel}, respectively.  These {\tt Channel} types will
be auto-generated.

\subsubsection{Methods}

\doc{void work()}  The {\tt work} function represents the most
fine-grained execution step of the filter.  It can read from the input
channel, write to the output channel, modify the state of the filter,
and send messages.

\doc{<input-type> drain(int index)}  The {\tt drain} function
specifies what values should be output from this filter if it lies on
the boundary of a region that is being re-initialized.  For the
information in the re-initialized region to drain out, downstream
filters will need to input data from the upstream edge of the region.
However, we do not want to pull fresh information from outside of the
region into the drain, so the {\tt drain} function is invoked instead
to fabricate data.  The {\tt drain} function is successively called
with indices 0, 1, 2, $\dots$ until the downstream region has drained.

\subsection{Splitter}

A {\tt Splitter} has one input channel and more than one output
channel.  For now, the user cannot define splitters; instead, there
are a series of compiler-defined splitters.

\subsubsection{Fields}

\doc{RoundRobin} etc etc

\subsection{Joiner}

A {\tt Joiner} has one output channel and more than one input channel.
For now, the user cannot define joiners; instead, there are a series
of compiler-defined joiners.

\subsubsection{Fields}

\doc{RoundRobin} etc etc

\subsection{SplitJoin}

A {\tt SplitJoin} is a set of independent, parallel streams that are
contained between a {\tt Splitter} and {\tt Joiner}.

\doc{Splitter setSplitter(Splitter splitter)}  This command sets the splitter within a {\tt SplitJoin} and returns its argument.  It must be called in the {\tt init} function of the {\tt SplitJoin}.

\doc{Joiner setJoiner(Joiner joiner)} This command sets the joiner within a {\tt SplitJoin} and returns its argument.  It must be called in the {\tt init} function of the {\tt SplitJoin}.

\doc{Stream add(Stream child)} This {\tt add} function overrides the {\tt add} function of {\tt Stream} to append {\tt child} as a parallel component within the {\tt SplitJoin.}  The first stream to be added is connected to the first port of the splitter and joiner, and likewise with the rest of the streams.  This function returns its argument.

\subsection{FeedbackLoop}

The FeedbackLoop provides the means for creating cycles in the stream
graph.

\subsubsection{Methods}

\doc{Joiner setJoiner(Joiner joiner)}
\doc{Stream setBody(Stream stream)}
\doc{Splitter setSplitter(Splitter splitter)}
\doc{Stream setLoop(Stream stream)}

These methods set the joiner, body stream, splitter, and loop stream for the feedback loop; they each return their argument.  Each of them must be called from within the {\init} function.

\doc{<varying type> initPath(int index)}  The {\tt initPath} function provides inputs to the joiner at the head of the feedback loop during the initialization period when there are no items on the channels around the loop.  The function is called with the number of the item that is being requested, starting from 0.

\doc{void setDelay(int delay)}  The {\tt setDelay} function specifies how many times the {\tt initPath} function is invoked before the joiner starts drawing input items from the feedback channel.

\subsection{Channel}

Channels are of a given type {\tt <channel-type>}, and are
auto-generated classes.  Their full Java class name is {\tt
<channel-type>Channel}, e.g., {\tt IntChannel}.  They provide typed
FIFO queues communicating steady-state data between filters.

\subsubsection{Methods}

\doc{<type> pop()}  The {\tt pop} function removes the item from the end of the channel and returns it.

\doc{<type> peek(int index)}  The {\tt peek} function returns the value at {\tt index} slots from the end of the channel, where {\tt peek(0)} = {\tt pop()}.  Unlike {\tt pop}, {\tt peek} does not remove any items from the channel.

\doc{void push(<type> item)}  The {\tt push} function enqueues {\tt item} onto the front of the channel.

\subsection{Portal}

Portals provide a means for broadcast messaging within StreaMIT.  They
are of a given type {\tt <portal-type>}, and are auto-generated
classes.  Their full Java class name is {\tt <portal-type>Portal},
e.g., {\tt MyFilterPortal}.

\subsubsection{Methods}

\doc{void register(<portal-type> receiver)}  The {\tt register} method adds {\tt receiver} to this portal as an object that will be the target of all messages passed to the portal.

\doc{all void methods of by <portal-type>}  A portal automatically defines each of the void methods that is implemented by {\tt <portal-type>}.  Since these methods have no return value, their invocation can act as a message to the receiver object.  However, the signature of these methods is modified to accept an extra argument of type {\tt TimeInterval}, which specifies the timing of the message delivery.  When a method is called on the Portal, it is treated as a message and is forwarded to all registered receivers within the given time interval.

\subsection{TimeInterval}

The {\tt TimeInterval} class simply provides a wrapper for specifying
the upper and lower time limits for a message delivery.

\subsubsection{Methods}

Constructor (min-time, max-time)

Constructor (min-time, max-time)

\section{Semantic restrictions}

\subsection{StreaMIT restrictions}

\begin{enumerate}

\item feedback-loop split/join must be non-null

\item the number of outputs on a split and input on a join must match the number of parallel streams in a splitjoin.

\item the joiner and splitter on a feedback loop must have two inputs and outputs

\item must have static rates in work function (compiler-detectable)

\item must only call input.pop() once per statement.  otherwise it's
ambiguous what value is being referenced.  similarly, a peek() can't
appear in the same expression as a pop().

\item same for nested add statements

\item the types of connected filters must match

\item the messaging and latency constraints must be satisfyable

\item there must be no deadlock in feedback loops, or overflow in feedback loops or splitjoins

\end{enumerate}

\subsection{Java restrictions}

\begin{enumerate}

\item no class libraries except for:  String,

\item no aliasing allowed.  what does this mean?

\end{enumerate}



