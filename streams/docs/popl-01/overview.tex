\section{Language Overview}

\begin{figure*}
\centering
\psfig{figure=Radio.eps,width=5.2in}
\caption{A block diagram of a software radio.  A detailed
implementation in StreaMIT appears in the Appendix.}
\label{fig:radiodiagram}
\end{figure*}

StreaMIT includes stream-specific abstractions and representations
that are designed to improve programmer productivity for the domain of
programs described above.  In this paper, we present StreaMIT in legal
Java syntax for ease of presentation.  Though this syntax can express
the fundamental ideas of StreaMIT, in the longer term we plan to
develop a cleaner and more abstract syntax that is designed
specifically for stream programs.

In the Appendix we have included a detailed example of a software
radio implemented in StreaMIT; a block diagram of the system appears
in Figure \ref{fig:radiodiagram}.  In the following sections, we draw
on different components of this example to describe and justify the
major features of StreaMIT.

\subsection{Filters}

\begin{figure}
\scriptsize
\begin{verbatim}
class FIR extends Filter {
   Channel input = new ComplexChannel();
   Channel output = new ComplexChannel();           
   int N;

   void init(int N) {
      this.N = N;
   }

   void work() {
      Complex sum = 0;
      for (int i=0; i<N; i++) {
         sum += input.peek(i)*fir_coeff[i][N];
      }
      input.pop();
      output.push(sum);
   }
}
\end{verbatim}
\vspace{-12pt}
\caption{\protect\small A Finite Input Response (FIR) filter in StreaMIT.
\protect\label{fig:firfilter}}
\vspace{-12pt}
\end{figure}

\subsubsection{StreaMIT Approach}

The basic unit of computation in StreaMIT is the {\tt Filter}.  An
example of a Filter is the {\tt FIRFilter}, a component of our
software radio (see Figure \ref{fig:firfilter}).  Each {\tt Filter}
contains an {\tt init} function that is called at initialization time;
in this case, the {\tt FIRFilter} records {\tt N}, the number of items
it should filter at once.

The {\tt work} function describes the most fine grained execution step
fo the filter in the steady state.  Within the {\tt work} function,
the filter can communicate with neighboring blocks using the {\tt
input} and {\tt output} channels, which are typed FIFO queue's
declared as fields at the top of the class.  These high-volume
channels support the three intuitive operations: 1) {\tt pop} removes
an item from the end of the channel and returns its value, 2) {\tt
peek(i)} returns the value of the item $i$ spaces from the end of the
channel without removing it, and 3) {\tt push(v)} writes the value $v$
to the front of the channel.  For now, we require that the number of
items popped, peeked, and pushed by each filter is constant from one
invocation of the {\tt work} function to the next.

\subsubsection{Rationale}

This representation of a filter is an improvement over general-purpose
languages.  In a procedural language, the analog of a filter is a
block of statements in a complicated loop nest.  This representation
is unnatural for expressing the feedback and parallelism that is
inherent in streaming systems.  Also, there is no clear abstraction
barrier between one filter and another, and high-volume stream
processing is muddled with global variables and control flow.  The
loop nest must be re-arranged if the input or output ratios of a
filter changes, and scheduling optimizations further inhibit the
readability of the code.  In contrast, StreaMIT places the filter in
its own independent unit, making explicit the parallelism and
inter-filter communication while hiding the grungy details of
scheduling and optimization from the programmer.

One could also use an object-oriented language to implement a stream
abstraction.  This avoids some of the problems associated with a
procedural loop nest, but the programming model is again complicated
by efficiency concerns.  That is, a runtime library might exectute
filters according to a pull model, where a filter operates on a block
of data that it retrieves from the input channel.  The block size is
often optimized for the cache size of a given architecture, which
hampers portability.  Moreover, operating on large-grained blocks
obscures the fundamental fine-grained algorithm that is visible in a
StreaMIT filter.  Thus, the absence of a runtime model in favor of
automated scheduling and optimization again distinguishes StreaMIT.

\subsection{Connecting Filters}

\subsubsection{StreaMIT Approach}

\begin{figure}
\scriptsize
\begin{verbatim}
class FFT extends Stream {
   void init(int N) {
      add(new SplitJoin() {
         void init() {
            setSplitter(WEIGHTED_ROUND_ROBIN(N/2, N/2));
            for(int i=0; i<2; i++) 
               add(new SplitJoin() {
                  void init() {
                     round_robin();
                     add (new Identity());
                     add (new Identity());
                     weighted_round_robin(N/4, N/4);
               }});
            setJoiner(ROUND_ROBIN);
      }});
      for(int i=2; i<=N/2; i *= 2)
        add(new Butterfly(i, N));
}}
\end{verbatim}
\vspace{-12pt}
\caption{\protect\small A Fast Fourier Transform (FFT) in StreaMIT.
\protect\label{fig:fft}}
\vspace{-12pt}
\end{figure}

The basic construct for composing filters into a communicating network
is a {\tt Stream}.  The FFT in Figure \ref{fig:firfilter} is an
example of a {\tt Stream} that appears in our software radio.  Like a
{\tt Filter}, a {\tt Stream} has an {\tt init} function that is called
upon its instantiation.  However, there is no {\tt work} function, and
all input and output channels are implicit; instead, the stream
behaves as the sequential composition of filters that are specified
with successive calls to {\tt add} from within {\tt init}.  That is,
{\tt Stream} creates a single pipeline.

There are two other stream constructors besides {\tt Stream}: {\tt
SplitJoin} and {\tt FeedbackLoop}.  The former is used to specify
independent parallel streams that diverge from a common {\it splitter}
and merge into a common {\it joiner}.  There are three kinds of
splitters:
\begin{enumerate}
\item WEIGHTED\_ROUND\_ROBIN($i_1$, $i_2$, $\dots$, $i_k)$),
which sends the first $i_1$ data items to the first stream, the next
$i_2$ data items to the second stream, and so on.
\item ROUND\_ROBIN, which is just a weighted round robin where all
weights are 1.
\item DUPLICATE, which replicates each data item and sends a copy to each
parallel stream.
\item NULL, which means that all of the parallel components are
sources and there is no input to split.
\end{enumerate}
Similarly, there are three kinds of joiners: 
\begin{enumerate}
\item WEIGHTED\_ROUND\_ROBIN($i_1$, $i_2$, $\dots$, $i_k)$), which reads the
first $i_1$ data items from the first stream, the next $i_2$ data
items to the second stream, and so on
\item ROUND\_ROBIN, which is just a weighted round robin where all
weights are 1
\item COMBINE, which reads all from all the streams in parallel and
combines the results in a structure which is passed on.
\item NULL, which means that all of the parallel components are sinks
and there is no output to join together.
\end{enumerate}
The splitter and joiner type are specified with calls to {\tt
setSplitter} and {\tt setJoiner}, respectively (see Figure \ref{fig:fft}).

\begin{figure}
\scriptsize
\begin{verbatim}
class Fibonnacci extends FeedbackLoop {
   void init() {
      setDelay(2);
      setBody(new Filter() {
          Channel input = new IntChannel();
          Channel output = new IntChannel();
          void work() {
              output.push(input.peek(0)+input.peek(1));
              input.pop();
          }
      });
   }

   int initPath(int index) {
      return index;
   }
}
\end{verbatim}
\vspace{-12pt}
\caption{\protect\small A FeedbackLoop version of Fibonnacci.
\protect\label{fig:feed}}
\vspace{-12pt}
\end{figure}

The last control construct provides a way to create cycles in the
stream graph: the {\tt FeedbackLoop}.  It contains a body stream (set
with {\tt setBody}, a feedback stream (set with {\tt setLoop}), and
round robin splitters and joiners (see Figure \ref{fig:feed}).  The
feedback loop has a special semantics when the stream is first
starting to run.  Since there are no items on the feedback path at
first, the stream instead inputs items from an {\tt initPath} function
defined by the {\tt FeedbackLoop}; {\tt initPath} is called with the
number of the data item that is being fabricated (starting from 0).
With a call to {\tt setDelay} from within the {\tt init} function, the
user can specify how many items should be calculated with {\tt
initPath} before the joiner looks for data items from the feedback
channel.

Evident in all of these examples is another feature of the StreaMIT
syntax: {\it inlining}.  The definition of any stream or filter can be
inlined at the point of its instantiation, thereby preventing the
definition of many small classes that are used only once, and,
moreover, providing a syntax that reveals the hierarchical structure
of the streams from the indentation level of the code.  In our Java
syntax, we make use of anonymous classes for inlining \cite{java}.

\subsubsection{Rationale}

StreaMIT differs from other languages in that it imposes a
well-defined structure on the streams; all stream graphs are built out
of a hierarchical composition of Streams, SplitJoins, and
FeedbackLoops.  This is in contrast to other environments, which
generally regard a stream as a flat and arbitrary network of filters
that are connected by channels.  However, arbitrary graphs are very
hard for the compiler to analyze, and equally difficult for a
programmer to describe.  Most programmers either resort to
straight-line code that links one filter to another (thereby making it
very hard to visualize the stream graph), or using an ad-hoc graphical
programming environment that is awkward to use and admits no good
textual representation.

In contrast, StreaMIT is a clean textual representation
that--especially with inlined streams--makes it very easy to see the
shape of the computation from the indentation level of the code.  The
comparison of StreaMIT's structure with arbitrary stream graphs could
be likened to the difference between structured control flow and GOTO
statements.  Though sometimes the structure restricts the
expressiveness of the programmer, the gains in robustness,
readability, and compiler analysis are immense.

A final benefit of stream graph construction in StreaMIT is the
ability to do {\it scripting} to parameterize graphs.  For instance,
both the FFT stream in Figure \ref{fig:fft} inputs a parameter {\tt N}
and adjusts the number of butterfly stages appropriately.  This
further improves readability and decreases code size.

\subsection{Messages}

\subsection{Re-Initialization}

\subsection{Realtime Constraints}

\begin{verbatim}

---------------------------------------------------------------------------
- integrated support for infrequent, low-bandwidh messages
- others:
	- embed control messages in data stream
		- complicated, error-prone, unreadable code
		- hurts performance of steady state (if you have to 
			check if everything is message or data)
		- complicates compiler analysis
		- can't send messages upstream without explicit
			feedback loop
	- treat messages as synchronous method calls
		- but delays stream progress when method en route, 
			disrupting scheduling freedom of compiler, as
			well as efficiency when at time of call
		- usually there is no return value (it's a message!)
		- no good notion of ``when'' message arrives relative
			to sender
- us: 	- talk about PORTALS
	- support for asynchronous messages with timing relative to
		data items
	- (define the ``wavefront'' of a data item, and say that
		messages sent with range of times)
	- avoids problems of two above approaches (it's readable, out
		of the way of steady-state data, and out of way of compiler)
	- this RELATIVE time gives more freedom to compiler for
		scheduling blocks
	- absence of global time good for parallel programming

- syntax presented:  sendMessage, messageHandlers, messageStubs.
---------------------------------------------------------------------------
- integrated support for re-initialization sections of a stream
- others:	
	- ad-hoc halting of whole stream's data flow so that some
		restructuring can take place
		
		- complicated programming to interface between the time of
			reinitialization and starting/stopping the stream

- us:
	- re-invoke the original initialization routine with different 
		parameters.

		- talk about draining the pipeline.  the compiler
                  worries about doing the reinitialization at the
                  right time so that the re-initialized segment drains
                  completely.  but the re-init message is delivered
                  just like a message, and a warning is given if the
                  message delivery schedule does not encompass a clean
                  draining point.

		- (alternatively, could destroy the pipeline.)

		- so improvement #1 is that the interface to the user is 
			cleaner.  Also it's easier for the compiler to 
			analyze.

		- improvement #2: very clear targets of
			re-initiailization.  Can reinitialize any
			block in the hierarchy in a very well-defined
			way.

		- improvement #3 is that the draining analysis is done
                  automatically, which otherwise is very complicated
                  for the programmer to deal with.

- syntax presented:  special reset method

\end{verbatim}






