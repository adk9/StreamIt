\section{Timing Semantics}

In this section we develop a more formal semantics for the message
delivery guarantees described above.  The timing model in StreaMIT is
unique in that all time is relative to {\it information
wavefronts}--that is, two independent filters can describe a common time
only in terms of when the {\it effects} of one filter's execution are
seen by another.  Thus, although each filter's {\tt work} function is
invoked asynchronously without any notion of global time, two
invocations of a work function occur at the same ``information-relative
time'' if they operate on the same information wavefront.

To define this notion more precisely, we present transfer functions that
describe the flow of information across filters and streams.  Using
these transfer functions, we translate message delivery constraints into
a set of constraints on the execution schedule of the stream graph.
Finally, we use these scheduling constraints to formulate an operational
semantics for messaging, latency, and re-initialization in StreaMIT.

\subsection{Information Flow}

The concept of information flow is central to the streaming domain.
When an item enters a stream, it carries with it some new information.
As execution progresses, this information cascades through the stream,
effecting the state of filters and the values of new data items which
are produced.  We refer to an ``information wavefront'' as the
sequence of filter executions that first sees the effects of a given
input item.  This wavefront is well-defined even in the presence of
rate-changing filters that peek, pop, and push differing number of
items in each invocation of their work function. {\bf Unclear--makes
it sound like it changes from one invocation to the next?}

\begin{figure}[t]
\begin{verbatim}
Diagram of some filters connected by infinite tapes, marking the regions
that are were previously on the tape (but have been popped), the items
that are currently under consideration (for popping & peeking), and the
items that haven't shown up yet.  Similarly for pushing, somehow.  Maybe
show a cone collapsing a region of some input tape into the output tape,
labeling the regions.
\end{verbatim}
\vspace{-12pt}
\caption{\protect\small FIR / FFT Filters.}
\vspace{-12pt}
\end{figure}

To formalize the wavefront, we introduce some new representations for
the state of the stream graph.  Consider that in place of each data
channel there is an infinite ``tape'' which contains the history of
values that have been pushed onto the channel.  Now consider the
following functions:

\begin{itemize}

\item Given that there are $x$ items on tape $a$, the maximum number
of items that can appear on tape $b$ is $\ma{a}{b}(x)$.

\item Given that there are $x$ items on tape $b$, the minimum number
of items that must appear on tape $a$ is $\mi{a}{b}(x)$.

\end{itemize}

Note that these functions are only defined over pairs of tapes $(a,
b)$ where $a$ is ``upstream'' of $b$ in the stream graph, as will
become clear below.  We now turn to deriving expressions for
$\ma{a}{b}$ and $\mi{a}{b}$ as a step towards formalizing the
semantics of messaging, latency, and re-initialization.

\subsubsection{Filters}

Consider a filter $A$ that peeks $peek_A$, pops $pop_A$, and pushes
$push_A$ data items on every execution step.  Further, let us denote
the input and output tapes of $A$ by $I_A$ and $O_A$, respectively.
We now turn our attention to finding $\ma{I_A}{O_A}$ and
$\mi{I_A}{O_A}$, describing the transfer of information across the
filter $A$.

To derive $\ma{I_A}{O_A}(x)$, observe that the filter can execute so
long as it does not peek beyond the $x$'th item on the input tape,
$I_A$.  After the $n$'th execution, it has popped $n$ items, peeked up
to $n + (peek_A - pop_A)$, and popped $2 * n$ items.  Thus, it can
execute $n = floor((x - (peek_A - pop_A)) / pop_A))$ times, leaving
the following expression for $\ma{I_A}{O_A}(x)$
\begin{eqnarray*}
\ma{I_A}{O_A}(x)& \\ = push_A&*floor((x-(peek_A-pop_A))/pop_A) if x \ge (peek_A-pop_A) \\
         = push_A&*floor((x-(peek_A-pop_A))/pop_A) if x <  (peek_A-pop_A)
\end{eqnarray*}
Similarly, the reader can verify that:
\begin{eqnarray*}
\mi{I_A}{O_A}(x)&= ceil(x/push_A)*pop_A+(peek_A-pop_A)
\end{eqnarray*}

\subsubsection{Pipelines}

Let us now derive expressions for $min$ and $max$ in the case of
pipelined filters.  In the base case, consider that two filters are
connected, with the output of $A$ feeding the input of $B$.  We are
seeking $\ma{I_A}{O_B}(x)$: the maximum number of items that can
appear on tape $O_B$ given that there are $x$ items on tape $I_A$.
Observing that a maximum of $\ma{I_A}{O_A}(x)$ items can appear on
tape $O_A$, and that $O_A$ must equal $I_B$ since the filters are
connected, we see that a maximum of
$\ma{I_B}{O_B}(\ma{I_A}{O_A}(x))$ items can appear on $O_B$:
\begin{equation*}
\ma{I_A}{O_B} = \ma{I_B}{O_B} \circ \ma{I_A}{O_A}
\end{equation*}
In the case of $\mi{I_A}{O_B}(x)$, the order of composition is
reversed: given that there are $x$ items on tape $O_B$, a minimum of
$\mi{I_B}{O_B}(x)$ are on tape $I_B$, and since $O_B = I_A$, we have
that a minimum of $\mi{I_A}{O_A}(\mi{I_B}{O_B}(x))$ items appear on
$I_A$, leaving:
\begin{equation*}
\mi{I_A}{O_B} = \mi{I_A}{O_A} \circ \mi{I_B}{O_B}
\end{equation*}
By identical reasoning, these composition laws hold for pipelined
streams as well as filters.  That is, for any tapes $x$, $y$, and $z$
such that $\ma{x}{y}$, $\ma{y}{z}$, $\mi{x}{y}$, and $\mi{y}{z}$ are
well-defined, we have:
\begin{eqnarray*}
\ma{x}{z} = \ma{y}{z} \circ \ma{x}{y} \\
\mi{x}{z} = \mi{x}{y} \circ \mi{y}{z}
\end{eqnarray*}

\subsubsection{SplitJoins}
\begin{figure}[t]
\scriptsize
\begin{verbatim}
Here I want a splitjoin diagram, labelled as:

    B1 ... Bn 
  /           \
S               J
  \           /
    A1 ... An

\end{verbatim}
\vspace{-12pt}
\caption{\protect\small SplitJoin labeling.
\protect\label{splitjoin}}
\vspace{-12pt}
\end{figure}

We now derive $min$ and $max$ in the case of a SplitJoin, as pictured
in Figure {\ref:splitjoin}.  For the splitter $S$ there are two output
tapes; let us denote them by $O1_S$ and $O2_S$.  Similarly, let us
denote the two input tapes of the joiner $J$ by $I1_J$ and $I2_J$.  We
now derive the transfer functions for round robin and
duplicate/combine nodes.

{\bf Round robin splitter.}  In the case of a round-robin splitter, the
items from the input tape are alternately routed to the output tapes,
with the first item going onto tape $O1_S$.  By this definition, we
can see that the splitter's $max$ is defined as follows:
\begin{eqnarray*}
\ma{I_S}{O1_S}(x) = ceil(x/2) \\
\ma{I_S}{O2_S}(x) = floor(x/2)
\end{eqnarray*}
To derive the $min$ function across a splitter, observe that the input
tape need only progress so far as to produce the items on the emptier
output tape.  That is, we need to consider the number of items on both
of the splitter's output to determine the minimum number of items that
are needed at its input.  Thus, our $min$ function has two arguments:
the first corresponding to $O1_S$ and the second corresponding to
$O2_S$.  The equation is as follows:
\begin{eqnarray*}
\mi{I_S}{(O1_S, O2_S)}(x_1, x_2) = min(2*x_1-1, 2*x_2)
\end{eqnarray*}
{\bf Round robin joiner.}  The rules for a round robin joiner are in
some sense dual to those of the round robin splitter.  Again assuming
that items are alternately drawn from the input tapes, starting with
$I1_J$, we have that:
\begin{eqnarray*}
\mi{I1_J}{O_J}(x) = ceil(x/2) \\
\mi{I2_J}{O_J}(x) = floor(x/2) 
\end{eqnarray*}
Again, the $max$ function takes two arguments, corresponding to the
number of items on $I1_J$ and $I2_J$, respectively:
\begin{eqnarray*}
\ma{(I1_J, I2_J)}{O_J}(x_1, x_2) = max(2*x_1-1, 2*x_2)
\end{eqnarray*}
{\bf Duplicate splitter}.  Clearly, the $max$ function of a duplicate
splitter is simply the identity function, since it maps each element
on the input tape to the same location on the output tapes:
\begin{eqnarray*}
\ma{I_S}{O1_S}(x) = x \\
\ma{I_S}{O2_S}(x) = x
\begin{eqnarray*}
The $min$ function is similar, except that

{\bf Combine joiner.} The derivations for a duplicating
splitter and combining joiner are simply the identity function, since
each element on the input tape(s) is mapped to the same index position
on the output tape(s).  That is, in the case of duplicate/combine,
$\ma{I1_J}{O_J}(x) = \ma{I2_J}{O_J}(x) = \mi{I1_J}{O_J}(x) =
\mi{I2_J}{O_J}(x) = x$.

\begin{verbatim}

--------------------------------------------------------------------------

- Definition of wavefront stuff

- Scheduling Constraints
	- data flow
	- messaging

- Semantics of the functions
	- in terms of messages and latency

--

scheduling constraints:

- again let n_a denote the number of items on the OUTPUT tape of filter a

if have filters a and b in pipeline (a -> b), then these are equivalent:
	- n_b <= h_b(n_a)
	- n_a >= p_b(n_b)

if have splitjoin with input a, then (b, c) in parallel, and output d:
	- there are n_a on input
	- can have up to h(n_a) = (ceil(n_a/2), floor(n_a/2)) into (b, c)
	- can have up to (h_b(ceil(n_a/2)), h_c(floor(n_a/2))) out of (b, c)
	- can have up to min(2*h_b(ceil(n_a/2))-1,2*h_c(floor(n_a/2))) into d

	so constraint is that:
	- n_d <= h_d( min(2*h_b(ceil(n_a/2))-1,2*h_c(floor(n_a/2))) )

	or, in other words, h(x) for a split/join is:
		h(x) = min(2*h_b(ceil(n_a/2))-1,2*h_c(floor(n_a/2)))

if sending message from a to b with max wavefront latency n, then:
	
	1. if b is downstream, with filters x1, x2, x3 in between a and b:
			a -> x1 -> x2 -> x3 -> b

		n_b <= h_b(h_x3(h_x2(h_x1(n_a + n * a.push))))

	2. if b is upstream, with filters x1, x2, x3 between b and a:
			b -> x1 -> x2 -> x3 -> a

		n_b <= p_x3(p_x2(p_x1(p_a(n_a + n * a.push))))

	3. in the general case, a is sending message to b.  trace a
		path, finding y1, y2, y3 that are blocks between OUTPUT of
		a and OUTPUT of b.  a -> y1 -> y2 -> y3 -> b.  (note that
		if b is upstream, then y1 = a.)  Then we have:

		n_b <= z_y3(z_y2(z_y1(n_ a + n * a.push)))

		where z is replaced by h if we are traveling downstream, 
		but replaced by p if we are traveling upstream.

aha, if coming from common sender or going to common receiver, the wavefront
	must have EQUAL index at the sender or receiver.  so you REFLECT
	around split/join points instead of translating through them.
	because if you go up one part of join and down the other, the
	wavefront shifts

\end{verbatim}


