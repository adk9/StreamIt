\section{Timing Semantics}

In this section we develop a more formal semantics for the message
delivery guarantees described above.  The timing model in StreaMIT is
unique in that all time is relative to {\it information
wavefronts}--that is, two independent filters can describe a common time
only in terms of when the {\it effects} of one filter's execution are
seen by another.  Thus, although each filter's {\tt work} function is
invoked asynchronously without any notion of global time, two
invocations of a work function occur at the same ``information-relative
time'' if they operate on the same information wavefront.

To define this notion more precisely, we present transfer functions that
describe the flow of information across filters and streams.  Using
these transfer functions, we translate message delivery constraints into
a set of constraints on the execution schedule of the stream graph.
Finally, we use these scheduling constraints to formulate an operational
semantics for messaging, latency, and re-initialization in StreaMIT.

\subsection{Information Flow}

The concept of information flow is central to the streaming domain.
When an item enters a stream, it carries with it some new information.
As execution progresses, this information cascades through the stream,
effecting the state of filters and the values of new data items which
are produced.  We refer to an ``information wavefront'' as the sequence
of filter executions that first sees the effects of a given input item.
This wavefront is well-defined even in the presence of rate-changing
filters that peek, pop, and push differing number of items in each
invocation of their work function.

\begin{figure}[t]
\begin{verbatim}
Diagram of some filters connected by infinite tapes, marking the regions
that are were previously on the tape (but have been popped), the items
that are currently under consideration (for popping & peeking), and the
items that haven't shown up yet.  Similarly for pushing, somehow.  Maybe
show a cone collapsing a region of some input tape into the output tape,
labeling the regions.
\end{verbatim}
\vspace{-12pt}
\caption{\protect\small FIR / FFT Filters.}
\vspace{-12pt}
\end{figure}

To formalize the wavefront, we introduce some new representations for
the state of the stream graph.  Consider that in place of each data
channel there is an infinite ``tape'' which contains the history of
values that have been pushed onto the channel.  For a given filter $A$,
let $in_A$ and $out_A$ denote the number of items appearing on its input
and output tapes, respectively, during a point of the stream's
execution.  Now consider the following functions:

\begin{itemize}

\item Given that there are $x$ items on the input tape of filter $A$,
the maximum number of items on the output tape of filter $B$ is
$f_{AB}(x)$.  That is, $f_{AB}(x) = max(out_B | in_A = x)$.

\item Given that there are $x$ items on the output tape of filter $B$,
the minimum number of items on the input tape of filter $A$ is
$g_{AB}(x)$.  That is, $g_{AB}(x) = min(in_A | out_B = x)$.

\end{itemize}

We now derive $f_AB$ and $g_AB$ for certain pairs of nodes $(A, B)$ in
the stream graph.  Doing so will allow us to express the semantics of
messaging, latency, and re-initialization.

\subsubsection{Filters}

Consider a filter $A$ that peeks $peek_A$, pops $pop_A$, and pushes
$push_A$ data items on every execution step.  To derive $f_AA(x)$,
observe that the filter can execute so long as it does not peek beyond
the $x$'th item on the input tape.  After the $n$'th execution, it has
popped $n$ items, peeked up to $n + (peek_A - pop_A)$, and popped $2 *
n$ items.  Thus, it can execute $n = floor((x - (peek_A - pop_A)) /
pop_A))$ times, leaving the following expression for $f_{AA}(x)$:
\begin{eqnarray*}
f_{AA}(x)&= push_A*floor((x-(peek_A-pop_A))/pop_A) if x \ge (peek_A-pop_A) \\
         &= push_A*floor((x-(peek_A-pop_A))/pop_A) if x <  (peek_A-pop_A)
\end{eqnarray*}
Similarly, the reader can verify that:
\begin{eqnarray*}
g_{AA}(x)&= ceil(x/push_A)*pop_A+(peek_A-pop_A)
\end{eqnarray*}

\subsubsection{Pipelines}

Let us now derive expressions for $f$ and $g$ in the case of pipelined
filters.  In the base case, consider that two filters are connected,
with the output of $A$ feeding the input of $B$.  We are seeking
$f_{AB}(x)$, the maximum number of items that can appear on $out_B$
given that there are $x$ items on $in_A$.  Observing that a maximum of
$f_{AA}(x)$ items can appear on $out_A$, and that $out_A$ must equal
$in_B$ since the filters are connected, we see that a maximum of
$f_{BB}(f_{AA}(x))$ items can appear on $out_B$:
\begin{equation*}
f_{AB} = f_{BB} \circ f_{AA}
\end{equation*}
In the case of $g_{AB}(x)$, the order of composition is reversed:
given that there are $x$ items on $out_B$, a minimum of $g_{BB}(x)$
are on $in_B$, and since $out_B = in_A$, we have that a minimum of
$g_{AA}(g_{BB}(x))$ items appear on $in_A$, leaving:
\begin{equation*}
g_{AB} = g_{AA} \circ f_{BB}
\end{equation*}
By identical reasoning, these composition laws hold for pipelined
streams as well as filters.  That is, if filter $B$ is connected in a
pipeline to filter $C$, then for any filters $A$ and $B$ for which
$f_{AB}$, $f_{CD}$, $g_{AB}$, and $g_{CD}$ are well defined, we have that:
\begin{eqnarray*}
f_{AD} = f_{CD} \circ f_{AB} \\
g_{AD} = g_{AB} \circ g_{CD}
\end{eqnarray*}

\subsubsection{SplitJoins}

\begin{figure}[t]
\scriptsize
\begin{verbatim}
Here I want a splitjoin diagram, labelled as:

    B1 ... Bn 
  /           \
S               J
  \           /
    A1 ... An

but I want the splitter and joiner split up into 3 ports, that look
like differen filters but are grouped together into one.  This will
ease the semantic definitions.  Label the import port S0, the bottom
S1 and the top S2; same for joiner.  

\end{verbatim}
\vspace{-12pt}
\caption{\protect\small SplitJoin labeling.
\protect\label{splitjoin}}
\vspace{-12pt}
\end{figure}

We now derive $f$ and $g$ in the case of a SplitJoin, as pictured in
Figure {\ref:splitjoin}.  Since the splitter has two output tapes and
the joiner has two input tapes, we need to modify slightly our
definitions of $f$ and $g$:

\begin{itemize}

\item Given that there are $x$ items on the input tape of splitter
$S$, then $f_{SAB}(x)$ is a pair of values $(y_1, y_2)$ where $y_1$
and $y_2$ are the maximum number of items on the output tapes of $A$
and $B$, respectively.  That is, $f_{SAB}(x) = max( (out_A, out_B) |
in_S = x)$ where max operates component-wise.  Similarly, for a joiner
$J$, $g_{ABJ}(x) = min( (in_A, in_B) | out_J = x)$

\item Given that there are $(y_1, y_2)$ items on the output tapes of a
filters $A$ and $B$, respectively, then $g_{SAB}(y_1, y_2)$ is the
minimum number of items on the input tape of $S$.  That is,
$g_{SAB}(y_1, y_2) = min(in_S | out_A = y_1 \wedge out_B = y_2)$,
where min operates component-wise.  Similarly, for a joiner $J$,
$f_{ABJ}(y_1) = max( out_J | in_A = y_1 \wedge in_B = y_2)$.

\end{itemize}

{\bf Round robin.}  We first give derivations for round-robin
splitters and joiners.  At a round-robin splitter, items are
alternately dispatched to two different filters.  We define
$f_{SSS}(x)$ 

\begin{verbatim}

--------------------------------------------------------------------------

- Definition of wavefront stuff

- Scheduling Constraints
	- data flow
	- messaging

- Semantics of the functions
	- in terms of messages and latency

let's try some new definitions:

given that there are exactly x items on your input tape, the maximum
number of items you can have on your output tape is h(x)

the inverse is now well-defined: given that there are exactly x items
on your output tape, the minimum number of items you need on your
input tape is p(x)

filter:		h(x) = push*max(0, floor((x-(peek-pop))/pop))
split:		h(x) = (ceil(x/2), floor(x/2))
join:		h(x1, x2) = min(2*x1-1, 2*x2)

filter:		p(x) = ceil(x/push)*pop+(peek-pop)
split:		p(x1, x2) = min(2*x1-1, 2*x2)
join:		p(x) = (ceil(x/2), floor(x/2))

--

scheduling constraints:

- again let n_a denote the number of items on the OUTPUT tape of filter a

if have filters a and b in pipeline (a -> b), then these are equivalent:
	- n_b <= h_b(n_a)
	- n_a >= p_b(n_b)

if have splitjoin with input a, then (b, c) in parallel, and output d:
	- there are n_a on input
	- can have up to h(n_a) = (ceil(n_a/2), floor(n_a/2)) into (b, c)
	- can have up to (h_b(ceil(n_a/2)), h_c(floor(n_a/2))) out of (b, c)
	- can have up to min(2*h_b(ceil(n_a/2))-1,2*h_c(floor(n_a/2))) into d

	so constraint is that:
	- n_d <= h_d( min(2*h_b(ceil(n_a/2))-1,2*h_c(floor(n_a/2))) )

	or, in other words, h(x) for a split/join is:
		h(x) = min(2*h_b(ceil(n_a/2))-1,2*h_c(floor(n_a/2)))

if sending message from a to b with max wavefront latency n, then:
	
	1. if b is downstream, with filters x1, x2, x3 in between a and b:
			a -> x1 -> x2 -> x3 -> b

		n_b <= h_b(h_x3(h_x2(h_x1(n_a + n * a.push))))

	2. if b is upstream, with filters x1, x2, x3 between b and a:
			b -> x1 -> x2 -> x3 -> a

		n_b <= p_x3(p_x2(p_x1(p_a(n_a + n * a.push))))

	3. in the general case, a is sending message to b.  trace a
		path, finding y1, y2, y3 that are blocks between OUTPUT of
		a and OUTPUT of b.  a -> y1 -> y2 -> y3 -> b.  (note that
		if b is upstream, then y1 = a.)  Then we have:

		n_b <= z_y3(z_y2(z_y1(n_ a + n * a.push)))

		where z is replaced by h if we are traveling downstream, 
		but replaced by p if we are traveling upstream.

aha, if coming from common sender or going to common receiver, the wavefront
	must have EQUAL index at the sender or receiver.  so you REFLECT
	around split/join points instead of translating through them.
	because if you go up one part of join and down the other, the
	wavefront shifts

\end{verbatim}


