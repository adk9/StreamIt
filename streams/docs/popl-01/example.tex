\section{Detailed Example}
This section describes the Trunked Radio example implementation in
Figure~\ref{fig:radiocode}. The code for the trunked radio demonstrate
many features of StreaMIT.

The high-level structure of the radio, graphically shown in
Figure~\ref{fig:radiodiagram}, is implemented in the class {\tt
TrunkedRadio}. It has 7 stages, where the first three stages operate
in the time domain and the last three stages on the frequency domain.
At this high level, the strcuture of the system is a pipeline of six
or seven stream stages. The difference is due to the {\tt Booster}
stage, which can be active or inactive. The switching on and off of
the {\tt Booster} stage, which happens infrequently, is accomplished
using a message from the {\tt CheckQuality} stage. We also use another
message, from the {\tt CheckFreqHop} stage to {\tt RFtoIF} stage to
change the baseband when a frequency hop tone is present.

In the implementation we will omit the first and the last stages, {\tt
ReadFromAtoD} and {\tt AudioBackEnd}. 

The {\tt RFtoIF} stage modulates the input signal from RF to a
frequency band around the current IF frequency. This stage is
implented as a filter, which multiplies the current signal with the
relevent component of a sine wave at the IF frequency. Since frequency
hopping can change the IF frequency, we have created a method {\tt
set\_freq} in the filter, which will be invoked using a message.

The optional {\tt Booster} stage will be activated when the signal is
hard to detect. However, to conserve power, it will get deactivated
during normal operation. The booster is a FIR filter, implemented
using a Filter. The turning on and off the filter is implemented using
a Stream. When the Stream is reset, the control-flow of the init
function will decide to or not to add the FIR filter.  The FIR filter,
shown in Figure~\ref{fig:firfilter}, is implemented using peek
to look at N elements.

The {\tt FFT} stage converts the program from the time domain to the
frequency domain using a multi-stage FFT. The FFT algorithm
implemented is graphically presented in~\ref{fig:fftfilter}. The FFT
is composed of a reordering filter and a multi-stage butterfly
filters. The StreaMIT representation of the reordering filter (a bit
reverse order filter) is given in
Figure~\ref{fig:bitreverseorder}. Note that the complex data
reshuffling is accomplished using few splitjoin constructs.  A
parameterized Butterfly implementation is used to abstract the
multi-stage butterfly in the FFT. As shown in
Figure~\ref{fig:butterfly}, the Butterfly filter is also implemented
using a combination of splitjoin constructs. 

StreaMIT implementation of the FFT filter is clean and intutive. It
already has a large amount of pipelined parallelism. Due to the simple
and straighforward mapping from the algorithm to implementation,
compiler analyses should be able to extract the parallel structure of
the FFT when hardware resources are available.

The next stage, {\tt CheckFreqHop}, checks four different frequencies
for the change frequency tone. When this tone is detected, the
frequency has to be changed within a time limit. Thus, a message is
send to the {\tt RFtoIF} stage requiring it to be delivered such that 
CheckFreqHop should receive at lest 4N and not more than 6N items
using the old modulation.

The {\tt CheckQuality} stage checks if the signal has a distinct
frequency spectrum. If all the frequencies has similar amplitute, it
assumes that the signal to noice ratio is low and send a message to
activate the {\tt Booster}. Note that this message is send using best
effort delivary.



\begin{figure}
\centering
\psfig{figure=fft-block.eps,width=3.2in}
\caption{The multi-stage FFT algorithm}
\label{fig:fftfilter}
\end{figure}

\begin{figure*}
\centering
\psfig{figure=fft-pre-tape.eps,width=4.8in}
\caption{The bit reverse order filter in FFT. The tapes at each
channel illustrates the data reshuffling when N=8. }
\label{fig:bitreverseorder}
\end{figure*}

\begin{figure*}
\centering
\psfig{figure=fft-butterfly-tape.eps,width=5.8in}
\caption{A 4x4 butterfly stage in the FFT. The tapes at each channel illusrates the data transformation and computation. }
\label{fig:butterfly}
\end{figure*}

\begin{figure}
\centering
\psfig{figure=fir-block.eps,width=3.2in}
\caption{A block diagram of a five tap FIR filter.}
\label{fig:firfilter}
\end{figure}



\newpage

\begin{figure}[t]
\scriptsize
\begin{verbatim}
class Butterfly extends Stream {
   void init(int N, int W) {
      add(new SplitJoin() {
         void init() {
            weighted_round_robin(N, N);
            add (new Identity());
            add (new Filter() {
               Float weights[W];
               int curr;
               Channel input = new FloatChannel();
               Channel output = new FloatChannel();
               void init() {
                  for(int i=0; i<W; i++)
                     weights[i] = calc_weight(i, N, W);
                  curr = 0;
               }
               void work() {
                  output.push(input.pop()*weights[curr++]);
                  if(curr>= W) curr = 0;
               }    
            });
            round_robin();
      }});
      add(new SplitJoin() {
         void init() {
            duplicate();
            add (new Filter() {   
               Channel input = new FloatChannel();
               Channel output = new FloatChannel();
               void work() {
                  output.push(input.pop() + input.pop());
               }
            });
            add (new Filter() {   
               Channel input = new FloatChannel();
               Channel output = new FloatChannel();
               void work() {
                  output.push(input.pop() - input.pop());
               }
            });
            weighted_round_robin(N, N);
      }});
}}

class FFT extends Stream {
   void init(int N) {
      add(new SplitJoin() {
         void init() {
            weighted_round_robin(N/2, N/2);
            for(int i=0; i<2; i++) 
               add(new SplitJoin() {
                  void init() {
                     round_robin();
                     add (new Identity());
                     add (new Identity());
                     weighted_round_robin(N/4, N/4);
               }});
            round_robin();
      }});
      for(int i=2; i<=N/2; i *= 2)
        add(new Butterfly(i, N));
}}

class FIR extends Filter {
   Channel input = new FloatChannel();
   Channel output = new FloatChannel();           
   int N;

   void init(int N) {
      this.N = N;
   }

   void work() {
      Float sum = 0;
      for (int i=0; i<N; i++) {
         sum += input.peek(i)*fir_coeff[i][N];
      }
      input.pop();
      output.push(sum);
   }
}
\end{verbatim}
\vspace{-12pt}
\caption{\protect\small The StreaMIT program for the Trunked Radio Receiver.
\protect\label{fig:radiocode}}
\vspace{-12pt}
\end{figure}

\begin{figure}[t]
\scriptsize
\begin{verbatim}
class RFtoIF extends Filter {
   Channel input = new FloatChannel();
   Channel output = new FloatChannel();
   int sz, i;
   Float weight[];
   void init(Float f) {
      set_freq(f);
   }
   void work() {
      output.push(input.pop()*weight[i++]);
      if(i==sz) i = 0;
   }
   void set_freq(Float f) {
      i = 0;
      sz = CarrierFreq/f*N;
      weight = new Float[sz];
      for(int i=0; i<sz; i++)
         weight[i] = sine(i*pi/sz);
   }
}

class CheckFreqHop extends SplitJoin {
   RFtoIFPortal freq_hop;
   void init(RFtoIFPortal fh) {
      freq_hop = fh;
      weighted_round_robin(N/4-2,1,1,N/2,1,1,N/4-2);
      int k = 0;
      for(int i=0; i<4; i++) {
         if((i==0)||(i==2)) {
            for(int j=0; j<2; j++) {
               add(new Filter() {
                  Channel input = new FloatChannel();
                  Channel output = new FloatChannel();
                  void work() {
                     Float val = input.pop();
                     if(val >= MIN_TRASHOLD) 
                        freq_hop.set_freq(Freq[k], new TimeInterval(4*N, 6*N)); 
                     output.push(val);
                  }
               });
               k++;
            }
         } else add(new Identity());
      }
      weighted_round_robin(N/4-2,1,1,N/2,1,1,N/4-2);
   }
}

class CheckQuality extends Filter {
   Channel input = new FloatChannel();
   Channel output = new FloatChannel();
   Float ave_hi, ave_lo;   
   BoosterPortal on_off_switch;
   void init(BoosterPortal on_off) {
      ave_hi = 0;
      ave_lo = 0;
      on_off_switch = on_off;
   }
   void work() {
      Float val = input.pop();
      ave_hi = max(0.9*ave_hi, val);
      ave_lo = min(1.1*ave_lo, val);
      if(ave_hi - ave_lo < QUAL_BAD_TRASHOLD)
         on_off_switch.init(true);
      if(ave_hi - ave_lo > QUAL_GOOD_TRASHOLD)
         on_off_switch.init(false);
      output.push(val);
   }
}

class Booster extends Stream {
   void init(boolean adds) {
      if(adds) add(new FIR(N));
   }
}

class TrunkedRadio extends Stream {
   RFtoIFPortal freq_hop = new RFtoIFPortal();
   BoosterPortal onoff = new BoosterPortal().
   void init() {
      add(new ReadFromAtoD());
      RFtoIF RF2IF = new RFtoIF();
      add(RF2IF);
      freq_hop.register(RF2IF);
      Booster ISS = new Booster();
      add(ISS);
      onoff.register(ISS);
      add(new FFT());
      add(new CheckFreqHop(freq_hop));
      add(new CheckQuality(onoff));
      add(new AudioBackEnd());
   }
}

\end{verbatim}
\vspace{-12pt}
\caption{\protect\small Example stuff.
\protect\label{fig1}}
\vspace{-12pt}
\end{figure}
