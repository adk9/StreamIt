\documentclass[draft]{article}
\usepackage{psfig, verbatim, fullpage}
\title{The StreaMIT Programming Language \\ A Reference Manual \\ Version 0.0.2}

\begin{document}
\maketitle

\section{Open questions}

\begin{enumerate}

\item What are the semantics of re-initialization of filter blocks?
What do we do about flushing pipelines, etc?

\item If we're building on top of C, then how do we pass a string
between filters without using pointers?  What is the exact restriction
on pointers, then?

\item More generally than above, what's the syntax of stuff that's not
streaming?  Is it C, Java, something subset or combination thereof?

\item Do we want the message delivery units to be in terms of the {\it
receiever's} work function?  It seems like that might make more sense
to the programmer (?)

\item Why don't we change messages to be arbitrary point-to-point
function calls?  Then the names could be more descriptive than {\tt
handleMessage}, and multiple parameters could be passed instead of
having to pack and unpack a user-defined structure.  (Also, just
dispatching method calls on the type of structure could be
confusing--for instance, if two different senders want to send the
same type of data to different targets within a filter block.)

\end{enumerate}

\section{Realizations / Changes}

\begin{enumerate}

\item When we're inlining filters, we don't need to provide the name
of the filter.

\item It's a misnomer to call the toplevel stream a {\tt FilterBlock},
since it has no input and output.  Let's call it a {\tt Stream}
instead?  Also, why name it, since there can be only one of them and
it's not accepting parameters?  Let's just say {\tt Stream} at the
toplevel.

\item I'm again of the opinion that control constructs should return
objects.  It's very difficult to explain what they *do* return (or
represent) if it's not an object--it's a collection of blocks, but
it's a control construct?  Then what if it's exactly one block?  Then
it's not an object anymore?  Doesn't make sense.

\item Is it ok not to require break statements at the end of each {\tt
case} in a {\tt StreamSelect}?  We'd differ from standard convention,
but would anyone use the fall-through feature?

\end{enumerate}

\section{To improve this document...}

\begin{enumerate}

\item Add lots of examples.

\item Replace my dinky syntax defs with the actual grammar.

\item Better / more clear distinction between initialization time and
steady state streaming time.  And then scripting time, too.

\item Better names for everything.  Especially control constructs
(graph construction constructs instead?), filters, ``functional
blocks'', etc.

\item Get number layered 4 deep instead of boldface headings.

\item Add a section on scheduling guarantees (or lack thereof.)

\item Define terms earlier (blocks vs. 1-to-1 blocks, etc.)

\item Make it clear that FilterBlocks can contain streams, not just
blocks.

\end{enumerate}

\section{Introduction}
\label{sec:intro}

The StreaMIT programming language is designed to enhance the
programmability and performance of streaming applications.  In
providing high-level constructs for building streams out of a number
of simple blocks, the language provides a clean, expressive, and
modular framework that programmers can use to reason about streaming
computations.  At the same time, the language imposes a structure on
the streams which can be exploited by a compiler to perform
stream-specific optimizations.  Thus, the abstractions provided by the
language serve not only to improve the programming model, but to
facilitate performance improvements that motivate the language in
their own right.

The following example defines a stream that prints a continuous
sequence of ``Hello World!'' messages to the screen.  It illustrates
the main components of StreaMIT:

\begin{verbatim}
Stream {

  Filter {
    output String myOutput;

    work() {
      output.push (``Hello '');
    }
  }

  Filter {
    input String myInput;
    output String myOutput;

    work() {
      output.push (input.pop () + ``World!'');
  }

  Filter {
    input String myInput;
    
    work() {
      System.out.println(input.pop ());
    }
  }
}
\end{verbatim}

In StreaMIT, the basic processing unit is the {\tt Filter}, which
may read items from an input channel and write items to an output
channel.  A filter that requires no input or output is called a
source and a sink, respectively.  In the example above, a 
source generates the ``Hello'' string, a {\tt Filter} appends
``World!'', and a sink prints the result to the screen.

Each filter defines a {\tt work} function that represents the most
fine-grained step of execution in transforming data from the input
channel to the output channel.  This function is called automatically
by the runtime system when the stream is running.  The input and
output channels are accessed as stacks.  Input is popped (or peeked, if
the data in the input is supposed to remain there),
while output is pushed to.  In the ``Hello World'' example, each 
filter reads or writes a single item before advancing the tape for 
the next step.

Filters implicitly are connected together in the order of their
definition.  Thus, in the ``Hello World!'' example, the three filters
are pipelined together and enclosed within a {\tt Stream} construct,
which denotes the top-level stream in the program.

The following sections describe the StreaMIT language in more detail.
First we present the {\it base language}, which encompasses all of the
expressive power of StreaMIT.  Then we discuss the {\it scripting
language}, a layer on top of the base language that simplifies stream
construction via the use of compile-time macros.

\section{The Base Language}

The StreaMIT base language allows the programmer to define processing
units and to arrange them into a stream.  Thus, the base language can
be broken down into two levels: 1) the definition of {\it functional
blocks} to transform one data stream into another, and 2) the use of
{\it control constructs} to arrange the objects into a streaming
structure.  Additionally, the language provides a set of dynamic
constructs for passing messages, re-initializing stream components,
and modifying the structure while the stream is executing.

In the following sections, we describe the StreaMIT base language from
the bottom up: functional blocks (Section \ref{sec:blocks}), control
constructs (Section \ref{sec:control}) and dynamic constructs (Section
\ref{sec:dynamic}).

\subsection{Types}

StreaMIT language uses a type system similar to those defined by Java and
C.  Following types are defined: bool, byte, word, int, long, float 
and double.  These types can be combined into {\tt struct}s, similar 
to those defined by C.  The language allows taking a (Java style) 
reference of a {\tt struct}.  The reference can be saved inside of 
Filters, etc, just like any other type.

An array can be defined using syntax similar to that of C:

element-type array-name [30];

Strings are represented as references null-terminated arrays of chars.

Finally, StreaMIT uses a tagged union type.  A tagged union type is similar
to a C union, except it checks which field of the union is currently active
(using an automatically maintained tag).  It is a run-time exception to
read a field which is not the most-recently assigned one.  In addition
to run-time checking of accessed fields, StreaMIT's tagged unions can also
test if a given field is the current field:

\begin{verbatim}
union u { int num; float frac }
u data;
data.num = 3;
if (data.isActive (num)) { /* do stuff if num is currently active */ }
\end{verbatim}

\subsection{Functional Blocks}
\protect\label{sec:blocks}

There are two kinds of functional blocks in StreaMIT.  The
lowest-level block is the {\tt Filter}, which defines a leaf node;
that is, the code within a filter is organized procedurally instead of
as a stream.  The second construct, the {\tt FilterBlock}, represents
a composition of other filters into a streaming structure.  Though a
filter block does not contain procedural code like a filter, we'll see
that filters and filter blocks can be treated as identical black-box
abstractions during stream construction.

\subsubsection{Filters}

In many ways, filters correspond to the usual notion of an object in
an object-oriented programming language.  Below we discuss their
declaration and instantiation.

\medskip
\noindent {\bf Filter Declaration}
\medskip

Filters are declared with the following syntax:

\begin{tabbing}
\hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \\

{\tt Filter} filter-name (type$_1$ param$_1$, type$_2$ param$_2$,
... , type$_n$ param$_n$) \{ \\ \\

\> \{ {\tt input} input-type input-name; \}+ \\
\> \{ {\tt output} output-type output-name; \}+ \\ \\

\> {\it data fields} \\ \\

\> {\it initialization code} \\ \\

\> {\tt work()} \{ \\ \\
\> \} \\ \\

\> {\it other functions} \\

\}
\end{tabbing}

We discuss the implications of the above syntax in the order that it
appears:

\begin{itemize}

\item {\it Type declaration.}  The {\tt Filter} type indicates that
there may be an input and an output channel for this block.  If there is
only an output channel, the {\tt Filter} is essentially a source; if there is
only an input channel, the {\tt Filter} is a sink.

\item {\it Naming filters.}  The ``filter-name'' denotes the name for
the type of filter being defined.  This name is used to instantiate
the filter (see below).

\item {\it Fields, parameters, and scoping.}  Data fields can be
declared as in C++ or Java.  All fields are implicitly private--they
are not visible from outside the scope of the filter.  Symmetrically,
no variables defined globally or in an enclosing scope are visible
from within a filter.  However, the filter can reference globally
visible functions that have no side effects and are only pure
functions of their arguments.

The filter can receive any number of parameters upon its
initialization.  These parameters act like data fields that are
initialized to the values that are passed as arguments to the filter.
That is, they are visible to all functions within the filter, they are
part of the filter's persistent state, and they can be modified like
normal fields.

\item {\it Input and output.}  The first field declarations are for
the input and output channels, which represent the means for passing
data through the filter during steady state stream operation.  Each
channel must be typed and given a name for use within the filter.  All
items within a channel are passed by value (with semantics equivalent
to copying each value before writing it to the channel), and no
pointers to global structures can be communicated through a channel.

\item {\it Initialization code.}  The initialization code is run when
the filter is first instantiated, just like the constructor to an
object.  The initialization code can modify data fields and
parameters, as well as read input and write output.  We allow I/O from
the initializer in case a filter needs to handle the first few data
items differently than the steady state.

\item {\it Work function.}  The work function holds the code that is
invoked dynamically for a single execution step of the filter.  This
function should be as fine-grained as possible--involving only as many
input and output items as necessary--to promote program
comprehensibility and to facilitate compiler optimization.  The
function accepts no parameters, although (like every other function in
a filter) it has access to the filter's fields and parameters.  Within
the work function, input and output is done via the channels as
described above.

\item {\it Other functions.}  The filter is free to define other
functions, just like objects can define methods in an object-oriented
language.  However, all of these functions are implictly private, and
can't be seen from outside the scope of the filter.

\end{itemize}

\medskip
\noindent {\bf Filter Instantiation}
\medskip

A filter can be instantiated into the stream graph by calling its name
with some arguments, e.g. {\tt MyFilter(arg$_1$, arg$_2$, ...,
arg$_n$)}.  This is equivalent to inlining the entire filter
definition and supplying the arguments as initial values for the
parameters.  That is, we can convert above call into:

\begin{tabbing}
\hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \\

{\tt Filter MyFilter(type$_1$ param$_1$ = arg$_1$, type$_2$ param$_2$
= arg$_2$, ..., type$_n$ param$_n$ = arg$_n$)} \{ \\ \\

\> {\it filter body} \\ \\
\}
\end{tabbing}

In this inlined form, the name {\tt MyFilter} becomes optional; we
could remove it if desired.  The inlined syntax is thus an equivalent
way of declaring filters.  We could translate any inlined filter into
a named filter that is explicitly instantiated.

An important restriction on filter instantiation is that the stream's
structure (i.e., which blocks appear in the stream and how they are
connected) must be known at compile time.  For now, this means that no
conditional control flow (e.g., {\tt for}, {\tt if}, {\tt while}) can
surround filter instantiations.  Later we will introduce two methods
to relax this restriction: {\tt StreamSelect} (Section
\ref{sec:streamselect}) and the scripting language (Section
\ref{sec:script}).

\subsubsection{FilterBlocks}

The second kind of functional block, the {\tt FilterBlock}, is similar
to a filter in that it transforms one data stream into another.
However, a filter block manifests this transformation as an arrangment
of other filters (and/or filter blocks) rather than as procedural code
that deals explicitly with input and output channels.  FilterBlocks
are instantiated just like filters.  However, their declaration is
somewhat different:

\begin{tabbing}
\hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \\

{\tt FilterBlock} filter-block-name (type$_1$ param$_1$, type$_2$ param$_2$,
... , type$_n$ param$_n$) \{ \\ \\

\> {\it data fields} \\ \\

\> {\it stream initialization code} \\ \\

\}
\end{tabbing}

The differences between the {\tt FilterBlock} and {\tt Filter}
declarations are as follows.  Firstly, the filter block lacks the
input and output channels, as well as the work function and the
capacity to define local methods.  However, the crucial difference is
in the initialization code.  Whereas a filter's initialization code is
for modifying fields and doing I/O, a filter block instantiates a
series of filters (and/or filter blocks).  By default, the filters are
connected in the order in which they are instantiated, although more
complex structures can be obtained using control constructs (see
Section {\ref{sec:control}}).  Thus, the filter block contains whatever
graph of filters it initializes.  

Sources and sinks are expressed simply as filters with no inputs/outputs.
Below is a modified version of Hello World program which uses source
and sink filters.

\begin{verbatim}
FilterBlock {

  MakeText();

  Filter {
    input String myInput;
    
    work() {
      System.out.println(input.pop ());
    }
  }
}

FilterBlock MakeText() {

  Filter {
    output String myOutput;

    work() {
      output.push (``Hello '');
    }
  }

  Filter {
    input String myInput;
    input String myOutput;

    work() {
      output.push (input.pop () + ``World!'');
    }
  }
}

\end{verbatim}

\subsubsection{Naming}

StreaMIT provides a naming scheme for functional blocks that is useful
for both dynamic events (see Section {\ref{sec:dynamic}}) and
debugging.  Firstly, any instantiation of a block can be bound to a
variable of type {\tt FilterRef}.  We require each {\tt FilterRef}
variable to be defined exactly once; that is, it functions less as a
variable than as a static denotable label for a single block
instantiation.  Accordingly, we allow {\tt FilterRef} variables to be
used before they are defined (but not before they are declared, of
course.)  {\tt FilterRef}'s can be passed as parameters to {\tt
Filter}'s and {\tt FilterBlock}'s, just like any other data type.  The
following example illustrates the syntax of assigning to {\tt
FilterRef}'s:

\begin{verbatim}
Filter MyFilter(FilterRef ref) {
  ...
}

FilterBlock MyBlock() {

  FilterRef ref1, ref2;

  ref1 = MyFilter(ref2);
  ref2 = Filter {
    ...
  }

}
\end{verbatim}

The second naming feature in StreaMIT allows one to assign a string
name to a given {\tt FilterRef} on the same line as its definition.
Then, the name can be obtained from a {\tt FilterRef} ``ref'' by
calling ``ref.getName()''.  Further, a hierarchical description
containing the path-delineated names of all enclosing blocks can be
obtained by calling ``ref.getFullName()''.  If a given block was not
assigned a name, then a name is generated from the block's type and
position in the stream structure.  In all, these naming functions
serve as a runtime counterpart the variable naming above; this
functionality is intended for user interface and debugging.  The
abstract syntax for the naming system is thus as follows:

[{\it filter-ref-variable} = [{\it string-name}] ] {\it block-instantiation}

where {\it block-instantiation} can be any block, either constructed
or inlined.  As an example, we rewrite the ``Hello World!'' program
using names:

\begin{verbatim} 

Stream {
  FilterRef helloRef, worldRef;		// NOTE: ILLEGAL INSIDE STREAM {

  helloRef = ``Hello '' Filter {
	...
  }

  worldRef = ``World!'' Filter {
	...
  }

  Filter(ref1 = helloRef, ref2 = worldRef) {
    ...
    
    work() {
      ...
      System.out.println(ref1.getName() + ref2.getName());
    }
  }

}

\end{verbatim}

\subsection{Control Constructs}
\protect\label{sec:control}

So far we have focussed on building the objects that do the
steady-state processing of stream data.  We now turn our attention to
the constructs that are used to connect the functional blocks into a
streaming structure.  Here it is important to emphasize that the graph
structure is created at {\it initialization time}, whereas the {\tt
work} functions of the filters are executed during the {\it steady
state} operation of the stream.  The initialization code is run only
once for any given period of steady state operation.  Thus, we have
two distinct times of execution in our language (we will introduce yet
another time in Section {\ref{sec:script}}.)

There are three basic control constructs in StreaMIT: 1) Pipe, for
connecting filters into a linear chain, 2) SplitJoin, for splitting a
stream into parallel components, and 3) FeedbackLoop, for
incorporating loops into the graph.  Note that while these constructs
are very expressive, they can not express all arbitrary connections of
filters.  However, our philosophy is that structured streams compare
to arbitrarily connected streams as structured control flow compares
to goto statements: the loss of expressive power will be more than
offset by improved readability and opportunity for optimization.

Some terminology is in order to accurately describe the semantics of
the control constructs.  We will use the word {\it block} to refer to
any of a {\tt Filter} or a {\tt FilterBlock}.
A {\it 1-to-1 block} refers to
only those blocks that have both an input and output: the {\tt Filter}
and {\tt FilterBlock}.  A {\it stream} is either a block or a
composition of blocks formed using the control constructs.  A stream
can be characterized by the presence or absence of the input and
output channel; a stream is designated {\it 1-to-1} if it both
consumes input and produces output.

\subsubsection{Pipe}

The simplest control construct is the {\tt Pipe}.  It connects a
series of streams into a linear chain, using the following syntax:

\begin{tabbing}
\hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \\

{\tt Pipe} \{ \\ \\
\> {\it stream$_1$} \\
\> {\it stream$_2$} \\
\> \dots \\
\> {\it stream$_{n-1}$} \\
\> {\it stream$_n$} \\

\}
\end{tabbing}

The {\tt Pipe} construct defines a stream where the output channel of
stream $i$ is connected to the input channel of stream $i+1$, for all
$i$ from $1$ to $n-1$.  Naturally, this requires that {\it stream$_1$}
produces output, {\it stream$_n$} consumes input, and {\it stream$_2$}
through {\it stream$_{n-1}$} are 1-to-1.  Further, each pair of input
and output channels that is connected must be of the same type.  The
stream defined by the {\tt Pipe} adopts the input channel of {\it
stream$_1$} and the output channel of {\it stream$_n$}, if these
channels exist.

The control flow defined by a {\tt Pipe} is the default control flow
in StreaMIT.  For instance, the streams defined within a {\tt
FilterBlock} are implicitly enclosed within a {\tt Pipe}.  

\subsubsection{Stream}

The {\tt Stream} construct is used to denote the top-level stream in
the program.  Its syntax and semantics are identical to that of {\tt
Pipe}, except that the first stream must require no input and the last
stream must produce no output.

\subsubsection{SplitJoin}

Up to this point, all of our streams have been arranged in a single
line.  The {\tt SplitJoin} construct can be used to split a stream
into multiple parallel sections.  It imposes structure in that no
connections are allowed between parallel sections; that is, parallel
streams must remain distinct until they are joined together again.
The syntax is as follows:

\begin{tabbing}
\hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \\
{\tt SplitJoin} \{ \\
\> splitter-type \\
\> {\it stream$_1$} \\
\> {\it stream$_2$} \\
\> \dots \\
\> {\it stream$_n$} \\
\> joiner-type \\
\}
\end{tabbing}

The {\tt SplitJoin} construct defines a stream where input items are
distributed to {\it stream$_1$} through {\it stream$_n$} according to
``splitter-type'', and outputs of {\it stream$_1$} through {\it
stream$_n$} are combined according to ``joiner-type''.  Thus, each
stream must be 1-to-1, and must have identical input and output types
(until we introduce type-dispatching splitters and joiners.)

The types of the splitter and joiner are compiler defined.  For now,
we support the following splitters:

\begin{enumerate}

\item {\tt DUPLICATE}, which sends a copy of each input item to each
of the parallel streams.

\item {\tt ROUND\_ROBIN}, which sends input item $i$ to {\it
stream$_{1+(i~mod~n)}$}.  That is, the inputs are alternately sent to
each stream, starting with the first one.

\item {\tt WEIGHTED\_ROUND\_ROBIN} (weight$_1$, weight$_2$, \dots,
weight$_n$), which operates like ROUND\_ROBIN, except that weight$_i$
items are sent to the $i$'th stream before moving on to the next one.
If stream $i$ does not have an input channel, then weight$_i$ must be
0.

\item {\tt NULL}, which is syntactic sugar for {\tt
WEIGHTED\_ROUND\_ROBIN}(0, 0, ..., 0).  That is, all of the streams
contain a source and require no input from the splitter.

\end{enumerate}

The joiners we support are as follows:

\begin{enumerate}

\item {\tt ROUND\_ROBIN}, which selects output item $i$ from {\it
stream$_{1+i~mod~n}$}.  That is, the outputs are alternately selected
from each stream, starting with the first one.

\item {\tt WEIGHTED\_ROUND\_ROBIN} (weight$_1$, weight$_2$, \dots,
weight$_n$), which operates like ROUND\_ROBIN, except that weight$_i$
items are drawn from the $i$'th stream before moving on to the next
one.  If stream $i$ does not have an ouput channel, then weight$_i$
must be 0.

\item {\tt NULL}, which is syntactic sugar for {\tt
WEIGHTED\_ROUND\_ROBIN}(0, 0, ..., 0).  That is, all of the streams
contain a sink and produce no output for the joiner.

\end{enumerate}

\subsubsection{FeedbackLoop}

The {\tt FeedbackLoop} construct provides a means for introducing
loops into the stream structure.  However, we impose the restriction
that there can be no channel connections between blocks inside the
loop and blocks outside the loop.  This results in a flow of data that
is similar to the flow of control in the loop nests of traditional
programs.  The syntax is as follows:

\begin{tabbing}
\hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \\

{\tt FeedbackLoop} \{ \\
\> {\it FeedbackFilter} \\
\> \{ {\tt body} {\it stream$_{body}$} \}+ \\
\> \{ {\tt loop} {\it stream$_{loop}$} \}+ \\
\}
\end{tabbing}

The {\tt FeedbackLoop} passes the input stream through a ``feedback
filter'' (see below), whose output is connected to {\it
stream$_{body}$}, the body of the loop.  The output of {\it
stream$_{body}$} is the output of the entire construct.  However, this
output is also passed back through {\it stream$_{loop}$} and connected
as a second input to the feedback filter, thereby introducing a
backwards path of data movement in the stream.

Both {\it stream$_{body}$} and {\it stream$_{loop}$} are optional.
If they are ommitted, they are assumed to be {\tt Filter}s which simply
copy their input to their output (do no useful work).

\medskip
\noindent {\bf FeedbackFilter}
\medskip

The {\tt FeedbackLoop} utilizes a special kind of filter called a {\tt
FeedbackFilter}.  A {\tt FeedbackFilter} is identical to a {\tt
Filter} except that it has an extra input channel for the feedback
loop.  This channel is declared as {\tt feedback-input} in the body of
the filter, such that the beginnig of a {\tt FeedbackFilter}
declaration looks like this:

\begin{tabbing}
\hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \\

{\tt FeedbackFilter} filter-name (type$_1$ param$_1$, type$_2$ param$_2$,
... , type$_n$ param$_n$) \{ \\ \\

\> {\tt feedback-input} feedback-input-type feedback-input-name; \\
\> {\tt input} input-type input-name; \\
\> {\tt output} output-type output-name; \\ \\

\> \dots \\
\}
\end{tabbing}

We would like to provide a mechanism for the {\tt FeedbackFilter} to
specify the {\it delay} of the feedback loop.  That is, suppose
that--in the steady state--item $i$ of {\tt input} and item $j$ of
{\tt feedback-input} are being read from within the work function.
Then we could
characterize the delay as the smallest $d$ for which {\tt
feedback-input[j]} depends on the value of {\tt input[i-d]}.
Intuitively, the delay is the offset of causal time fronts between the
inputs of the {\tt FeedbackFilter}, measured in the units of the
original stream.  Note that the delay is not necessarily equal to the
number of items that are in transit around the loop, since the item
count could vary if there are rate changes between blocks.

To allow the {\tt FeedbackFilter} to control the loop delay, as well
as to control which initial values are propagated around the feedback
path, we make a further restriction on the {\tt feedback-input}
channel: it can not be read from within the initialization code.
Instead, the {\tt FeedbackFilter} initializer should read {\it delay}
elements from the original {\tt input} channel and fabricate initial
outputs accordingly.  These outputs will propagate around the loop and
accumulate on the {\tt feedback-input} channel.  Then, when the
initializer exits and we enter the steady state, the {\tt
feedback-input} channel will be exactly $delay$ items ``behind'' the
{\tt input} channel, as desired.  Additionally, channels throughout
the feedback loop are initialized as a natural consequence of each
block's instantiation.  The compiler will signal an error if the
initializers do not output enough items to reach the {\tt
feedback-input} channel.

\subsection{Dynamic Constructs}
\protect\label{sec:dynamic}

Up until now, we have been considering only static definitions of
blocks and streaming structures.  We now introduce two dynamic
features of StreaMIT: message passing and re-initialization.  The
messaging system allows blocks to communicate data outside of the
primary input and output channels, perhaps to change some internal
parameters elsewhere in the stream.  The re-initialization construct
enables a filter to completely reset the internal state of a block in
the stream; this feature motivates an advanced control structure
called {\tt StreamSelect} that returns different stream structures
based on the values of the initialization parameters.

\subsubsection{Messages}

A filter can send dynamic messages from within its {\tt work}
function.  The syntax is as follows:

\medskip
{\it filter-ref-target}.{\tt handleMessage(}{\it msg}{\tt) }[{\tt @ }{\it delay} $|$ {\tt (}{\it min-delay}, {\it max-delay}{\tt )}]
\medskip

Let us examine the different parts of this statement:

\begin{itemize}

\item The message {\it msg} is an instance of a primitive type or a
user-defined structure that does not contain pointers.

\item The target of the message is given by {\it filter-ref-target},
of type {\it FilterRef}.  In the event that {\it filter-ref-target} is
a filter, the runtime system inspects the filter for a {\tt
handleMessage} method with the appropriate parameter type.  If such a
method exists, it is invoked with {\it msg} as the argument;
otherwise, the message has no effect.  If the target is instead a
filter block, then the above procedure is repeated in a top-down
fashion for every filter within the block.  In this case, ``top-down''
means that every filter is guaranteed that those blocks who dominate
it will receive the message before it does.

\item The optional @ syntax at the end of the statement indicates when
the message should be delivered.  The units of measurement are
executions of the {\it sender's} {\tt work} function.  If the message
delay is $k$, then the handler will be invoked (not necessarily
finishing) between the $(k-1)$'th and $k$'th fresh execution of {\tt
work}.  One may specify either an exact {\it delay}, or a range of
acceptable delays {\it (min-delay, max-delay)}.  If no delay is
specified, then the compiler makes a best-effort attempt to deliver
the message quickly.  The compiler will generate a warning message if
a specified delay is so small that it restricts its scheduling of the
stream; likewise, an error will be generated if the scheduling
constraints make it impossible to deliver a message as quicly as
requested.

\end{itemize}

There are some additional constraints on message passing.  The only
place that messages can be sent is from within the {\tt work} function
of a filter; initialization code and message handlers can not send
messages.  Also, a filter's message handlers are prohibited from doing
I/O on its channels, although they are allowed to modify the filter's
state.

\subsubsection{Re-Initialization}

Filters can re-initialize blocks from within their {\tt work} function
and message handlers.  Re-initialization can not be done from within
initialization code.  The syntax is as follows:

\medskip
{\it filter-ref-target}.{\tt reset(}{\it param$_1$, param$_2$, \dots, param$_n$}{\tt) }[{\tt @ }{\it delay} $|$ {\tt (}{\it min-delay}, {\it max-delay}{\tt )}]
\medskip

The re-initialization signal is delivered to a block just like any
other message.  Upon receiving the re-initialization message, the
target block executes all of its initialization code just as it did in
the beginning, but with the parameters specified by the caller.  

The compiler guarantees that there is a clean transition between the
old and the new blocks (as far as flushing pipelines, etc), but {\bf
we still need to work out the details}.

\subsubsection{StreamSelect}
\label{sec:streamselect}

Now that we have a method of re-initializing blocks, it is natural to
consider a control construct that can produce different stream
structures depending on the initialization parameters.  In this way, a
filter can change the structure of the stream dynamically, albeit
through an expensive re-initialization operation that should be used
sparingly.  The {\tt StreamSelect} construct serves this purpose; its
syntax is as follows:

\begin{tabbing}
\hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \hspace{0.2in} \= \\

{\tt StreamSelect(} {\it switch-expr} {\tt )} \{ \\ \\
\> {\tt case }{\it const-literal$_1$}{\tt :  }{\it stream$_1$}; \\
\> {\tt case }{\it const-literal$_2$}{\tt :  }{\it stream$_2$}; \\
\> \dots \\
\> {\tt case }{\it const-literal$_n$}{\tt :  }{\it stream$_{n}$}; \\
\> [{\tt default}{\tt :  }{\it stream$_{default}$};] \\
\}
\end{tabbing}

The stream returned by the {\tt StreamSelect} construct is a function
of the value of {\it switch-expr}, which must be of a type allowed by
the standard C {\tt switch} statement.  Also familiar from a common
{\tt switch} statement is 1) Each const-literal$_i$ must be unique,
and 2) the optional {\tt default} case, which is evaluated if none of
the case statements match.  However, the semantics differ from the
traditional {\tt switch} statement in that we do not require {\tt
break} commands to return control out of a given case; rather, control
returns by default instead of falling through to the next case.

\section{Scripting Language}
\label{sec:script}

The preceding sections completely describe the class of programs that
can be expressed in StreaMIT.  However, the restriction that block
instantiations can not appear within any conditional control flow
makes graph construction tedious and inflexible--for example, by
requiring $n$ repeated filter instantiations instead of having a
single instantiation inside a {\tt for} loop.

To allow such parameterized block instantiations, we introduce special
graph variables, graph control constructs, and graph parameters
whose values can be analyzed at compile time.

\subsection{Graph Type}

The {\tt graph} keyword is a primitive type modifier, with syntax
analogous to {\tt const} in Java or C:

\medskip
{\tt graph }{\it type variable-name};
\medskip

The restriction on graph variables is that their value must be
analyzable at compile-time for all points in the program.  An
expression is of type {\tt graph} if it is: 1) a constant literal, 2)
a graph variable that has been initialized, or 3) a pure function of
these.  A ``pure function'' is either a determistic primitive operator
(e.g., the arithmetic operators) or a user-defined function without
global side effects that returns a {\tt graph} expression.

Control flow that depends only on graph expressions is called {\it
graph control flow}.  To make it clear to the programmer which
control constructs have this property, we designate different keywords
for all graph control constructs.  They have the names of the normal
constructs, but with an ``g'' prepended, e.g., {\tt gfor}, {\tt gif},
and {\tt gwhile}.  Only expressions of type {\tt graph} can appear in
the conditional clause of these constructs.

Thus, with these definitions, we see that for the value of a graph
variable to be statically determined at all points in the program, it
must only be assigned expresseions of type {\tt graph}, and these
assignments must appear only within graph control flow.  By the same
reasoning, the stream structure is statically analyzable if all block
instantiations are within graph control flow.  This is our new
restriction on block instantiations: they can be enclosed in control
flow, but it must be {\it graph} control flow.

\subsection{Graph Parameters}

Parameters of type {\tt graph} can also be passed to filters and
filter blocks.  Since the values of these parameters can be determined
at compile time, they will not change across multiple instantiations
of a block.  Thus, we allow the user to specify graph parameters
enclosed between angled brackets before the regular dynamic
parameters:

{\tt Filter} filter-name $<${\tt graph} type$_{s1}$, {\tt graph} type$_{s2}$, \dots {\tt graph} type$_{sn}>$ (type$_1$ dynamic-param$_1$, type$_2$ dynamic-param$_2$, \dots , type$_n$ dynamic-param$_n$) \{ \dots \} \\

{\tt FilterBlock} filter-block-name $<${\tt graph} type$_{s1}$, {\tt graph} type$_{s2}$, \dots {\tt graph} type$_{sn}>$ (type$_1$ dynamic-param$_1$, type$_2$ dynamic-param$_2$, \dots , type$_n$ dynamic-param$_n$) \{ \dots \} \\

The graph parameters can be used just like the dynamic ones in the
context of the filters, but do not need to be given as arguments to
re-initialization calls.

\end{document}







