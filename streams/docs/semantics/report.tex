\documentclass[twocolumn, draft]{article}
\usepackage{psfig, wide, verbatim}
\title{StreaMIT Language Description \\ Version 0.0.5}
\author{Insomniac Streams Anonymous}


\begin{document}
\maketitle

\section{Basic Ideas}

The stream representation is composed of a number of basic building blocks.
All of these blocks are put together to form a graph, which can be drawn
on a 2D surface with no intersections.  The graph is almost a DAG, except
we allow feedback loops in arrangement of filters.

All blocks can be aggregated into larger superblocks:  Pipes, StreamSelects,
and SplitJoins.  The arrangement of these superblocks and
Filters is created in our scripting language.

Every Filter can send and receive messages through MessagePipes.  A filter 
can accept a MessagePipe in its Init function.  It can then bind itself
to this pipe as a receiver.  This allows us to set up a one-one,
one-many, many-one and many-many communication between filters.

There is another construct, ResetWire, for triggering reinitalization of 
filters/superblocks (through calling a function of the scripting language).

\section{Filters}
A new filter class is defined as follows:

\begin{verbatim}
class FooType is Filter
{
// insert data/functions here
};
\end{verbatim}

\subsection{Input/Output}

Each filter is required to have a single input and single output:
\begin{verbatim}
input inputType fooInput;
output outputType fooOutput;
\end{verbatim}

\subsection{Work}

Most of the work done by a filter is described in a Work function:

\begin{verbatim}
Work ()
{
  // essentially a low pass filter:
  fooOutput [0] = fooInput [0] + fooInput [-1];
}
\end{verbatim}

Work accepts no parameters.  It is allowed to send messages.  It is also
allowed to re-initialize other blocks.
Input/output
is accessed as an array.  For input, element 0 is first new element of input,
element 1 is second new element of input, etc.  Element -1 is the first seen
element of input.

\subsection{Init}

When a new filter is being constructed, a constructor (called Init) is called.
This constructor has a chance to initialize the filter with some initial
data (passed as arguments):

\begin{verbatim}
class FooClass is Filter
{
  float amplification;
  Init (float a)
  {
    amplification = a;
  }
};
\end{verbatim}

Init is allowed to send messages and push data into output blocks,
but is not allowed to read inputs or switch StreamSelects (described later).

\subsection{Message}

Each filter is allowed to receive messages:

\begin{verbatim}
MessageHandler (Msg fooMsg)
{
// .. handle msg here
}
\end{verbatim}

A message is defined as follows:

\begin{verbatim}
struct Msg
{
  int length;
  void *data;
};
\end{verbatim}

Message handlers are allowed to send other messages and/or reinitialize blocks.
Message handlers are not allowed to read stream input but they are allowed
to output to a stream.
Initialization of a filter causes this filter's message queue to be emptied.

In order to sign up for receiving messages, a Filter needs to bind a
handler function to a MessagePipe.

\begin{verbatim}
class FooFilter is Filter
{
  Init (MessagePipe pipe)
  {
    BindReceiver (MessageHandler, pipe);
  }
  MessageHandler(Msg x)
  {
  }

};
\end{verbatim}

Similarly, to sign up for sending messages, a Filter needs to store the
MessagePipe and send a message to it.

\begin{verbatim}
class BarFilter is Filter
{
  MessagePipe myPipe;
  Init (MessagePipe pipe)
  {
    mypipe = pipe;
  }
  Work ()
  {
    ...
    SendMessage (myPipe, msg);
    ...
  }
}
\end{verbatim}

\section{Scripting Language}

\subsection{Intro}

The scripting language is designed to allow for easy arrangement of 
filter structures.  The scripting language is procedural;  when a filter
variable is defined, it is considered inserted into the filter graph.
We define splits and joins that allow us to separate a stream into multiple
streams and then join them back together.

\subsection{Functions}

The script language is arranged into functions.  Calling a function is
equivalent to copying the function's body.  Thus the filter structure 
represented by the function will be placed at the point of the function
call.  Functions do not return values.  All of their parameters must
be constant (dependent only on their own parameters) to allow the compiler 
to determine the correct configuration of a given stream.

Functions are allowed to perform their own computation, but none of the
filters and/or other filter control sturctures may lay on paths that are
dependent on parameter inputs.  StreamSelect (described later) is used
for determining the particular structure of a stream graph.

The begining of the structure is described in the main function.

\begin{verbatim}
main ()
{
  FMRadio (99.9, RockNRoll, 1.5);
}
\end{verbatim}

In the example above, RockNRoll is a constant, probably defined through
an enum.

\subsection{Pipe}

Pipe is used for aggregating several filters together in a serial connection.

\begin{verbatim}
FMRadio (float fmFreq, MusicType mType, float loudness)
{
  Pipe
  {
    FMRadioSource (fmFreq);
    Equalizer (mType);
    Amplifier (loudness);
    Speaker ();
  }
}
\end{verbatim}

All filters and/or function calls have to accept a single input and result
in a single output (except for sources and sinks, described below).
All inputs/outputs are type-checked to make sure that
all types agree.

\subsection{Split}

In order to allow for splitting of single streams into multiples,
we define a SplitJoin construct:

\begin{verbatim}
Equalizer (MusicType mType)
{
  SplitJoin
  {
    RoundRobin;
    LeftAudioEqualizer leftAudio;
    RightAudioEqualizer rightAudio;
    RoundRobin;
  }
}
\end{verbatim}

The first entry of a SplitJoin must be the type of splitting performed
by this SplitJoin.  There types allowed are:  RoundRobin, WeightedRoundRobin
and Duplicate.  The last field is the method for joining the streams.  
Currently only RoundRobin and WeightedRoundRobin are allowed.

WeightedRoundRobin requires extra information which indicates how many
pieces of data should go to each subsequent filter.  The syntax for it
is as follows:

\begin{verbatim}
SplitJoin
{
  WeightedRoundRobin = {1, 2, 1};
  Filter1 foo;
  Filter2 bar;
  Filter3 foobar;
  WeightedRoundRobin = {1, 2, 1};
}
\end{verbatim}

The number of weights listed in the WeighterRoundRobin definition must
match the number of filters providied in the SplitJoin.

\subsection{StreamSelect}

StreamSelect allows us to switch configurations of the stream graph.
We define a StreamSelectSwitch, which can be activated by Work and message
handler functions of Filters. 

\begin{verbatim}
enum MusicType {
  Vocal,
  RockNRoll,
  HeavyMetal
}


{
  StreamSelectSwitch switch;
  StreamSelectSwitch (mType) = switch
  {
     case Vocal:
       // Vocal music sounds good without 
       // any modifications,
       // so don't do anything
     case RockNRoll:
       // want to amplify bass and treble
       LowPassFilter (0.5); // amplify
       HighPassFilter (0.5);
     case HeavyMetal:
       // only amplify the base
       LowPassFilter (0.5);
  }
}

class VoiceControl is Filter
{
  StreamSelectSwitch switch;
  Init (StreamSelectSwitch musicSwitch, 
        MessagePipe voiceMsgPipe)
  {
    switch = musicSwitch;
    BindReceiver (VoiceMsgHandler, voiceMsgPipe);
  }
  // on some message, switch to Vocal music:
  VoiceMsgHandler (Msg msg)
  {
    // process the msg
    ..
    // and switch
    switch.Set (Vocal);
  }
}
\end{verbatim}

Note, that parameter to the Set function of StreamSelectSwitch must be
a constant.  As a result the compiler can analyze possible combinations
of the stream and initialize them all.

\subsection{Sources/Sinks}

Sources and Sinks are very similar to Filters, except they either have
no inputs or outputs.  They are defined just like Filters (without
input/output), and used just like Filters.  A macro function can begin/end
with a Source/Sink.  This will cause it to have
no inputs/outputs.

The first block defined by calling the main function should have
no sources.  The last one should have no sinks.

A block with no input/output can be used in the middle of a macro function  (or
other appropriate structure).  The constraint is that after/before block(s) 
with no input/output, a Split/Join is required.

\begin{verbatim}

class Demultiplexer is Filter
{
  input StereoSignal rrAudio;
  output StereoSignal audioOut;
  Work ()
  {
    audioOut [0] = rrAudio [0] + rrAudio [1];
  }
};

class Microphone is Source
{
  output StereoSignal audio;
  Init ()
  { }
  Work ()
  {
    audio [0] = GetValueFromMic ();
  }
};

class TapePlayer is Source 
{ ... }

class SeparateStereo is Filter
{
  input StereoSignal sAudio;
  output float mAudio;
  int left;
  Init (int l)
  {
    left = l;
  }
  Work ()
  {
    if (left)
    {
      mAudio [0] = sAudio [0].left;
    } else {
      mAudio [0] = sAudio [0].right;
    }
  }
};

class Speaker is Sink
{ ... }

Karaoke ()
{
  Pipe
  {
    {
      Microphone ();
      TapePlayer ();
      // merge 2 streams using RoundRobin
      // merging.  Note: if we specify that
      // we want to merge 3 streams, Join
      // would also expect to get an input
      // to Kareoke
    } Join (2, RoundRobin);

    Demultiplexer ();
    // split into 2 streams using Duplicate
    // splitting;
    Split (2, Duplicate)
    {
      Pipe
      {
        SeparateStereo (0); // get left audio
        Speaker left ();
      }
      Pipe
      {
        SeparateStereo (1); // get right audio
        Speaker right ();
      }
    }
  }
}
\end{verbatim}

\subsection{FeedbackLoop}

Some stream applications require feedback loops for data processing.
Here we define a type that allows us to create feedback loops
in our stream graph.

A FeedbackLoop construct is very similar to Pipe.  It connects
several blocks in a serial connection, but it also allows to connect
the output of the pipe to the first block of the FeedbackLoop through
a FeedbackPath (which must be the last statement of the FeedbackLoop).
Since the first filter in a FeedbackLoop accepts
two inputs, this filter must be of FeedbackFilter type.

\begin{verbatim}
class NegFeedbackAmplifierFilter is FeedbackFilter
{
  input float audioIn;
  feedbackinput float feedback;
  output float audioOut;
  float ampGain;
  float amplification;
  Work ()
  {
    // this basically implements a negative feedback
    // loop with an amp of set gain and a set target
    // amplification.
    float in = audioIn [0];
    float out = feedback [0];
    float negFeed = in + 
      (in + out) / (-amplification + 1);
    float result = - negFeed * ampGain;
    audioOut [0] = result;
  }

  // note: here a is the POSITIVE amplification
  Init (float a, float gain)
  {
    ampGain = gain;
    amplification = -a;
  }
};

class NegFeedbackBuffer is Filter
{
  input float in;
  output float out;
  Work ()
  {
    in [0] = out [0];
  }

  Init (int delay)
  {
    for (int i = 0; i < delay; i++)
    {
      out [i] = 0;
    }
  }
};

NegFeedbackAmplifier ()
{
  FeedbackLoop
  {
    NegFeedbackAmplifierFilter (10, 1000);
    FeedbackPath NegFeedbackFilter (2);
  }
}
\end{verbatim}

\include{grammar}

\begin{comment}

\begin{figure}[t]
\centerline{\psfig{figure=block.ps}}
\vspace{-24pt}
\caption{\protect\small The block construct.}
\end{figure}

\section{old stuff}

\begin{lgrind}
\input{code.tex}
\end{lgrind}

\end{comment}


\end{document}

