\documentclass[twocolumn, draft]{article}
\usepackage{psfig, wide, verbatim}
\title{StreaMIT Language Description \\ Version 0.3-pre}
\author{Insomniac Streams Anonymous}


\begin{document}
\maketitle

\section{Basic Ideas}

The stream representation is composed of a number of basic building blocks.
All of these blocks are put together to form a graph, which can be drawn
on a 2D surface with no intersections.  The graph is almost a DAG, except
we allow feedback loops in arrangement of filters.

All blocks can be aggregated into larger superblocks:  Pipes, StreamSelects,
and SplitsJoins.  The arrangement of these superblocks and
Filters is created in our scripting language.

Every Filter can send and receive messages through MessagePipes.  A filter 
accepts a MessagePipe for its Init function.  It can then bind itself
to this pipe as a sender or a receiver.  This allows us to set up a one-one,
one-many, many-one and many-many communication between filters.

There is another construct, ResetWire, for triggering reinitalization of 
filters/superblocks (through calling a function of the scripting language).

\section{Filters}
A new filter type is defined as follows:

\begin{verbatim}
type FooType is Filter
{
// insert data/functions here
};
\end{verbatim}

\subsection{Input/Output}

Each filter is required to have a single input and single output:
\begin{verbatim}
input inputType fooInput;
output outputType fooOutput;
\end{verbatim}

\subsection{Work}

Most of the work done by a filter is described in a Work function:

\begin{verbatim}
Work ()
{
  // essentially a low pass filter:
  fooOutput [0] = fooInput [0] + fooInput [-1];
  fooInput.release (1);
  fooInput.advance (1);
  fooOutput.push (1);
}
\end{verbatim}

Work accepts no parameters.  It is allowed to send messages.  It is also
allowed to re-initialize other blocks.
Input/output
is accessed as an array.  For input, element 0 is first new element of input,
element 1 is second new element of input, etc.  Element -1 is the first seen
element of input.

\subsection{Init}

When a new filter is being constructed, a constructor (called Init) is called.
This constructor has a chance to initialize the filter with some initial
data (passed as arguments):

\begin{verbatim}
type FooType is Filter
{
  float amplification;
  Init (float a)
  {
    amplification = a;
  }
};
\end{verbatim}

Init is not allowed to send messages or initialize other blocks.

\subsection{Message}

Each filter is allowed to receive messages:

\begin{verbatim}
MessageHandler (Msg fooMsg)
{
// .. handle msg here
}
\end{verbatim}

A message is defined as follows:

\begin{verbatim}
struct Msg
{
  int length;
  void *data;
};
\end{verbatim}

Message handlers are allowed to send other messages and/or reinitialize blocks.
Message handlers are not allowed to read stream input or output any stream data.
Initialization of a filter causes this filter's message queue to be emptied.

In order to sign up for receiving messages, a Filter needs to bind a
handler function to a MessagePipe.

\begin{verbatim}
type FooFilter is Filter
{
  Init (MessagePipe pipe)
  {
    BindReceiver (MessageHandler, pipe);
  }
  MessageHandler(Msg x)
  {
  }

};
\end{verbatim}

Similarly, to sign up for sending messages, a Filter needs to store the
MessagePipe and send a message to it.

\begin{verbatim}
type BarFilter is Filter
{
  MessagePipe myPipe;
  Init (MessagePipe pipe)
  {
    mypipe = pipe;
  }
  Work ()
  {
    ...
    SendMessage (myPipe, msg);
    ...
  }
}
\end{verbatim}

\section{Scripting Language}

\subsection{Intro}

The scripting language is designed to allow for easy arrangement of 
filter structures.  The scripting language is procedural;  when a filter
variable is defined, it is considered inserted into the filter graph.
We define splits and joins that allow us to separate a stream into multiple
streams and then join them back together.

\subsection{Functions}

The script language is arranged into functions.  Calling a function is
equivalent to copying the function's body.  Thus the filter structure 
represented by the function will be placed at the point of the function
call.  Functions do not return values.  All of their parameters must
be constant (dependent only on their own parameters) to allow the compiler 
to determine the correct configuration of a given stream.

Functions are allowed to perform their own computation, but none of the
filters and/or other filter control sturctures may lay on paths that are
dependent on parameter inputs.  StreamSelect (described later) is used
for determining the particular structure of a stream graph.

The begining of the structure is described in the main function.

\begin{verbatim}
main ()
{
  FMRadio (99.9, RockNRoll, 1.5);
}
\end{verbatim}

In the example above, RockNRoll is a constant, probably defined through
an enum.

\subsection{Pipe}

Pipe is used for aggregating several filters together in a serial connection.

\begin{verbatim}
FMRadio (float fmFreq, MusicType mType, float loudness)
{
  Pipe
  {
    FMRadioSource (fmFreq);
    Equalizer (mType);
    Amplifier (loudness);
    Speaker ();
  }
}
\end{verbatim}

All filters and/or function calls have to accept a single input and result
in a single output (except for sources and sinks, described below).
All input/outputs are type-checked to make sure that
all types agree.

\subsection{Split}

In order to allow for splitting of single streams into multiples,
we define a SplitJoin construct:

\begin{verbatim}
Equalizer (MusicType mType)
{
  SplitJoin
  {
    RoundRobin;
    LeftAudioEqualizer leftAudio;
    RightAudioEqualizer rightAudio;
    RoundRobin;
  }
}
\end{verbatim}

The first entry of a SplitJoin must be the type of splitting performed
by this SplitJoin.  There are two types allowed:  RoundRobin and Duplicate.
The last field is the method for joining the streams.  Currently only
RoundRobin is allowed.

\subsection{StreamSelect}

StreamSelect allows us to switch configurations of the stream graph.
We define a StreamSelectSwitch, which can be activated by Work and message
handler functions of Filters. 

\begin{verbatim}
enum MusicType {
  Vocal,
  RockNRoll,
  HeavyMetal
}

Equalizer (MusicType mType)
{
  StreamSelectSwitch switch;
  StreamSelectSwitch (mType) = switch
  {
     case Vocal:
       // Vocal music sounds good without 
       // any modifications,
       // so don't do anything
     case RockNRoll:
       // want to amplify bass and treble
       LowPassFilter (0.5); // amplify
       HighPassFilter (0.5);
     case HeavyMetal:
       // only amplify the base
       LowPassFilter (0.5);
  }
}

type VoiceControl is Filter
{
  StreamSelectSwitch switch;
  Init (StreamSelectSwitch musicSwitch, 
        MessagePipe voiceMsgPipe)
  {
    switch = musicSwitch;
    BindReceiver (VoiceMsgHandler, voiceMsgPipe);
  }
  // on some message, switch to Vocal music:
  VoiceMsgHandler (Msg msg)
  {
    // process the msg
    ..
    // and switch
    switch.Set (Vocal);
  }
}
\end{verbatim}

Note, that parameter to the Set function of StreamSelectSwitch must be
a constant.  As a result the compiler can analyze possible combinations
of the stream and initialize them all.

\begin{comment}
\subsection{Split/Merge}

The predefined Split construct does not allow for much flexability in
creating interesting designs of stream flow.  Following two base types
are used for defining custom splits and merges:

\begin{verbatim}
type LeftHeavySplit is CustomSplit
{
  input float audio;
  output float leftAudio;
  output float rightAudio;
  Work ()
  {
    leftAudio[0] = audio[0];
    leftAudio[1] = audio[1];
    rightAudio[0] = audio[2];

    audio.release (3);
    audio.advance (3);
    leftAudio.push (2);
    rightAudio.push (1);
  }
};

type LeftHeavyMerge is CustomMerge
{
  input float leftAudio;
  input float rightAudio;
  output float audio;
  Work ()
  {
    audio[0] = leftAudio [0];
    audio[1] = leftAudio [1];
    audio[2] = rightAudio [2];

    leftAudio.release (2);
    leftAudio.advance (2);
    rightAudio.release (1);
    rightAudio.advance (1);
    audio.push (3);
  }
};

type LeftHeavyFilter is FilterBlock
{
  input float inAudio;
  output float outAudio;
  Init ()
  {
    LeftHeavySplit s;
    LeftAudioFilter l;
    RightAudioFilter r;
    LeftHeavyMerge m;
  }
};
\end{verbatim}

Both CustomMerge and CustomSplit are allowed to have Init and Message
functions.  Their functionality and definition syntax is overall very
similar to that of Filter, except Filter is allowed only single input/
single output, where as CustomSplit can have multiple outputs and 
CustomMerge can have multiple inputs.

When using CustomSplit/CustomMerge, we simply declare the Split, followed
by appropriate number of singe input/single output blocks, followed by
a CustomMerge of appropriate number of inputs.

\end{comment}

\subsection{Sources/Sinks}

Sources and Sinks are very similar to Filters, except they either have
no inputs or outputs.  They are defined just like Filters (without
input/output), and used just like Filters.  A macro function can begin/end
with a Source/Sink.  This will cause it to have
no inputs/outputs.

The first block defined by calling the main function should have
no sources.  The last one should have no sinks.

A block with no input/output can be used in the middle of a macro function  (or
other appropriate structure).  The constraint is that after/before block(s) 
with no input/output, a Merge/Join is required.

\begin{verbatim}

type Demultiplexer is Filter
{
  input StereoSignal rrAudio;
  output StereoSignal audioOut;
  Work ()
  {
    audioOut [0] = rrAudio [0] + rrAudio [1];

    rrAudio.release (2);
    rrAudio.advance (2);
    audioOut.push (1);
  }
};

type Microphone is Source
{
  output StereoSignal audio;
  Init ()
  { }
  Work ()
  {
    audio [0] = GetValueFromMic ();
    audio.push (1);
  }
};

type TapePlayer is Source 
{ ... }

type SeparateStereo
{
  input StereoSignal sAudio;
  output float mAudio;
  int left;
  Init (int l)
  {
    left = l;
  }
  Work ()
  {
    if (left)
    {
      mAudio [0] = sAudio [0].left;
    } else {
      mAudio [0] = sAudio [0].right;
    }
  }
};

type Speaker is Sink
{ ... }

Karaoke ()
{
  Pipe
  {
    {
      Microphone ();
      TapePlayer ();
      // merge 2 streams using RoundRobin merging
      // note: if we specify that we want to merge 3 streams,
      // Merge would also expect to get an input to Kareoke
    } Merge (2, RoundRobin);

    Demultiplexer ();
    // split into 2 streams using Duplicate splitting;
    Split (2, Duplicate)
    {
      Pipe
      {
        SeparateStereo (0); // get left audio
        Speaker left ();
      }
      Pipe
      {
        SeparateStereo (1); // get right audio
        Speaker right ();
      }
    }
  }
}
\end{verbatim}

\subsection{FeedbackBlock}

We're still looking for good syntax for feedback blocks.

\begin{comment}
Some stream applications require feedback loops for data processing.
Here we define a type that allows us to create feedback loops
in our stream graph.

A FeedbackBlock type is very similar to FilterBlock, but it uses two inputs 
and one output.  The first input
is from the outside stream.  The second input is the feedback input.
The feedback input is defined using FeedbackPath construct.  FeedbackPath
allows us to specify in the Init function what type of FeedbackPath will
be used.  FeedbackPath must be used exactly once per Init function, and
may only be used in FeedbackBlock.

A FeedbackBlock does not have a Work function, but its first non-source
block must be a Merge.

\begin{verbatim}
type NegFeedbackAmplifierMerge is CustomMerge
{
  input float audioIn;
  input float feedback;
  output float audioOut;
  float ampGain;
  float amplification;
  Work ()
  {
    // this basically implements a negative feedback
    // loop with an amp of set gain and a set target
    // amplification.
    float in = audioIn [0];
    float out = feedback [0];
    float negFeed = in + 
      (in + out) / (-amplification + 1);
    float result = - negFeed * ampGain;
    audioOut [0] = result;
	
    audioIn.release (1);
    audioIn.advance (1);
    feedback.release (1);
    feedback.advance (1);
    audioOut.push (1);
  }

  // note: here a is the POSITIVE amplification
  Init (float a, float gain)
  {
    ampGain = gain;
    amplification = -a;
  }
};

type NegFeedbackBuffer is Filter
{
  input float in;
  output float out;
  Work ()
  {
    in [0] = out [0];

    in.release (1);
    in.advance (1);
    out.push (1);
  }

  Init (int delay)
  {
    for (int i = 0; i < delay; i++)
    {
      out [i] = 0;
    }
    out.push (delay);
  }
};

type NegFeedbackAmplifier is NegFeedbackAmp
{
  input float in;
  input float feedback;
  output float out;

  Init(float amp)
  {
    // gain = amp * 10 should be sufficient
    NegFeedbackAmplifierMerge (amp, amp * 10);

    // feedback will be delayed by 2 
    FeedbackPath NegFeedbackBufffer myBuffer (2);
  }
};

\end{verbatim}

\end{comment}

\begin{comment}

\begin{figure}[t]
\centerline{\psfig{figure=block.ps}}
\vspace{-24pt}
\caption{\protect\small The block construct.}
\end{figure}

\section{old stuff}

\begin{lgrind}
\input{code.tex}
\end{lgrind}

\end{comment}


\end{document}

