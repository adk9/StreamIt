\documentstyle[psfig,lgrind]{article}
\title{StreaMIT Intermediate Representation \\ Version 2.2}


\begin{document}
\maketitle

\begin{verbatim}
things to add:
- initialization
- hierarchical naming 
- how to do merges with the packaging semantics
- direct name invocation of messages
\end{verbatim}

\section{Basic Ideas}

The stream representation is composed of a number of basic building blocks.
All of these blocks are put together to form a graph, which can be drawn
on a 2D surface with no intersections.  The graph is almost a DAG, except
we allow feedback loops in arrangement of filters.

All blocks can be aggregated into larger superblocks:  Pipes, StreamSelects,
FeedbackLoops, Splits and FilterBlocks.  
All of these superblocks can be named.  Every 
(super)block has a StreamID associated with it.  A message can be sent 
to a StreamID, which will cause all highest-level blocks prepared to
receive messages contained in within the named block
to receive this msg.

A named (super)block can also be reinitialized.  This will cause all the 
in/outflowing buffers to be purged.

\section{Filters}
A new filter type is defined as follows:

\begin{verbatim}
type FooType is Filter
{
// insert data/functions here
};
\end{verbatim}

\subsection{Input/Output}

Each filter is required to have a single input and single output:
\begin{verbatim}
input inputType fooInput;
output outputType fooOutput;
\end{verbatim}

\subsection{Work}

Most of the work done by a filter is described in a Work function:

\begin{verbatim}
Work ()
{
  fooOutput [0] = fooInput [0] + fooInput [1];
  fooInput.release (2);
  fooInput.advance (2);
  fooOutput.push (1);
}
\end{verbatim}

Work accepts no parameters.  It is allowed to send messages.  It is also
allowed to re-initialize other blocks.
Input/output
is accessed as an array.  For input, element 0 is first new element of input,
element 1 is second new element of input, etc.  Element -1 is the first seen
element of input.

\subsection{Init}

When a new filter is being constructed, a constructor (called Init) is called.
This constructor has a chance to initialize the filter with some initial
data (passed as arguments):

\begin{verbatim}
type FooType is Filter
{
  StreamID parent;
  float amplification;
  Init (float a, StreamID p)
  {
    parent = p;
    amplification = a;
  }
};
\end{verbatim}

Init is not allowed to send messages or initialize other blocks.

\subsection{Message}

Each filter is allowed to receive messages:

\begin{verbatim}
Message (Msg fooMsg)
{
// .. handle msg here
}
\end{verbatim}

A message is defined as follows:

\begin{verbatim}
struct Msg
{
  StreamID source;
  int type;
  int length;
  void *data;
};
\end{verbatim}

Message is allowed to send other messages and/or reinitialize blocks.
Message is not allowed to read stream input or output any stream data.
Initialization of a filter causes this filter's message queue to be emptied.
A filter is guaranteed that all of its appropriate predecessors (in the graph)
will have received the msg before it does.

\section{FilterBlock}

FilterBlock is used to aggregate filters and superblocks.  It is a 
single input/single output structure.  It is allowed to have Init and Message
functions, but it is not allowed to have a Work function, nor define its
input or output.

\subsection{Init}

Init function for a FilterBlock is similar to Init function of a Filter.
FilterBlock, however, can also contain Filters/superblocks:

\begin{verbatim}
Init (float amp, float fLow, float fHigh, StreamID p)
{
  LowPass lowPassFilter (aLow);
  HighPass highPassFilter (aHigh);
  Amplifier amplifier (amp);
  parent = p;
}
\end{verbatim}

The above creates three filters connected in series.

\subsection{Message}

The Message function for a FilterBlock looks/works
identically to Filter's Message function.

\section{Pipe}

The above Init function aggregates three filters into one.  While this is
useful, we define another construct to do essentially the same thing
without having to define an all new type.  This new construct will
allow us to aggregate an arbitrary serial connection of fileters/superblocks:

\begin{verbatim}
Init (float amp, float fLow, float fHigh, StreamID p)
{
  Pipe BandPassFilter
  {
    LowPass lowPassFilter (aLow);
    HighPass highPassFilter (aHigh);
  } 
  Amplifier amplifier (amp);
  parent = p;
}
\end{verbatim}

Pipe allows us only to connect single input/single output blocks.

\section{Split}

In order to allow for splitting of single streams into multiples,
we define a Split construct:

\begin{verbatim}
Init ()
{
  Split(RoundRobin, RoundRobin)
  {
    LeftAudioFilter leftAudio;
    RightAudioFilter rightAudio;
  }
}
\end{verbatim}

The first field passed to Split is the type of splitting (RoundRobin,
Duplicate).  Second field passed to Split is type of merge (RoundRobin)
[shouldn't there be more?!!].  The body of Split defines all single input/
single output filters which are part of the Split.

\section{Custom Split/Merge}

The predefined Split construct does not allow for much flexability in
creating interesting designs of stream flow.  Following two base types
are used for defining custom splits and merges:

\begin{verbatim}
type LeftHeavySplit is CustomSplit
{
  input float audio;
  output float leftAudio;
  output float rightAudio;
  Work ()
  {
    leftAudio[0] = audio[0];
    leftAudio[1] = audio[1];
    rightAudio[0] = audio[2];

    audio.release (3);
    audio.advance (3);
    leftAudio.push (2);
    rightAudio.push (1);
  }
};

type LeftHeavyMerge is CustomMerge
{
  input float leftAudio;
  input float rightAudio;
  output float audio;
  Work ()
  {
    audio[0] = leftAudio [0];
    audio[1] = leftAudio [1];
    audio[2] = rightAudio [2];

    leftAudio.release (2);
    leftAudio.advance (2);
    rightAudio.release (1);
    rightAudio.advance (1);
    audio.push (3);
  }
};

type LeftHeavyFilter is FilterBlock
{
  input float inAudio;
  output float outAudio;
  Init ()
  {
    LeftHeavySplit s;
    LeftAudioFilter l;
    RightAudioFilter r;
    LeftHeavyMerge m;
  }
};
\end{verbatim}

Both CustomMerge and CustomSplit are allowed to have Init and Message
functions.  Their functionality and definition syntax is overall very
similar to that of Filter, except Filter is allowed only single input/
single output, where as CustomSplit can have multiple outputs and 
CustomMerge can have multiple inputs.

When using CustomSplit/CustomMerge, we simply declare the Split, followed
by appropriate number of singe input/single output blocks, followed by
a CustomMerge of appropriate number of inputs.

\section{Sources/Sinks}

Sources and Sinks are very similar to Filters, except they either have
no inputs or outputs.  They are defined just like Filters (without
input/output), and used just like Filters.  A FilterBlock can begin/end
its Init function with a Source/Sink.  This will cause it to have
no inputs/outputs.

A block with no input/output can be used in the middle of a FilterBlock (or
other appropriate structure).  The constraint is that after/before block(s) 
with no input/output, a Merge/Join is required.  These can be either
custom or defined as a part of Split construct.

\begin{verbatim}
type Microphone is Source
{
  float vol;
  output float audio;
  Init (float freq, float v)
  {
    vol = v;
    InitHardwareMic (freq);
  }
  Work()
  {
    audio [0] = vol * GetInputFromMic ();
    audio.push (1);
  }
};

type Speaker is Sink
{
  float vol;
  input float audio;
  Init (float v)
  {
    vol = v;
  }
  Work ()
  {
    SendToSpeaker (vol * audio[0]);
  }
};

type Karaoke
{
  StreamID me;
  Init (float micVol, float speakerVol)
  {
    Split (RoundRobin, RoundRobin) // first RoundRobin is unnecesary...
    {
      Microphone left (micVol);
      Microphone right (micVol);
    }
    LeftHeavySplit customSplit; // would give strange sound effect here...
    Speaker left;
    Speaker right;
    me = this.GetID ();
  }
  Message(Msg volume)
  {
    me.Init (float (thisvolume.type));
  }
};

\end{verbatim}


\section{Basic Constructs}

The stream representation is composed of a number of basic building
blocks.  Though all of these components could be templated to deal with
different types of data, for now we ignore typing issues and assume
everything is of type {\tt int}.

\subsection{Block}

The {\em block} is the basic unit of a stream (see Figure 1.)  It has
one input channel and one output channel, as well as a {\em step}
function that performs a unit of computation.  The block's specification
includes how many items it requires on its input channel to guarantee
that it will execute one complete step, as well as the maximum number of
items that it could produce on its output channel as a result of that
step.  One of our first compiler analyses will be to automatically
detect these input and output paremeters, although they could be
user-declared at first.

A block could be represented with the following syntax:

\begin{verbatim}
Block sum_pairs {
   // blocks can have private member fields that are visible only
   // to the member functions of this block
   int x, y;

   // the initialization function is called when the block is 
   // instantiated.
   init(int _x, int _y) {
     x = _x;
     y = _y;
   }

   // each step of this block will input at 
   // most two items and output at most one
   step (input 2, output 1) {
     int i1, i2;
     i1 = input(0);               // get newest item
     i2 = input(1);               // get next item in channel
     output(0) = i1 + i2;         // put sum in output channel
   }
}
\end{verbatim}

\begin{figure}[t]
\centerline{\psfig{figure=block.ps}}
\vspace{-24pt}
\caption{\protect\small The block construct.}
\end{figure}

\subsection{Pipe}

The pipeline construct is used to cascade single-input blocks (see
Figure 2.)  Since it has one output and one input, a pipeline is a
subclass of the Block type. Its syntax could be as follows:

\begin{verbatim}
Block my_pipe = pipe {
  // member fields
  int x, y;

  // initialization function
  init() {}

  block_1();
  block_2();
  ...
  block_n();
}
\end{verbatim}

\begin{figure}[t]
\centerline{\psfig{figure=pipe.ps}}
\vspace{-24pt}
\caption{\protect\small The pipe construct.}
\end{figure}

\subsection{Split-Join}

The split-join construct is the only means of obtaining parallelism in
our representation (see Figure 3.)  It consists of three parts: 1) a
{\em splitter} that inputs from single channel and outputs to $n$
channels (not necessarily all at once), 2) a {\em joiner} that inputs
from $n$ channels (not necessarily all at once) and outputs to a single
channel, and 3) $n$ 1-to-1 blocks in the middle.

For now, we are only considering pre-defined splitters and joiners,
though user-defined ones could follow.  The kinds we are considering
are:

\begin{enumerate}

\item {\em Round-Robin (splitter/joiner)}.  The round-robin block gets
(or puts) an item to each of the input (or output) channels in sequence.

\item {\em Null (splitter/joiner)}.  The null block serves as a
placeholder in constructs that do not require input from the splitter or
do not pass any output to the joiner.

\item {\em Duplicator (splitter)}.  The duplicator sends a copy of its
input to each of the output channels.

\end{enumerate}

The split-join construct could be used with the following syntax:

\begin{verbatim}
// construct a split-join out of n parallel blocks with a duplicating
// splitter and a round-robin joiner
Block my_split = split-join (DUPLICATE, ROUND_ROBIN) {
  block_1();
  block_2();
  ...
  block_n();
}
\end{verbatim}

\begin{figure}[t]
\centerline{\psfig{figure=split-join.ps}}
\vspace{-24pt}
\caption{\protect\small The split-join construct.}
\end{figure}

\subsection{Feedback Loop}

The feedback loop provides a structured way to introduce cylces into
streams (see Figure 4.)  Given a block $B$ that comprises the body of
the loop, this construct feeds the output from $B$ into the second input
channel of a joiner $J$ at the head of the loop.  There is a buffer
between $B$ and $J$ whose length can be specified; also, an initializer
must be indicated to setup the contents of the buffer.

The syntax of the looping construct could be as follows.  We haven't
throught through the way to specify the custom joiner at the head of the
loop.

\begin{verbatim}
// specify a loop with a CUSTOM_JOINER at the top, an instance of
// my_pipe in the body, a buffer of size 10 and an instance of the 
// loop initializer defined below
Block my_loop = feedback_loop (CUSTOM_JOINER, my_pipe(), 10, my_init());

// here we specify a loop initializer that sets all the contents of the
// buffer to zero.
LoopInitializer my_init {
   // initializes the contents of the buffer to be zero.
   do_work(int* buffer, int delay) {
      for i = 1 to delay {
         buffer(i) = 0;
      }
   }
}

\end{verbatim}

\begin{figure}[t]
\centerline{\psfig{figure=feedback.ps}}
\caption{\protect\small The feedback-loop construct.}
\end{figure}

\section{Control Constructs}

The building blocks above are all intended for steady-state processing
of stream data.  There are also constructs for dynamic modification of
stream components and for dynamic message passing between blocks.  

A block can send a message from inside the body of its {\em step}
function.  When a message is sent, the message travels up the hierarchy
of block declarations until it reaches a {\em message ceiling} block
that catches the given type of message (see below.)  The recipients of
the message will be all blocks contained within the message ceiling that
are listening for the given type of message.  However, the message will
never appear in the data stream; rather, special handlers will be
invoked in the target blocks.

The block must instantiate a message, and indicate whether the message
will be delivered directly to other blocks (DIRECT\_NOTIFICATION), or
will be delivered through the data stream (STREAM\_NOTIFICATION).  In
direct delivery, the message recipients will be notified in any order,
whereas with stream notification, the message will enter the data stream
and will be processed in the same order as other data items.  Thus, the
syntax for sending messages could be as follows:

\begin{verbatim}
// this block sends a pre-defined StreamSelect message type, with
// in-order notification of recipients
Block sending_block {
  step (input n, ouput m) {
    ...
    send(StreamSelect(``fm''), STREAM_NOTIFICATION);
    ...
  }
}
\end{verbatim}

For receiving messages, we consider the following constructs:

\subsection{Stream Select}

The stream select construct is a mechanism for dynamically enabling and
disabling stream components (see Figure 5.)  Unlike the composition
constructs above, stream select is a {\em control} construct in that it
listens for StreamSelect messages to dictate its behavior.  The
construct has a pre-defined splitter and joiner, and requires $n$ input
streams to select from.  At any given time, only one of these streams
will be active, and all of the incoming data will be directed to the
active stream.  The active stream can be toggled via StreamSelect
messages that are tagged by the name of the active stream.

We still have to work out the exact semantics of stream initialization
when a new stream becomes active.  The syntax could be as follows:

\begin{verbatim}
// create a stream selector between fm and am streams that can be 
// toggled by StreamSelect messages with tags ``fm'' and ``am'', respectively
Block my_select = stream-select(fm_stream(), am_stream(), ``fm'', ``am'');
\end{verbatim}

\begin{figure}[t]
\centerline{\psfig{figure=stream-select.ps}}
\vspace{-24pt}
\caption{\protect\small The stream-select construct.}
\end{figure}

\subsection{Message Ceiling}

The message ceiling construct specifies the scope of given kinds of
messages (see Figure 6.)  It is constructed from 1) a block, which is
the stream enclosed by the ceiling, and 2) the message types that are
caught by the ceiling.  Then, whenever any block under the ceiling
throws a message of a recognized type, the message notification process
is initiated for all sub-components.

The syntax could be as follows:

\begin{verbatim}
// create a message ceiling over my_block for messages of type
// StreamSelect and UserMessage1
Block my_ceiling = message-ceiling(my_block(), StreamSelect, UserMessage1)
\end{verbatim}

\begin{figure}[t]
\centerline{\psfig{figure=ceiling.ps}}
\vspace{-24pt}
\caption{\protect\small The message-ceiling construct.}
\end{figure}

\section{C++ Interface}

It should be easy to design a scripting facility in C++ that will
automatically generate the structures of our intermediate lanaguage.
One method for doing this would be via ``descriptors'', which are
immutable, composable descriptions of a stream instantiation.  The
lowest-level descriptor requires specifying the type and primitive
arguments (chars, ints, strings, etc.) to a constructor of that type,
and higher-level descriptors are composed using the pipe, split-join,
and feedback-loop constructs.  Then, a descriptor can be instantiated
into a stream class that can then be executed.  The code fragment below
follows this approach.

Here are some nice aspects of using a scripting language to build up the
representation like this:

\begin{enumerate}

\item Allows you to pass initialization information to a given instance
of a type of block without allowing that instance to be named and used
in other parts of the program.

\item The descriptors are immutable, so it doesn't matter if you share
them in different parts of a definition.  That is, you can reuse a
descriptor as if it described a type, even though it describes a set of
instances.

\item Allows a good continuum between static and dynamic compilation (or
just conservative static analysis.)  When all the descriptor
construction can be analyzed, the stream object can be layed out at
compile time; otherwise it can be done at runtime.  Also, we can check
at compile time whether the construction is a semantically correct
stream representation.

\item When a stream is instantiated, it contains descriptions for all
the low-level components, too.  So optimization can be as global and
deep as desired.

\item Easy debugging when you're building up your program as a string.

\end{enumerate}

Now for the code: \\ \\

\begin{lgrind}
\input{code.tex}
\end{lgrind}

\end{document}

