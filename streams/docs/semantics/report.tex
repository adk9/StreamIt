\documentclass[twocolumn, draft]{article}
\usepackage{psfig, wide, verbatim}
\title{StreaMIT Intermediate Representation \\ Version 0.0.6}
\author{Perl Monkeys Inc.}


\begin{document}
\maketitle

\section{Basic Ideas}

The stream representation is composed of a number of basic building blocks.
All of these blocks are put together to form a graph, which can be drawn
on a 2D surface with no intersections.  The graph is almost a DAG, except
we allow feedback loops in arrangement of filters.

The layout of the filters is defined using a scripting language.  The scripting
language allows us to collect filters into structures such as Pipe,
StreamSelect, FeedbackLoop, SplitJoin and FilterBlock.  FilterBlock and 
SplitJoin are two constructs which work together to allow us to dynamically
change the flow of the stream.

Any FilterBlock can have its reference taken.  This reference can be passed
around, to functions and filters.  Filters can in turn send messages to
the reference and/or change its dynamic parameters.  Messages get delivered
from the top to the bottom (a filter will receive its message once its
predecessors have received this message).

\section{Script Type Modifier and Control Constructs}

In order to allow the programmer to express the difference between
script variables and dynamic variables, we introduce a new type modifier
and control constructs.  The purpose of script types is to allow the compiler
to figure out the exact flow of the streams.  Values of script variables
can be determined at compile time.

\subsection{Script Types}

A script type is also called a script type (to differentiate from C static
variables).  A script type can only be assigned a constant value, and can
only be modified within script control constructs.

\begin{verbatim}
script int foo;
foo = 42;
\end{verbatim}

\subsection{Script Control Constructs}

A script control construct is a control construct that operates only on
script and constant (textually, as in '3') values.  Otherwise these
control constructs behave exactly as regular C constrcuts.  Their names
are same as their C equivalents, except we add an 's' in front of all
script constructs ('s' as in script).

\begin{verbatim}
script int foo;
foo = 42;
int bar;
bar = 13;
sif (foo == 3) // legal
{ }
sif (bar == 17) // illegal
{ }
\end{verbatim}

Script control constructs are only allowed at the top level of a
script function or inside other script constructs:

\begin{verbatim}
sif (foo > 3)
  sif (foo < 10) // legal
    { }

if (foo < 3)
  sif (foo < 10) // illegal
    { }
\end{verbatim}

Regular C constructs are allowed to use script variables, as if they were
just regular C variables.


\section{Filters}
A new filter type is defined as follows:

\begin{verbatim}
Filter FooType<script params> (dynamic params)
{
// insert data/functions here
};
\end{verbatim}

\subsection{Parameters}

Upon instantiation, a filter can receive some parameters.  There are two
types of parameters:  script and dynamic.

Both types of parameters behave just like const parameters passed to a C 
function.  They can be copied to other variables, but cannot be modified
themselves.  The difference between them is that script parameters are
guaranteed to remain unchanged across multiple initializations of the
filter, while the dynamic variables are free to change between initializations.

\subsection{Input/Output}

Each filter is required to have a single input and single output:
\begin{verbatim}
input inputType fooInput;
output outputType fooOutput;
\end{verbatim}

\subsection{Work}

Most of the work done by a filter is described in a Work function:

\begin{verbatim}
Work ()
{
  fooOutput [0] = fooInput [0] + fooInput [1];
}
\end{verbatim}

Work accepts no parameters.  It is allowed to send messages.  It is also
allowed to re-initialize other blocks, using stored references to
FilterBlocks.
Input/output
is accessed as an array.  For input, element 0 is first new element of input,
element 1 is second new element of input, etc.  Element -1 is the first seen
element of input.

\subsection{Init}

When a filter is being initialized or reinitialized, a constructor 
(called Init) is called.  This constructor has a chance to initialize 
the filter with some initial data (passed as arguments to the filter).
Init does not accept any parameters of its own.

Because of the difference between the script and dynamic parameters,
we may want to preserve some of the properties of the script variables.
We have added a 'script' modifier to indicate that a given variable's
value is purely a function of script variables.  We also add new control
flow constructs (identical to C's constructs in function) for the same purpose.
These are explained later.

All distinctions between script and dynamic parameters and variables
are done in order to help the programmer to be expressive in choice of
constructs.

\begin{verbatim}
Filter FooType<script FilterRef p> (float a)
{
  script FilterRef parent;
  float amplification;
  Init ()
  {
    parent = p;
    amplification = a;
  }
};
\end{verbatim}

Init is not allowed to send messages or initialize other blocks.

\subsection{Message}

Each filter is allowed to receive messages:

\begin{verbatim}
ReceiveMessage (MyMsgType fooMsg)
{
// .. handle msg here
}
\end{verbatim}

MyMsgType is a custom type defined by the user (obviously it does not need
to be called MyMsgType).  A message is sent by calling a function on a
FilterRef.  Every Filter lying underneath the FilterBlock and containing
a function with an appropriate name will be called.  The function called
must accept at most one parameter, and the parameters received and passed
must match in type.

The function being called is allowed to send other messages and/or reinitialize
FilterBlocks.  It is not allowed to read stream input/output.

\section{Scripting Language}

The scripting language is designed to allow for easy arrangement of 
filter structures.  The scripting language is procedural;  when a filter
variable is defined, it is considered inserted into the filter graph.
We define splits and joins that allow us to separate a stream into multiple
streams and then join them back together.

\subsection{Script Functions}

The script language is arranged into functions.  Calling a function is
equivalent to copying the function's body.  Thus the filter structure 
represented by the function will be placed at the point of the function
call.  Functions do not return values.

Just like Filters, functions accept two types of parameters, script
and dynamic.  All of the rules for filter Init functions apply to the
scripting functions.

The begining of the filter structure is described in the 'main' function.
This function accepts no script or dynamic parameters.

\begin{verbatim}
main ()
{
  FMRadio (99.9, RockNRoll, 1.5);
}
\end{verbatim}

The above function calls the FMRadio function with some parameters.
Here is a possible body of FMRadio:

\begin{verbatim}
FMRadio (float fmFreq,
         MusicType mType,
         float amp)
{
  FilterRef ampRef;
  FMRadioSource (fmFreq);
  Equalizer<ampRef, RadioSettings> (mType);
  Amplifier<ampRef> (loudness);
  Speaker ();
}
\end{verbatim}

Here the Equalizer filter accepts not only the music type to be played
(which is passed as a dynamic parameter, as it can potentially be
changed when the user flips a switch on the real radio), but also
a script parameter, which tells it that it will be processing a radio
signal.  This can describe the frequency of the signal passing through,
relative amplitude of the signal and other signal properties.

\subsection{Pipe}

The above FMRadio function aggregates four filters into one.  While this is
useful, we define another construct to do essentially the same thing.
This new construct will
allow us to aggregate an arbitrary serial connection of fileters/blocks.
This construct will be very useful when dealing with SplitJoins, 
and other, more complex constructs:

\begin{verbatim}
BandPassFilter<script float amp, 
               script float fLow, 
               script float fHigh> ()
{
  Pipe
  {
    LowPass lowPassFilter (fLow);
    HighPass highPassFilter (fHigh);
  } 
  Amplifier amplifier (amp);
}
\end{verbatim}

Pipe allows us only to connect single input/single output blocks.

\subsection{SplitJoin}

In order to allow for splitting of single streams into multiples,
we define a SplitJoin construct:

\begin{verbatim}
Equalizer<script FileterRef filterRef,
          script SourceType sType>
          (MusicType mType)
{
  SplitJoin
  {
    RoundRobin;
    AudioEqualizer<filterRef, sType> leftAudio (mType);
    AudioEqualizer<filterRef, sType> rightAudio (mType);
    RoundRobin;
  }
}
\end{verbatim}

The first entry of a SplitJoin must be the type of splitting performed
by this SplitJoin.  There types allowed are:  RoundRobin, WeightedRoundRobin
and Duplicate.  The last field is the method for joining the streams.  
Currently only RoundRobin and WeightedRoundRobin are allowed.

WeightedRoundRobin requires extra information which indicates how many
pieces of data should go to each subsequent filter.  The syntax for it
is as follows:

\begin{verbatim}
SplitJoin
{
  WeightedRoundRobin = {1, 2, 1};
  Filter1 foo;
  Filter2 bar;
  Filter3 foobar;
  WeightedRoundRobin = {1, 2, 1};
}
\end{verbatim}

The number of weights listed in the WeighterRoundRobin definition must
match the number of filters providied in the SplitJoin.

\subsection{StreamSelect and FilterBlock}

StreamSelect allows us to dynamically change the configuration
of the stream graph.  This is done through reinitialization of 
a part of the streams.  We define a FilterBlock construct, which
is essentially an object, which can have a reference taken.
A reference to a FilterBlock is of type FilterRef.  FilterRef behaves similarly
to a C++ reference, except that it can be assigned a value after it's been
declared (though each FilterRef must be assigned exactly one value).
A FilterBlock puts up a scope wall between it and the function it
resides in.  The only way to pass it parameters is through the
script and dynamic parameters, which are set up identically to
those of a function.

FilterBlock is also used for sending messages to a block of Filters.

\begin{verbatim}
enum MusicType {
  Vocal,
  RockNRoll,
  HeavyMetal
}

AudioEqualizer<script FilterRef blockRef,
               script SourceType sType>
          (MusicType mType)
{
  FilterBlock<script SourceType sType>
          (Musictype mType)
  {
    blockRef = StreamSelect (mType)
    {
      case Vocal:
        // Vocal music sounds good without 
        // any modifications,
        // so don't do anything
      case RockNRoll:
        // want to amplify bass and treble
        LowPassFilter (0.5); // amplify
        HighPassFilter (0.5);
      case HeavyMetal:
        // only amplify the base
        LowPassFilter (0.5);
    }
  }
}
\end{verbatim}

Here is a filter that might send a message to the FilterBlock in 
the AudioEqualizer:

\begin{verbatim}
Filter VoiceControl<script FilterRef voiceBlock>
{
  script FilterRef vBlock;
  Init ()
  {
    vBlock = voiceBlock;
  }
  // on some message, switch to Vocal music:
  VoiceMsgHandler (Msg msg)
  {
    // process the msg
    ..
    // and switch
    voiceBlock.Reset (Vocal);
  }
}
\end{verbatim}

\subsection{Sources/Sinks}

Sources and Sinks are very similar to Filters, except they either have
no inputs or outputs.  They are defined just like Filters (without
input/output), and used just like Filters.  A macro function can begin/end
with a Source/Sink.  This will cause it to have
no inputs/outputs.

The first block defined by calling the main function should have
no sources.  The last one should have no sinks.

A block with no input/output can be used in the middle of a macro function  (or
other appropriate structure).  The constraint is that after/before block(s) 
with no input/output, a Split/Join is required.

\begin{verbatim}
Filter Demultiplexer
{
  input StereoSignal rrAudio;
  output StereoSignal audioOut;
  Work ()
  {
    audioOut [0] = rrAudio [0] + rrAudio [1];
  }
};

Source Microphone
{
  output StereoSignal audio;
  Init ()
  { }
  Work ()
  {
    audio [0] = GetValueFromMic ();
  }
};

Source TapePlayer 
{ ... }

Filter<script int left> SeparateStereo
{
  input StereoSignal sAudio;
  output float mAudio;
  Init ()
  { }
  Work ()
  {
    if (left)
    {
      mAudio [0] = sAudio [0].left;
    } else {
      mAudio [0] = sAudio [0].right;
    }
  }
};

Sink Speaker
{ ... }

Karaoke ()
{
  {
    Microphone ();
    TapePlayer ();
    // merge 2 streams using RoundRobin
    // merging.  Note: if we specify that
    // we want to merge 3 streams, Join
    // would also expect to get an input
    // to Kareoke
  } Join (2, RoundRobin);

  Demultiplexer ();
  // split into 2 streams using Duplicate
  // splitting;
  Split (2, Duplicate)
  {
    Pipe
    {
      SeparateStereo<0> (); // get left audio
      Speaker left ();
    }
    Pipe
    {
      SeparateStereo<1> (); // get right audio
      Speaker right ();
    }
  }
}
\end{verbatim}

\subsection{FeedbackLoop}

Some stream applications require feedback loops for data processing.
Here we define a type that allows us to create feedback loops
in our stream graph.

A FeedbackLoop construct is very similar to Pipe.  It connects
several blocks in a serial connection, but it also allows to connect
the output of the pipe to the first block of the FeedbackLoop through
a FeedbackPath (which must be the last statement of the FeedbackLoop).
Since the first filter in a FeedbackLoop accepts
two inputs, this filter must be of FeedbackFilter type.

\begin{verbatim}
FeedbackFilter NegFeedbackAmplifierFilter
        (float amp, float gain)
{
  input float audioIn;
  feedbackinput float feedback;
  output float audioOut;
  Work ()
  {
    // this basically implements a negative feedback
    // loop with an amp of set gain and a set target
    // amplification.
    float in = audioIn [0];
    float out = feedback [0];
    float negFeed = in + 
      (in + out) / (amp + 1);
    float result = - negFeed * gain;
    audioOut [0] = result;
  }
  Init () { }
};

Filter NegFeedbackBuffer<int delay>
{
  input float in;
  output float out;
  Work ()
  {
    in [0] = out [0];
  }

  Init ()
  {
    sfor (static int i = 0; i < delay; i++)
    {
      out [i] = 0;
    }
  }
};

NegFeedbackAmplifier ()
{
  FeedbackLoop
  {
    NegFeedbackAmplifierFilter (10, 1000);
    FeedbackPath NegFeedbackFilter<2>;
  }
}
\end{verbatim}

\begin{comment}
\include{grammar}
\end{comment}

\begin{comment}

\begin{figure}[t]
\centerline{\psfig{figure=block.ps}}
\vspace{-24pt}
\caption{\protect\small The block construct.}
\end{figure}

\section{old stuff}

\begin{lgrind}
\input{code.tex}
\end{lgrind}

\end{comment}

\end{document}

