% -*- LaTeX -*-
% This is a noweb source file.  To produce a LaTeX file from it:
%   noweave -delay -x streamit.h.nw > streamit.tex
% To produce the C header file:
%   notangle -Rstreamit.h > streamit.h

\documentclass{article}
\usepackage{fullpage}
\usepackage{noweb}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1.2ex plus 0.3ex minus 0.2ex}
\pagestyle{noweb}

\title{StreaMIT C Runtime Interface}
\author{ComMIT Streams Group}

\begin{document}
\maketitle

%

\section{Preliminaries}

This document describes a C interface for compiling StreaMIT programs
against a runtime library.  The StreaMIT compiler processes its input
file and eventually produces a C source file, which is compiled with
this header file and linked against the runtime library.  The compiler
generates a set of functions, including a top-level init function for
the entire program.  This function in turn calls lower-level init
functions, causing the entire system to be initialized.  During
initialization the runtime system is informed of the connectivity
between modules and the layout of objects in memory.

\subsection{Assumptions}

This definition makes a number of assumptions about the StreaMIT
language, which may be relaxed or removed in later versions of the
system.  These currently include:

\begin{description}

\item[No re-initialization.]

\item[Canonical ordering.]  Several parts of this document refer to a
  ``canonical ordering''; that ordering is just a lexicographical
  ordering of eligible names.  For ordering tapes, the canonical order
  is a left-to-right reading across blocks.

\item[Message timing.]  StreaMIT currently only does best-effort
  message delivery; the latencies requested in message functions are
  not necessarily respected.

\end{description}

\subsection{Outstanding Questions}

\begin{itemize}

\item The compiler will need to determine the exact number of items
  that can reasonably be assumed to exist on a tape.  This requires a
  full analysis of init functions' peeking behavior.  Otherwise, the
  correct push/pop ratios could be established for steady-state
  behavior, but the runtime system couldn't set the system up properly
  because it wouldn't know how many residual items need to exist on
  the tapes.

\item What do you think about a traversal order for sub-streams that
  is used to declare contents and minimum firing contents of tapes
  implicitly, without a naming convention?  Also used to go from order
  of declaration to stream structure.  We could do something
  heirarchical instead of flat, but I'm guessing that flat might be
  easier inside the compiler.  We'll want to translate to heirarchical
  inside the runtime system, anyways.

\item How do splitters and joiners fit into the scheme?  A split/join
  structure consists of split-body-join, and a feedback loop has
  join-body-split.  Splitters and joiners are the only things that
  violate the one-input/one-output rule, and need to be implemented in
  the library.

\end{itemize}


\section{Basic Types}

<<Basic Types>>=
<<Enumerations>>
<<Latencies>>
<<Other Types>>
@

\subsection{Enumerations}

There are a couple of simple enumerations that are needed to describe
the types of objects in the StreaMIT system.  The compiler needs to
know the type of a stream structure:

<<Enumerations>>=
typedef enum stream_type {
  INVALID_STREAM_TYPE,
  FILTER,
  PIPELINE,
  SPLIT_JOIN,
  FEEDBACK_LOOP
} stream_type;
@

For split/join structures, there also need to be constants for the
types of splitters and joiners.

<<Enumerations>>=
typedef enum splitjoin_type {
  ROUND_ROBIN,
  DUPLICATE,
  COMBINE,
  NULL_SJ
} splitjoin_type;
@

\subsection{Latencies}

Latencies can be expressed as a linked list of discrete values or a
continuous range of possible values.  There are also special-case
values that can be used in certain circumstances (for example,
requesting best-effort delivery).

<<Latencies>>=
typedef struct latency_list {
  int val;
  struct latency_list *next;
} latency_list;

typedef struct latency_range {
  int min_val;
  int max_val;
} latency_range;

typedef enum latency_special {
  _BEST_EFFORT
} latency_special;

typedef union latency {
  latency_list list;
  latency_range range;
  latency_special special;
} latency;

#define LATENCY_BEST_EFFORT ((latency){ special: _BEST_EFFORT })
@

\subsection{Other Types}

Some miscellaneous types are needed by other parts of the runtime
system.  Several functions take callback functions as parameters, so
we define a standard type for those:

<<Other Types>>=
typedef void (*streamit_handler)(void *);
@

There are more specialized types of handler functions for work
functions.

<<Other Types>>=
typedef void (*work_fn)(void *);
@

Interface tables are used for message handling.  An interface defines
a set of functions that can be called as message targets.  Each class
that implements an interface needs to provide a mapping between
interface message numbers and functions to be called.

<<Other Types>>=
typedef streamit_handler *interface_table;
@

\section{Function-Call Interface}

<<Interface Functions>>=
<<Initialization Functions>>
<<Split/Join Initializers>>
<<Messaging Functions>>
<<Run Function>>
@

\subsection{Initialization}

An initialization function is called for each filter.  The
initialization function, in turn, needs to call several functions to
inform the run-time library of the internal structure of the filter.
[[set_stream_type]] tells the run-time library the type of the current
stream object; [[set_peek]], [[set_pop]], and [[set_push]] tell the
library the number of items examined and removed from the input tape
and added to the output tape on each iteration.

<<Initialization Functions>>=
void set_stream_type(stream_context *c, stream_type type);
void set_peek(stream_context *c, int peeks);
void set_pop(stream_context *c, int pops);
void set_push(stream_context *c, int pushes);
@

Several handler functions can be registered with the run-time
library.  Every filter should call [[set_work]] to register its work
function.

<<Initialization Functions>>=
void set_work(stream_context *c, work_fn f);
void set_teardown(stream_context *c, streamit_handler f);
@

Children also need to be registered with the library, so that the
library can determine the layout of the stream.

<<Initialization Functions>>=
void register_child(stream_context *c, stream_context *child);
stream_context *get_parent(stream_context *c);
@

Once children have been created, parents are responsible for creating
tapes between them.  The actual tape structure is defined later in
this document; initialization code should treat tapes as opaque.
[[create_tape]] creates a tape between two simple stream objects; the
tape is connected to [[a]]'s output and [[b]]'s input.  It requires
the tape object sizes to be consistent, and creates a tape at least
large enough to handle steady-state execution.

<<Initialization Functions>>=
tape *create_tape(stream_context *a, stream_context *b,
                  int data_size, int tape_length);
@

Every object should have a ``canonical form''.  Internally, fast-path
code might want to grab parameters of its children to perform SIMD
operations between parallel streams, or perform other optimizations.
However, when blocks are deconstructed and reconstructed, data needs
to exist in the canonical form.

Two functions perform this translation between canonical format and
optimized format.  [[set_to_canon]] registers a function that ensures
that required state is available in canonical form.
[[set_from_canon]] takes state in canonical form, and prepares for
continued steady-state execution.

<<Initialization Functions>>=
void set_to_canon(stream_context *c, streamit_handler f);
void set_from_canon(stream_context *c, streamit_handler f);
@

\subsection{Splitters and Joiners}

Splitters and joiners are used extensively in StreaMIT.  A split/join
structure contains a splitter, some number of body nodes, and a
joiner; a feedback loop contains a joiner, its body, and a splitter,
with one output from the joiner pointing back into the splitter.

Splitters and joiners are the only structures that do not have exactly
one input and one output.  Splitters have multiple outputs; joiners
have multiple inputs.  This requires special support from the runtime
library.

[[set_splitter]] and [[set_joiner]] create splitter and joiner nodes
within the stream graph.  Both functions take a [[splitjoin_type]] as
their first parameter, indicating the type of the splitter or joiner.
The second parameter is the fan-out/in of the splitter or joiner.  The
remaining parameters are the number of consecutive items that go to
each stream, for a [[ROUND_ROBIN]] type.  There are assumed to be
exactly [[n]] ratio items.

A particular stream structure is assumed to have at most one splitter
or joiner.  A [[SPLIT_JOIN]] has the splitter at the top of the block,
and the joiner at the bottom; there should be [[n]] calls to
[[register_child]], which register child objects in order.  A
[[FEEDBACK_LOOP]] has the joiner at the top of the block, and the
splitter at the bottom; [[n]] should be exactly [[2]].  The two
children added are for the body and the feedback edge, in that order.
The [[set_joiner]] ratios are for the entry path and the feedback
edge, in that order; the [[set_splitter]] ratios are for the exit path
and the feedback edge.

<<Split/Join Initializers>>=
void set_splitter(stream_context *c, splitjoin_type type, int n, ...);
void set_joiner(stream_context *c, splitjoin_type type, int n, ...);
@

Tapes must be explicitly created between splitters, joiners, and other
nodes.  [[create_split_tape]] and [[create_join_tape]] do this work;
they are similar to [[create_tape]], but to identify the source and
destination of the tape, they take parameters for the containing
context and the slot number (indexed from 0) on the splitter
output/joiner input.

<<Split/Join Initializers>>=
void create_split_tape(stream_context *container, int slot,
                       int data_size, int tape_length);
void create_join_tape(stream_context *container, int slot,
                      int data_size, int tape_length);
@

It is an error to call splitter and joiner functions when they are not
relevant.  In particular, no splitter or joiner functions may be
called on [[FILTER]] or [[PIPELINE]] nodes.  [[create_split_tape]] and
[[create_join_tape]] also may not be called for slots that don't exist
in the splitter or joiner structures.  The run-time library also does
consistency checking: the splitter and joiner must have the same
number of slots, and each input and output tape must have the same
size.

\subsection{Messaging}

Messages can be sent between filters.  Both senders and receivers must
register with the run-time library.  Messages are referenced by
indices into a list of canonically-ordered handler functions.  Each
object type should export a list of function pointers for each
handler.

Messages are sent through a portal; see the StreaMIT language
documentation for how this works.

<<Messaging Functions>>=
portal *create_portal(void);
void register_receiver(portal *p, stream_context *receiver,
                       interface_table *vtbl, latency *l);
void register_sender(portal *p, stream_context *sender, latency *l);
@

To send a message, you need to know the message number, the portal,
the required latency, and the parameters to send on.  It's unclear at
the moment how parameters will get packaged up.

<<Messaging Functions>>=
void send_message(portal *p, int msgid, latency *l, ...);
@

\subsection{Starting the System}

The [[streamit_run]] function is called with the context of the
top-level object.  It runs the system continuously.

<<Run Function>>=
void streamit_run(stream_context *c);
@

\section{Internal Library Types}

<<Opaque Types>>=
<<Tapes>>
<<Stream Context>>
<<Portal>>
@

\subsection{Tapes}

Data is passed between streams on tapes.  The tape structure can be
manipulated directly by work functions if need be.  The [[data]] is
allocated by the creator of the tape, and its size is exactly
[[len * size]] bytes.  [[read_pos]] and [[write_pos]] are both
integers greater than or equal to [[0]] and strictly less than
[[len]], and point to [[size]]-byte offsets into [[data]].  In
particular, they point to the last item read or written to the tape,
such that [[PUSH]], [[POP]], and [[PEEK(0)]] will all use the
following item.

<<Tapes>>=
typedef struct tape {
  void *data;
  int read_pos;
  int write_pos;
  int data_size;
  int tape_length;
} tape;
@

There are macros defined to manipulate tapes.  [[PUSH]] adds an item
to the writer end of the tape; [[PEEK]] and [[POP]] both read data
from the reader end.

<<Tapes>>=
#define PUSH(c, type, d) { if (++(c)->output_tape->write_pos >= (c)->output_tape->tape_length ) \
                             (c)->output_tape->write_pos = 0; \
                           ((type *)(c)->output_tape->data)[(c)->output_tape->write_pos] = (d); }
#define PEEK(c, type, n) (((type *)c->input_tape->data)[(c->input_tape->read_pos+n)%c->input_tape->tape_length])
#define POP(c, type) ((((++c->input_tape->read_pos) >= c->input_tape->tape_length) ? (c->input_tape->read_pos = 0) : 0), \
                      ((type *)c->input_tape->data)[c->input_tape->read_pos])
@

\subsection{Filter Context}

A context structure is used to store data used by the run-time
library.  Depending on the type of the stream, it may store some
internal data.

<<Stream Context>>=
struct stream_context;

typedef struct stream_context_list {
  struct stream_context *context;
  struct stream_context_list *next;
} stream_context_list;

typedef struct pipeline_type_data {
  stream_context_list *first_child;
  stream_context_list *last_child;
} pipeline_type_data;

typedef union stream_type_data {
  pipeline_type_data pipeline_data;
} stream_type_data;
@

The actual context structure contains a [[stream_type_data]] union,
along with quite a bit of other information.  This includes the object
the stream is associated with, the type of the stream, the data
ratios, the work function, the parent context, and the input and
output tapes.  Note that two objects should point to any given tape,
one reading from it and one writing to it.

<<Stream Context>>=
typedef struct stream_context {
  void *stream_data;
  stream_type type;
  int peek_size, pop_size, push_size;
  work_fn work_function;
  struct stream_context *parent;
  tape *input_tape;
  tape *output_tape;
  stream_type_data type_data;
} stream_context;
@

Contexts are created by [[create_context]], which takes a pointer to
the data object the context is relevant for.

<<Stream Context>>=
stream_context *create_context(void *p);
@

\subsection{Portals}

Messages are sent to portals.  Portals currently only track the list
of receiving contexts.

<<Portal>>=
typedef struct portal {
  stream_context_list *destinations;
} portal;
@

\section{Header File}

<<streamit.h>>=
#ifndef STREAMIT_H
#define STREAMIT_H

<<Basic Types>>
<<Opaque Types>>
<<Interface Functions>>

#endif /* STREAMIT_H */
@

\end{document}

%%% Local variables:
%%% mmm-classes: noweb-c
%%% End:
